
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AnchorText
 * 
 */
export type AnchorText = $Result.DefaultSelection<Prisma.$AnchorTextPayload>
/**
 * Model Announcements
 * 
 */
export type Announcements = $Result.DefaultSelection<Prisma.$AnnouncementsPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model BestSelling
 * 
 */
export type BestSelling = $Result.DefaultSelection<Prisma.$BestSellingPayload>
/**
 * Model CallRequest
 * 
 */
export type CallRequest = $Result.DefaultSelection<Prisma.$CallRequestPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model ContactUs
 * 
 */
export type ContactUs = $Result.DefaultSelection<Prisma.$ContactUsPayload>
/**
 * Model CustomerType
 * 
 */
export type CustomerType = $Result.DefaultSelection<Prisma.$CustomerTypePayload>
/**
 * Model DeleteRequest
 * 
 */
export type DeleteRequest = $Result.DefaultSelection<Prisma.$DeleteRequestPayload>
/**
 * Model Discount
 * 
 */
export type Discount = $Result.DefaultSelection<Prisma.$DiscountPayload>
/**
 * Model DropMessage
 * 
 */
export type DropMessage = $Result.DefaultSelection<Prisma.$DropMessagePayload>
/**
 * Model ExclusiveCollection
 * 
 */
export type ExclusiveCollection = $Result.DefaultSelection<Prisma.$ExclusiveCollectionPayload>
/**
 * Model HeroSliders
 * 
 */
export type HeroSliders = $Result.DefaultSelection<Prisma.$HeroSlidersPayload>
/**
 * Model ImageWeek
 * 
 */
export type ImageWeek = $Result.DefaultSelection<Prisma.$ImageWeekPayload>
/**
 * Model Logos
 * 
 */
export type Logos = $Result.DefaultSelection<Prisma.$LogosPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model NewArrivals
 * 
 */
export type NewArrivals = $Result.DefaultSelection<Prisma.$NewArrivalsPayload>
/**
 * Model Newsletter
 * 
 */
export type Newsletter = $Result.DefaultSelection<Prisma.$NewsletterPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model OrderDetails
 * 
 */
export type OrderDetails = $Result.DefaultSelection<Prisma.$OrderDetailsPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model PaymentDetails
 * 
 */
export type PaymentDetails = $Result.DefaultSelection<Prisma.$PaymentDetailsPayload>
/**
 * Model Privilege
 * 
 */
export type Privilege = $Result.DefaultSelection<Prisma.$PrivilegePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model ProductColor
 * 
 */
export type ProductColor = $Result.DefaultSelection<Prisma.$ProductColorPayload>
/**
 * Model ProductFabric
 * 
 */
export type ProductFabric = $Result.DefaultSelection<Prisma.$ProductFabricPayload>
/**
 * Model ProductImage
 * 
 */
export type ProductImage = $Result.DefaultSelection<Prisma.$ProductImagePayload>
/**
 * Model ProductInventory
 * 
 */
export type ProductInventory = $Result.DefaultSelection<Prisma.$ProductInventoryPayload>
/**
 * Model ProductReview
 * 
 */
export type ProductReview = $Result.DefaultSelection<Prisma.$ProductReviewPayload>
/**
 * Model ProductSize
 * 
 */
export type ProductSize = $Result.DefaultSelection<Prisma.$ProductSizePayload>
/**
 * Model ProductWeek
 * 
 */
export type ProductWeek = $Result.DefaultSelection<Prisma.$ProductWeekPayload>
/**
 * Model Quotes
 * 
 */
export type Quotes = $Result.DefaultSelection<Prisma.$QuotesPayload>
/**
 * Model ReturnRequest
 * 
 */
export type ReturnRequest = $Result.DefaultSelection<Prisma.$ReturnRequestPayload>
/**
 * Model Rewards
 * 
 */
export type Rewards = $Result.DefaultSelection<Prisma.$RewardsPayload>
/**
 * Model SearchQuery
 * 
 */
export type SearchQuery = $Result.DefaultSelection<Prisma.$SearchQueryPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model ShopByOccasion
 * 
 */
export type ShopByOccasion = $Result.DefaultSelection<Prisma.$ShopByOccasionPayload>
/**
 * Model ShopByOccasionProduct
 * 
 */
export type ShopByOccasionProduct = $Result.DefaultSelection<Prisma.$ShopByOccasionProductPayload>
/**
 * Model ShopBySeason
 * 
 */
export type ShopBySeason = $Result.DefaultSelection<Prisma.$ShopBySeasonPayload>
/**
 * Model ShopBySeasonProduct
 * 
 */
export type ShopBySeasonProduct = $Result.DefaultSelection<Prisma.$ShopBySeasonProductPayload>
/**
 * Model Showcases
 * 
 */
export type Showcases = $Result.DefaultSelection<Prisma.$ShowcasesPayload>
/**
 * Model SizeChart
 * 
 */
export type SizeChart = $Result.DefaultSelection<Prisma.$SizeChartPayload>
/**
 * Model SocialLinks
 * 
 */
export type SocialLinks = $Result.DefaultSelection<Prisma.$SocialLinksPayload>
/**
 * Model StaticMessages
 * 
 */
export type StaticMessages = $Result.DefaultSelection<Prisma.$StaticMessagesPayload>
/**
 * Model SubCategory
 * 
 */
export type SubCategory = $Result.DefaultSelection<Prisma.$SubCategoryPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model Tags
 * 
 */
export type Tags = $Result.DefaultSelection<Prisma.$TagsPayload>
/**
 * Model Trending
 * 
 */
export type Trending = $Result.DefaultSelection<Prisma.$TrendingPayload>
/**
 * Model UpdateHistory
 * 
 */
export type UpdateHistory = $Result.DefaultSelection<Prisma.$UpdateHistoryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserAddress
 * 
 */
export type UserAddress = $Result.DefaultSelection<Prisma.$UserAddressPayload>
/**
 * Model UserPrivilege
 * 
 */
export type UserPrivilege = $Result.DefaultSelection<Prisma.$UserPrivilegePayload>
/**
 * Model Vides
 * 
 */
export type Vides = $Result.DefaultSelection<Prisma.$VidesPayload>
/**
 * Model Visitor
 * 
 */
export type Visitor = $Result.DefaultSelection<Prisma.$VisitorPayload>
/**
 * Model WishlistItem
 * 
 */
export type WishlistItem = $Result.DefaultSelection<Prisma.$WishlistItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StaticMessages_status: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type StaticMessages_status = (typeof StaticMessages_status)[keyof typeof StaticMessages_status]


export const OrderDetails_status: {
  INCOMPLETE: 'INCOMPLETE',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  SHIPPED: 'SHIPPED',
  INTRANSIT: 'INTRANSIT',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type OrderDetails_status = (typeof OrderDetails_status)[keyof typeof OrderDetails_status]


export const ReturnRequest_status: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  REFUNDED: 'REFUNDED'
};

export type ReturnRequest_status = (typeof ReturnRequest_status)[keyof typeof ReturnRequest_status]


export const Discount_type: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED: 'FIXED'
};

export type Discount_type = (typeof Discount_type)[keyof typeof Discount_type]


export const SupportTicket_status: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type SupportTicket_status = (typeof SupportTicket_status)[keyof typeof SupportTicket_status]


export const DeleteRequest_status: {
  REVIEW: 'REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type DeleteRequest_status = (typeof DeleteRequest_status)[keyof typeof DeleteRequest_status]


export const User_role: {
  ADMIN: 'ADMIN',
  SELLER: 'SELLER',
  BUYER: 'BUYER',
  STAFF: 'STAFF'
};

export type User_role = (typeof User_role)[keyof typeof User_role]


export const OrderDetails_paymentMethod: {
  COD: 'COD',
  ONLINE: 'ONLINE'
};

export type OrderDetails_paymentMethod = (typeof OrderDetails_paymentMethod)[keyof typeof OrderDetails_paymentMethod]


export const User_status: {
  ACTIVE: 'ACTIVE',
  DEACTIVE: 'DEACTIVE',
  BANNED: 'BANNED'
};

export type User_status = (typeof User_status)[keyof typeof User_status]

}

export type StaticMessages_status = $Enums.StaticMessages_status

export const StaticMessages_status: typeof $Enums.StaticMessages_status

export type OrderDetails_status = $Enums.OrderDetails_status

export const OrderDetails_status: typeof $Enums.OrderDetails_status

export type ReturnRequest_status = $Enums.ReturnRequest_status

export const ReturnRequest_status: typeof $Enums.ReturnRequest_status

export type Discount_type = $Enums.Discount_type

export const Discount_type: typeof $Enums.Discount_type

export type SupportTicket_status = $Enums.SupportTicket_status

export const SupportTicket_status: typeof $Enums.SupportTicket_status

export type DeleteRequest_status = $Enums.DeleteRequest_status

export const DeleteRequest_status: typeof $Enums.DeleteRequest_status

export type User_role = $Enums.User_role

export const User_role: typeof $Enums.User_role

export type OrderDetails_paymentMethod = $Enums.OrderDetails_paymentMethod

export const OrderDetails_paymentMethod: typeof $Enums.OrderDetails_paymentMethod

export type User_status = $Enums.User_status

export const User_status: typeof $Enums.User_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AnchorTexts
 * const anchorTexts = await prisma.anchorText.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AnchorTexts
   * const anchorTexts = await prisma.anchorText.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.anchorText`: Exposes CRUD operations for the **AnchorText** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnchorTexts
    * const anchorTexts = await prisma.anchorText.findMany()
    * ```
    */
  get anchorText(): Prisma.AnchorTextDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcements`: Exposes CRUD operations for the **Announcements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcements.findMany()
    * ```
    */
  get announcements(): Prisma.AnnouncementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bestSelling`: Exposes CRUD operations for the **BestSelling** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BestSellings
    * const bestSellings = await prisma.bestSelling.findMany()
    * ```
    */
  get bestSelling(): Prisma.BestSellingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callRequest`: Exposes CRUD operations for the **CallRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallRequests
    * const callRequests = await prisma.callRequest.findMany()
    * ```
    */
  get callRequest(): Prisma.CallRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactUs`: Exposes CRUD operations for the **ContactUs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactuses
    * const contactuses = await prisma.contactUs.findMany()
    * ```
    */
  get contactUs(): Prisma.ContactUsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerType`: Exposes CRUD operations for the **CustomerType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerTypes
    * const customerTypes = await prisma.customerType.findMany()
    * ```
    */
  get customerType(): Prisma.CustomerTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deleteRequest`: Exposes CRUD operations for the **DeleteRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeleteRequests
    * const deleteRequests = await prisma.deleteRequest.findMany()
    * ```
    */
  get deleteRequest(): Prisma.DeleteRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dropMessage`: Exposes CRUD operations for the **DropMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DropMessages
    * const dropMessages = await prisma.dropMessage.findMany()
    * ```
    */
  get dropMessage(): Prisma.DropMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exclusiveCollection`: Exposes CRUD operations for the **ExclusiveCollection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExclusiveCollections
    * const exclusiveCollections = await prisma.exclusiveCollection.findMany()
    * ```
    */
  get exclusiveCollection(): Prisma.ExclusiveCollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.heroSliders`: Exposes CRUD operations for the **HeroSliders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeroSliders
    * const heroSliders = await prisma.heroSliders.findMany()
    * ```
    */
  get heroSliders(): Prisma.HeroSlidersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.imageWeek`: Exposes CRUD operations for the **ImageWeek** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImageWeeks
    * const imageWeeks = await prisma.imageWeek.findMany()
    * ```
    */
  get imageWeek(): Prisma.ImageWeekDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logos`: Exposes CRUD operations for the **Logos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logos
    * const logos = await prisma.logos.findMany()
    * ```
    */
  get logos(): Prisma.LogosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newArrivals`: Exposes CRUD operations for the **NewArrivals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewArrivals
    * const newArrivals = await prisma.newArrivals.findMany()
    * ```
    */
  get newArrivals(): Prisma.NewArrivalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.newsletter`: Exposes CRUD operations for the **Newsletter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newsletters
    * const newsletters = await prisma.newsletter.findMany()
    * ```
    */
  get newsletter(): Prisma.NewsletterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderDetails`: Exposes CRUD operations for the **OrderDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderDetails
    * const orderDetails = await prisma.orderDetails.findMany()
    * ```
    */
  get orderDetails(): Prisma.OrderDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentDetails`: Exposes CRUD operations for the **PaymentDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentDetails
    * const paymentDetails = await prisma.paymentDetails.findMany()
    * ```
    */
  get paymentDetails(): Prisma.PaymentDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privilege`: Exposes CRUD operations for the **Privilege** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Privileges
    * const privileges = await prisma.privilege.findMany()
    * ```
    */
  get privilege(): Prisma.PrivilegeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productColor`: Exposes CRUD operations for the **ProductColor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductColors
    * const productColors = await prisma.productColor.findMany()
    * ```
    */
  get productColor(): Prisma.ProductColorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productFabric`: Exposes CRUD operations for the **ProductFabric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductFabrics
    * const productFabrics = await prisma.productFabric.findMany()
    * ```
    */
  get productFabric(): Prisma.ProductFabricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productInventory`: Exposes CRUD operations for the **ProductInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductInventories
    * const productInventories = await prisma.productInventory.findMany()
    * ```
    */
  get productInventory(): Prisma.ProductInventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productReview`: Exposes CRUD operations for the **ProductReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductReviews
    * const productReviews = await prisma.productReview.findMany()
    * ```
    */
  get productReview(): Prisma.ProductReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productSize`: Exposes CRUD operations for the **ProductSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductSizes
    * const productSizes = await prisma.productSize.findMany()
    * ```
    */
  get productSize(): Prisma.ProductSizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productWeek`: Exposes CRUD operations for the **ProductWeek** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductWeeks
    * const productWeeks = await prisma.productWeek.findMany()
    * ```
    */
  get productWeek(): Prisma.ProductWeekDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotes`: Exposes CRUD operations for the **Quotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quotes.findMany()
    * ```
    */
  get quotes(): Prisma.QuotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.returnRequest`: Exposes CRUD operations for the **ReturnRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnRequests
    * const returnRequests = await prisma.returnRequest.findMany()
    * ```
    */
  get returnRequest(): Prisma.ReturnRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewards`: Exposes CRUD operations for the **Rewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.rewards.findMany()
    * ```
    */
  get rewards(): Prisma.RewardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchQuery`: Exposes CRUD operations for the **SearchQuery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchQueries
    * const searchQueries = await prisma.searchQuery.findMany()
    * ```
    */
  get searchQuery(): Prisma.SearchQueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopByOccasion`: Exposes CRUD operations for the **ShopByOccasion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopByOccasions
    * const shopByOccasions = await prisma.shopByOccasion.findMany()
    * ```
    */
  get shopByOccasion(): Prisma.ShopByOccasionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopByOccasionProduct`: Exposes CRUD operations for the **ShopByOccasionProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopByOccasionProducts
    * const shopByOccasionProducts = await prisma.shopByOccasionProduct.findMany()
    * ```
    */
  get shopByOccasionProduct(): Prisma.ShopByOccasionProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopBySeason`: Exposes CRUD operations for the **ShopBySeason** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopBySeasons
    * const shopBySeasons = await prisma.shopBySeason.findMany()
    * ```
    */
  get shopBySeason(): Prisma.ShopBySeasonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shopBySeasonProduct`: Exposes CRUD operations for the **ShopBySeasonProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopBySeasonProducts
    * const shopBySeasonProducts = await prisma.shopBySeasonProduct.findMany()
    * ```
    */
  get shopBySeasonProduct(): Prisma.ShopBySeasonProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.showcases`: Exposes CRUD operations for the **Showcases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Showcases
    * const showcases = await prisma.showcases.findMany()
    * ```
    */
  get showcases(): Prisma.ShowcasesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sizeChart`: Exposes CRUD operations for the **SizeChart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SizeCharts
    * const sizeCharts = await prisma.sizeChart.findMany()
    * ```
    */
  get sizeChart(): Prisma.SizeChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialLinks`: Exposes CRUD operations for the **SocialLinks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialLinks
    * const socialLinks = await prisma.socialLinks.findMany()
    * ```
    */
  get socialLinks(): Prisma.SocialLinksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staticMessages`: Exposes CRUD operations for the **StaticMessages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaticMessages
    * const staticMessages = await prisma.staticMessages.findMany()
    * ```
    */
  get staticMessages(): Prisma.StaticMessagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subCategory`: Exposes CRUD operations for the **SubCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategories
    * const subCategories = await prisma.subCategory.findMany()
    * ```
    */
  get subCategory(): Prisma.SubCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **Tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.TagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trending`: Exposes CRUD operations for the **Trending** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trendings
    * const trendings = await prisma.trending.findMany()
    * ```
    */
  get trending(): Prisma.TrendingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.updateHistory`: Exposes CRUD operations for the **UpdateHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UpdateHistories
    * const updateHistories = await prisma.updateHistory.findMany()
    * ```
    */
  get updateHistory(): Prisma.UpdateHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAddress`: Exposes CRUD operations for the **UserAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAddresses
    * const userAddresses = await prisma.userAddress.findMany()
    * ```
    */
  get userAddress(): Prisma.UserAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPrivilege`: Exposes CRUD operations for the **UserPrivilege** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPrivileges
    * const userPrivileges = await prisma.userPrivilege.findMany()
    * ```
    */
  get userPrivilege(): Prisma.UserPrivilegeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vides`: Exposes CRUD operations for the **Vides** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vides
    * const vides = await prisma.vides.findMany()
    * ```
    */
  get vides(): Prisma.VidesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitor`: Exposes CRUD operations for the **Visitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Visitors
    * const visitors = await prisma.visitor.findMany()
    * ```
    */
  get visitor(): Prisma.VisitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wishlistItem`: Exposes CRUD operations for the **WishlistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishlistItems
    * const wishlistItems = await prisma.wishlistItem.findMany()
    * ```
    */
  get wishlistItem(): Prisma.WishlistItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AnchorText: 'AnchorText',
    Announcements: 'Announcements',
    AuditLog: 'AuditLog',
    BestSelling: 'BestSelling',
    CallRequest: 'CallRequest',
    CartItem: 'CartItem',
    ContactUs: 'ContactUs',
    CustomerType: 'CustomerType',
    DeleteRequest: 'DeleteRequest',
    Discount: 'Discount',
    DropMessage: 'DropMessage',
    ExclusiveCollection: 'ExclusiveCollection',
    HeroSliders: 'HeroSliders',
    ImageWeek: 'ImageWeek',
    Logos: 'Logos',
    Message: 'Message',
    NewArrivals: 'NewArrivals',
    Newsletter: 'Newsletter',
    Notification: 'Notification',
    OrderDetails: 'OrderDetails',
    OrderItem: 'OrderItem',
    Otp: 'Otp',
    PaymentDetails: 'PaymentDetails',
    Privilege: 'Privilege',
    Product: 'Product',
    ProductCategory: 'ProductCategory',
    ProductColor: 'ProductColor',
    ProductFabric: 'ProductFabric',
    ProductImage: 'ProductImage',
    ProductInventory: 'ProductInventory',
    ProductReview: 'ProductReview',
    ProductSize: 'ProductSize',
    ProductWeek: 'ProductWeek',
    Quotes: 'Quotes',
    ReturnRequest: 'ReturnRequest',
    Rewards: 'Rewards',
    SearchQuery: 'SearchQuery',
    Session: 'Session',
    ShopByOccasion: 'ShopByOccasion',
    ShopByOccasionProduct: 'ShopByOccasionProduct',
    ShopBySeason: 'ShopBySeason',
    ShopBySeasonProduct: 'ShopBySeasonProduct',
    Showcases: 'Showcases',
    SizeChart: 'SizeChart',
    SocialLinks: 'SocialLinks',
    StaticMessages: 'StaticMessages',
    SubCategory: 'SubCategory',
    SupportTicket: 'SupportTicket',
    Tags: 'Tags',
    Trending: 'Trending',
    UpdateHistory: 'UpdateHistory',
    User: 'User',
    UserAddress: 'UserAddress',
    UserPrivilege: 'UserPrivilege',
    Vides: 'Vides',
    Visitor: 'Visitor',
    WishlistItem: 'WishlistItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "anchorText" | "announcements" | "auditLog" | "bestSelling" | "callRequest" | "cartItem" | "contactUs" | "customerType" | "deleteRequest" | "discount" | "dropMessage" | "exclusiveCollection" | "heroSliders" | "imageWeek" | "logos" | "message" | "newArrivals" | "newsletter" | "notification" | "orderDetails" | "orderItem" | "otp" | "paymentDetails" | "privilege" | "product" | "productCategory" | "productColor" | "productFabric" | "productImage" | "productInventory" | "productReview" | "productSize" | "productWeek" | "quotes" | "returnRequest" | "rewards" | "searchQuery" | "session" | "shopByOccasion" | "shopByOccasionProduct" | "shopBySeason" | "shopBySeasonProduct" | "showcases" | "sizeChart" | "socialLinks" | "staticMessages" | "subCategory" | "supportTicket" | "tags" | "trending" | "updateHistory" | "user" | "userAddress" | "userPrivilege" | "vides" | "visitor" | "wishlistItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AnchorText: {
        payload: Prisma.$AnchorTextPayload<ExtArgs>
        fields: Prisma.AnchorTextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnchorTextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnchorTextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnchorTextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnchorTextPayload>
          }
          findFirst: {
            args: Prisma.AnchorTextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnchorTextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnchorTextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnchorTextPayload>
          }
          findMany: {
            args: Prisma.AnchorTextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnchorTextPayload>[]
          }
          create: {
            args: Prisma.AnchorTextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnchorTextPayload>
          }
          createMany: {
            args: Prisma.AnchorTextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnchorTextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnchorTextPayload>
          }
          update: {
            args: Prisma.AnchorTextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnchorTextPayload>
          }
          deleteMany: {
            args: Prisma.AnchorTextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnchorTextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnchorTextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnchorTextPayload>
          }
          aggregate: {
            args: Prisma.AnchorTextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnchorText>
          }
          groupBy: {
            args: Prisma.AnchorTextGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnchorTextGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnchorTextCountArgs<ExtArgs>
            result: $Utils.Optional<AnchorTextCountAggregateOutputType> | number
          }
        }
      }
      Announcements: {
        payload: Prisma.$AnnouncementsPayload<ExtArgs>
        fields: Prisma.AnnouncementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          findMany: {
            args: Prisma.AnnouncementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>[]
          }
          create: {
            args: Prisma.AnnouncementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          createMany: {
            args: Prisma.AnnouncementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnnouncementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          update: {
            args: Prisma.AnnouncementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnnouncementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementsPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncements>
          }
          groupBy: {
            args: Prisma.AnnouncementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementsCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementsCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      BestSelling: {
        payload: Prisma.$BestSellingPayload<ExtArgs>
        fields: Prisma.BestSellingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BestSellingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BestSellingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BestSellingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BestSellingPayload>
          }
          findFirst: {
            args: Prisma.BestSellingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BestSellingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BestSellingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BestSellingPayload>
          }
          findMany: {
            args: Prisma.BestSellingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BestSellingPayload>[]
          }
          create: {
            args: Prisma.BestSellingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BestSellingPayload>
          }
          createMany: {
            args: Prisma.BestSellingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BestSellingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BestSellingPayload>
          }
          update: {
            args: Prisma.BestSellingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BestSellingPayload>
          }
          deleteMany: {
            args: Prisma.BestSellingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BestSellingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BestSellingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BestSellingPayload>
          }
          aggregate: {
            args: Prisma.BestSellingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBestSelling>
          }
          groupBy: {
            args: Prisma.BestSellingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BestSellingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BestSellingCountArgs<ExtArgs>
            result: $Utils.Optional<BestSellingCountAggregateOutputType> | number
          }
        }
      }
      CallRequest: {
        payload: Prisma.$CallRequestPayload<ExtArgs>
        fields: Prisma.CallRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRequestPayload>
          }
          findFirst: {
            args: Prisma.CallRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRequestPayload>
          }
          findMany: {
            args: Prisma.CallRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRequestPayload>[]
          }
          create: {
            args: Prisma.CallRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRequestPayload>
          }
          createMany: {
            args: Prisma.CallRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CallRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRequestPayload>
          }
          update: {
            args: Prisma.CallRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRequestPayload>
          }
          deleteMany: {
            args: Prisma.CallRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CallRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRequestPayload>
          }
          aggregate: {
            args: Prisma.CallRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallRequest>
          }
          groupBy: {
            args: Prisma.CallRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CallRequestCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      ContactUs: {
        payload: Prisma.$ContactUsPayload<ExtArgs>
        fields: Prisma.ContactUsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactUsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactUsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findFirst: {
            args: Prisma.ContactUsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactUsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          findMany: {
            args: Prisma.ContactUsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>[]
          }
          create: {
            args: Prisma.ContactUsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          createMany: {
            args: Prisma.ContactUsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactUsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          update: {
            args: Prisma.ContactUsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          deleteMany: {
            args: Prisma.ContactUsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUsPayload>
          }
          aggregate: {
            args: Prisma.ContactUsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactUs>
          }
          groupBy: {
            args: Prisma.ContactUsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactUsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactUsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactUsCountAggregateOutputType> | number
          }
        }
      }
      CustomerType: {
        payload: Prisma.$CustomerTypePayload<ExtArgs>
        fields: Prisma.CustomerTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTypePayload>
          }
          findFirst: {
            args: Prisma.CustomerTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTypePayload>
          }
          findMany: {
            args: Prisma.CustomerTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTypePayload>[]
          }
          create: {
            args: Prisma.CustomerTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTypePayload>
          }
          createMany: {
            args: Prisma.CustomerTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTypePayload>
          }
          update: {
            args: Prisma.CustomerTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTypePayload>
          }
          deleteMany: {
            args: Prisma.CustomerTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerTypePayload>
          }
          aggregate: {
            args: Prisma.CustomerTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerType>
          }
          groupBy: {
            args: Prisma.CustomerTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerTypeCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerTypeCountAggregateOutputType> | number
          }
        }
      }
      DeleteRequest: {
        payload: Prisma.$DeleteRequestPayload<ExtArgs>
        fields: Prisma.DeleteRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeleteRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeleteRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeleteRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeleteRequestPayload>
          }
          findFirst: {
            args: Prisma.DeleteRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeleteRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeleteRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeleteRequestPayload>
          }
          findMany: {
            args: Prisma.DeleteRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeleteRequestPayload>[]
          }
          create: {
            args: Prisma.DeleteRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeleteRequestPayload>
          }
          createMany: {
            args: Prisma.DeleteRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeleteRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeleteRequestPayload>
          }
          update: {
            args: Prisma.DeleteRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeleteRequestPayload>
          }
          deleteMany: {
            args: Prisma.DeleteRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeleteRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeleteRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeleteRequestPayload>
          }
          aggregate: {
            args: Prisma.DeleteRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeleteRequest>
          }
          groupBy: {
            args: Prisma.DeleteRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeleteRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeleteRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DeleteRequestCountAggregateOutputType> | number
          }
        }
      }
      Discount: {
        payload: Prisma.$DiscountPayload<ExtArgs>
        fields: Prisma.DiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findFirst: {
            args: Prisma.DiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findMany: {
            args: Prisma.DiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          create: {
            args: Prisma.DiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          createMany: {
            args: Prisma.DiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          update: {
            args: Prisma.DiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          deleteMany: {
            args: Prisma.DiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          aggregate: {
            args: Prisma.DiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscount>
          }
          groupBy: {
            args: Prisma.DiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountCountAggregateOutputType> | number
          }
        }
      }
      DropMessage: {
        payload: Prisma.$DropMessagePayload<ExtArgs>
        fields: Prisma.DropMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DropMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DropMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropMessagePayload>
          }
          findFirst: {
            args: Prisma.DropMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DropMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropMessagePayload>
          }
          findMany: {
            args: Prisma.DropMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropMessagePayload>[]
          }
          create: {
            args: Prisma.DropMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropMessagePayload>
          }
          createMany: {
            args: Prisma.DropMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DropMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropMessagePayload>
          }
          update: {
            args: Prisma.DropMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropMessagePayload>
          }
          deleteMany: {
            args: Prisma.DropMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DropMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DropMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DropMessagePayload>
          }
          aggregate: {
            args: Prisma.DropMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDropMessage>
          }
          groupBy: {
            args: Prisma.DropMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DropMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DropMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DropMessageCountAggregateOutputType> | number
          }
        }
      }
      ExclusiveCollection: {
        payload: Prisma.$ExclusiveCollectionPayload<ExtArgs>
        fields: Prisma.ExclusiveCollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExclusiveCollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExclusiveCollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExclusiveCollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExclusiveCollectionPayload>
          }
          findFirst: {
            args: Prisma.ExclusiveCollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExclusiveCollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExclusiveCollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExclusiveCollectionPayload>
          }
          findMany: {
            args: Prisma.ExclusiveCollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExclusiveCollectionPayload>[]
          }
          create: {
            args: Prisma.ExclusiveCollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExclusiveCollectionPayload>
          }
          createMany: {
            args: Prisma.ExclusiveCollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExclusiveCollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExclusiveCollectionPayload>
          }
          update: {
            args: Prisma.ExclusiveCollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExclusiveCollectionPayload>
          }
          deleteMany: {
            args: Prisma.ExclusiveCollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExclusiveCollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExclusiveCollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExclusiveCollectionPayload>
          }
          aggregate: {
            args: Prisma.ExclusiveCollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExclusiveCollection>
          }
          groupBy: {
            args: Prisma.ExclusiveCollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExclusiveCollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExclusiveCollectionCountArgs<ExtArgs>
            result: $Utils.Optional<ExclusiveCollectionCountAggregateOutputType> | number
          }
        }
      }
      HeroSliders: {
        payload: Prisma.$HeroSlidersPayload<ExtArgs>
        fields: Prisma.HeroSlidersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeroSlidersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeroSlidersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidersPayload>
          }
          findFirst: {
            args: Prisma.HeroSlidersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeroSlidersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidersPayload>
          }
          findMany: {
            args: Prisma.HeroSlidersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidersPayload>[]
          }
          create: {
            args: Prisma.HeroSlidersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidersPayload>
          }
          createMany: {
            args: Prisma.HeroSlidersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HeroSlidersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidersPayload>
          }
          update: {
            args: Prisma.HeroSlidersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidersPayload>
          }
          deleteMany: {
            args: Prisma.HeroSlidersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeroSlidersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HeroSlidersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroSlidersPayload>
          }
          aggregate: {
            args: Prisma.HeroSlidersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeroSliders>
          }
          groupBy: {
            args: Prisma.HeroSlidersGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeroSlidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.HeroSlidersCountArgs<ExtArgs>
            result: $Utils.Optional<HeroSlidersCountAggregateOutputType> | number
          }
        }
      }
      ImageWeek: {
        payload: Prisma.$ImageWeekPayload<ExtArgs>
        fields: Prisma.ImageWeekFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageWeekFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageWeekPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageWeekFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageWeekPayload>
          }
          findFirst: {
            args: Prisma.ImageWeekFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageWeekPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageWeekFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageWeekPayload>
          }
          findMany: {
            args: Prisma.ImageWeekFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageWeekPayload>[]
          }
          create: {
            args: Prisma.ImageWeekCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageWeekPayload>
          }
          createMany: {
            args: Prisma.ImageWeekCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImageWeekDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageWeekPayload>
          }
          update: {
            args: Prisma.ImageWeekUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageWeekPayload>
          }
          deleteMany: {
            args: Prisma.ImageWeekDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageWeekUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageWeekUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImageWeekPayload>
          }
          aggregate: {
            args: Prisma.ImageWeekAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImageWeek>
          }
          groupBy: {
            args: Prisma.ImageWeekGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageWeekGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageWeekCountArgs<ExtArgs>
            result: $Utils.Optional<ImageWeekCountAggregateOutputType> | number
          }
        }
      }
      Logos: {
        payload: Prisma.$LogosPayload<ExtArgs>
        fields: Prisma.LogosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogosPayload>
          }
          findFirst: {
            args: Prisma.LogosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogosPayload>
          }
          findMany: {
            args: Prisma.LogosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogosPayload>[]
          }
          create: {
            args: Prisma.LogosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogosPayload>
          }
          createMany: {
            args: Prisma.LogosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogosPayload>
          }
          update: {
            args: Prisma.LogosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogosPayload>
          }
          deleteMany: {
            args: Prisma.LogosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogosPayload>
          }
          aggregate: {
            args: Prisma.LogosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogos>
          }
          groupBy: {
            args: Prisma.LogosGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogosGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogosCountArgs<ExtArgs>
            result: $Utils.Optional<LogosCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      NewArrivals: {
        payload: Prisma.$NewArrivalsPayload<ExtArgs>
        fields: Prisma.NewArrivalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewArrivalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewArrivalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewArrivalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewArrivalsPayload>
          }
          findFirst: {
            args: Prisma.NewArrivalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewArrivalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewArrivalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewArrivalsPayload>
          }
          findMany: {
            args: Prisma.NewArrivalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewArrivalsPayload>[]
          }
          create: {
            args: Prisma.NewArrivalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewArrivalsPayload>
          }
          createMany: {
            args: Prisma.NewArrivalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NewArrivalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewArrivalsPayload>
          }
          update: {
            args: Prisma.NewArrivalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewArrivalsPayload>
          }
          deleteMany: {
            args: Prisma.NewArrivalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewArrivalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewArrivalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewArrivalsPayload>
          }
          aggregate: {
            args: Prisma.NewArrivalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewArrivals>
          }
          groupBy: {
            args: Prisma.NewArrivalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewArrivalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewArrivalsCountArgs<ExtArgs>
            result: $Utils.Optional<NewArrivalsCountAggregateOutputType> | number
          }
        }
      }
      Newsletter: {
        payload: Prisma.$NewsletterPayload<ExtArgs>
        fields: Prisma.NewsletterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsletterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsletterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          findFirst: {
            args: Prisma.NewsletterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsletterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          findMany: {
            args: Prisma.NewsletterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>[]
          }
          create: {
            args: Prisma.NewsletterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          createMany: {
            args: Prisma.NewsletterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NewsletterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          update: {
            args: Prisma.NewsletterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          deleteMany: {
            args: Prisma.NewsletterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsletterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsletterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsletterPayload>
          }
          aggregate: {
            args: Prisma.NewsletterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsletter>
          }
          groupBy: {
            args: Prisma.NewsletterGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsletterGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsletterCountArgs<ExtArgs>
            result: $Utils.Optional<NewsletterCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      OrderDetails: {
        payload: Prisma.$OrderDetailsPayload<ExtArgs>
        fields: Prisma.OrderDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          findFirst: {
            args: Prisma.OrderDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          findMany: {
            args: Prisma.OrderDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>[]
          }
          create: {
            args: Prisma.OrderDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          createMany: {
            args: Prisma.OrderDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          update: {
            args: Prisma.OrderDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          deleteMany: {
            args: Prisma.OrderDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderDetailsPayload>
          }
          aggregate: {
            args: Prisma.OrderDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderDetails>
          }
          groupBy: {
            args: Prisma.OrderDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<OrderDetailsCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      PaymentDetails: {
        payload: Prisma.$PaymentDetailsPayload<ExtArgs>
        fields: Prisma.PaymentDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          findFirst: {
            args: Prisma.PaymentDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          findMany: {
            args: Prisma.PaymentDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>[]
          }
          create: {
            args: Prisma.PaymentDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          createMany: {
            args: Prisma.PaymentDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          update: {
            args: Prisma.PaymentDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailsPayload>
          }
          aggregate: {
            args: Prisma.PaymentDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentDetails>
          }
          groupBy: {
            args: Prisma.PaymentDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentDetailsCountAggregateOutputType> | number
          }
        }
      }
      Privilege: {
        payload: Prisma.$PrivilegePayload<ExtArgs>
        fields: Prisma.PrivilegeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivilegeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivilegeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          findFirst: {
            args: Prisma.PrivilegeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivilegeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          findMany: {
            args: Prisma.PrivilegeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>[]
          }
          create: {
            args: Prisma.PrivilegeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          createMany: {
            args: Prisma.PrivilegeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrivilegeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          update: {
            args: Prisma.PrivilegeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          deleteMany: {
            args: Prisma.PrivilegeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivilegeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrivilegeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivilegePayload>
          }
          aggregate: {
            args: Prisma.PrivilegeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivilege>
          }
          groupBy: {
            args: Prisma.PrivilegeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivilegeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivilegeCountArgs<ExtArgs>
            result: $Utils.Optional<PrivilegeCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductColor: {
        payload: Prisma.$ProductColorPayload<ExtArgs>
        fields: Prisma.ProductColorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductColorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductColorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          findFirst: {
            args: Prisma.ProductColorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductColorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          findMany: {
            args: Prisma.ProductColorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>[]
          }
          create: {
            args: Prisma.ProductColorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          createMany: {
            args: Prisma.ProductColorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductColorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          update: {
            args: Prisma.ProductColorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          deleteMany: {
            args: Prisma.ProductColorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductColorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductColorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          aggregate: {
            args: Prisma.ProductColorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductColor>
          }
          groupBy: {
            args: Prisma.ProductColorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductColorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductColorCountArgs<ExtArgs>
            result: $Utils.Optional<ProductColorCountAggregateOutputType> | number
          }
        }
      }
      ProductFabric: {
        payload: Prisma.$ProductFabricPayload<ExtArgs>
        fields: Prisma.ProductFabricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFabricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFabricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFabricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFabricPayload>
          }
          findFirst: {
            args: Prisma.ProductFabricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFabricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFabricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFabricPayload>
          }
          findMany: {
            args: Prisma.ProductFabricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFabricPayload>[]
          }
          create: {
            args: Prisma.ProductFabricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFabricPayload>
          }
          createMany: {
            args: Prisma.ProductFabricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductFabricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFabricPayload>
          }
          update: {
            args: Prisma.ProductFabricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFabricPayload>
          }
          deleteMany: {
            args: Prisma.ProductFabricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductFabricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductFabricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFabricPayload>
          }
          aggregate: {
            args: Prisma.ProductFabricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductFabric>
          }
          groupBy: {
            args: Prisma.ProductFabricGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductFabricGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductFabricCountArgs<ExtArgs>
            result: $Utils.Optional<ProductFabricCountAggregateOutputType> | number
          }
        }
      }
      ProductImage: {
        payload: Prisma.$ProductImagePayload<ExtArgs>
        fields: Prisma.ProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findFirst: {
            args: Prisma.ProductImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findMany: {
            args: Prisma.ProductImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          create: {
            args: Prisma.ProductImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          createMany: {
            args: Prisma.ProductImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          update: {
            args: Prisma.ProductImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          deleteMany: {
            args: Prisma.ProductImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          aggregate: {
            args: Prisma.ProductImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductImage>
          }
          groupBy: {
            args: Prisma.ProductImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImageCountArgs<ExtArgs>
            result: $Utils.Optional<ProductImageCountAggregateOutputType> | number
          }
        }
      }
      ProductInventory: {
        payload: Prisma.$ProductInventoryPayload<ExtArgs>
        fields: Prisma.ProductInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductInventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductInventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInventoryPayload>
          }
          findFirst: {
            args: Prisma.ProductInventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductInventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInventoryPayload>
          }
          findMany: {
            args: Prisma.ProductInventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInventoryPayload>[]
          }
          create: {
            args: Prisma.ProductInventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInventoryPayload>
          }
          createMany: {
            args: Prisma.ProductInventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductInventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInventoryPayload>
          }
          update: {
            args: Prisma.ProductInventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInventoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductInventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductInventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductInventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductInventoryPayload>
          }
          aggregate: {
            args: Prisma.ProductInventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductInventory>
          }
          groupBy: {
            args: Prisma.ProductInventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductInventoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductInventoryCountAggregateOutputType> | number
          }
        }
      }
      ProductReview: {
        payload: Prisma.$ProductReviewPayload<ExtArgs>
        fields: Prisma.ProductReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          findFirst: {
            args: Prisma.ProductReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          findMany: {
            args: Prisma.ProductReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>[]
          }
          create: {
            args: Prisma.ProductReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          createMany: {
            args: Prisma.ProductReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          update: {
            args: Prisma.ProductReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          deleteMany: {
            args: Prisma.ProductReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReviewPayload>
          }
          aggregate: {
            args: Prisma.ProductReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductReview>
          }
          groupBy: {
            args: Prisma.ProductReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ProductReviewCountAggregateOutputType> | number
          }
        }
      }
      ProductSize: {
        payload: Prisma.$ProductSizePayload<ExtArgs>
        fields: Prisma.ProductSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          findFirst: {
            args: Prisma.ProductSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          findMany: {
            args: Prisma.ProductSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>[]
          }
          create: {
            args: Prisma.ProductSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          createMany: {
            args: Prisma.ProductSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          update: {
            args: Prisma.ProductSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          deleteMany: {
            args: Prisma.ProductSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          aggregate: {
            args: Prisma.ProductSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductSize>
          }
          groupBy: {
            args: Prisma.ProductSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductSizeCountArgs<ExtArgs>
            result: $Utils.Optional<ProductSizeCountAggregateOutputType> | number
          }
        }
      }
      ProductWeek: {
        payload: Prisma.$ProductWeekPayload<ExtArgs>
        fields: Prisma.ProductWeekFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductWeekFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWeekPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductWeekFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWeekPayload>
          }
          findFirst: {
            args: Prisma.ProductWeekFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWeekPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductWeekFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWeekPayload>
          }
          findMany: {
            args: Prisma.ProductWeekFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWeekPayload>[]
          }
          create: {
            args: Prisma.ProductWeekCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWeekPayload>
          }
          createMany: {
            args: Prisma.ProductWeekCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductWeekDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWeekPayload>
          }
          update: {
            args: Prisma.ProductWeekUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWeekPayload>
          }
          deleteMany: {
            args: Prisma.ProductWeekDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductWeekUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductWeekUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductWeekPayload>
          }
          aggregate: {
            args: Prisma.ProductWeekAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductWeek>
          }
          groupBy: {
            args: Prisma.ProductWeekGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductWeekGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductWeekCountArgs<ExtArgs>
            result: $Utils.Optional<ProductWeekCountAggregateOutputType> | number
          }
        }
      }
      Quotes: {
        payload: Prisma.$QuotesPayload<ExtArgs>
        fields: Prisma.QuotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          findFirst: {
            args: Prisma.QuotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          findMany: {
            args: Prisma.QuotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>[]
          }
          create: {
            args: Prisma.QuotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          createMany: {
            args: Prisma.QuotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          update: {
            args: Prisma.QuotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          deleteMany: {
            args: Prisma.QuotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotesPayload>
          }
          aggregate: {
            args: Prisma.QuotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotes>
          }
          groupBy: {
            args: Prisma.QuotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotesCountArgs<ExtArgs>
            result: $Utils.Optional<QuotesCountAggregateOutputType> | number
          }
        }
      }
      ReturnRequest: {
        payload: Prisma.$ReturnRequestPayload<ExtArgs>
        fields: Prisma.ReturnRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReturnRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          findFirst: {
            args: Prisma.ReturnRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          findMany: {
            args: Prisma.ReturnRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>[]
          }
          create: {
            args: Prisma.ReturnRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          createMany: {
            args: Prisma.ReturnRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReturnRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          update: {
            args: Prisma.ReturnRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          deleteMany: {
            args: Prisma.ReturnRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReturnRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnRequestPayload>
          }
          aggregate: {
            args: Prisma.ReturnRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturnRequest>
          }
          groupBy: {
            args: Prisma.ReturnRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnRequestCountAggregateOutputType> | number
          }
        }
      }
      Rewards: {
        payload: Prisma.$RewardsPayload<ExtArgs>
        fields: Prisma.RewardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardsPayload>
          }
          findFirst: {
            args: Prisma.RewardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardsPayload>
          }
          findMany: {
            args: Prisma.RewardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardsPayload>[]
          }
          create: {
            args: Prisma.RewardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardsPayload>
          }
          createMany: {
            args: Prisma.RewardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RewardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardsPayload>
          }
          update: {
            args: Prisma.RewardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardsPayload>
          }
          deleteMany: {
            args: Prisma.RewardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RewardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardsPayload>
          }
          aggregate: {
            args: Prisma.RewardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewards>
          }
          groupBy: {
            args: Prisma.RewardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardsCountArgs<ExtArgs>
            result: $Utils.Optional<RewardsCountAggregateOutputType> | number
          }
        }
      }
      SearchQuery: {
        payload: Prisma.$SearchQueryPayload<ExtArgs>
        fields: Prisma.SearchQueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchQueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchQueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findFirst: {
            args: Prisma.SearchQueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchQueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          findMany: {
            args: Prisma.SearchQueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>[]
          }
          create: {
            args: Prisma.SearchQueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          createMany: {
            args: Prisma.SearchQueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SearchQueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          update: {
            args: Prisma.SearchQueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          deleteMany: {
            args: Prisma.SearchQueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchQueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchQueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchQueryPayload>
          }
          aggregate: {
            args: Prisma.SearchQueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchQuery>
          }
          groupBy: {
            args: Prisma.SearchQueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchQueryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchQueryCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      ShopByOccasion: {
        payload: Prisma.$ShopByOccasionPayload<ExtArgs>
        fields: Prisma.ShopByOccasionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopByOccasionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopByOccasionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionPayload>
          }
          findFirst: {
            args: Prisma.ShopByOccasionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopByOccasionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionPayload>
          }
          findMany: {
            args: Prisma.ShopByOccasionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionPayload>[]
          }
          create: {
            args: Prisma.ShopByOccasionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionPayload>
          }
          createMany: {
            args: Prisma.ShopByOccasionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShopByOccasionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionPayload>
          }
          update: {
            args: Prisma.ShopByOccasionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionPayload>
          }
          deleteMany: {
            args: Prisma.ShopByOccasionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopByOccasionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShopByOccasionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionPayload>
          }
          aggregate: {
            args: Prisma.ShopByOccasionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopByOccasion>
          }
          groupBy: {
            args: Prisma.ShopByOccasionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopByOccasionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopByOccasionCountArgs<ExtArgs>
            result: $Utils.Optional<ShopByOccasionCountAggregateOutputType> | number
          }
        }
      }
      ShopByOccasionProduct: {
        payload: Prisma.$ShopByOccasionProductPayload<ExtArgs>
        fields: Prisma.ShopByOccasionProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopByOccasionProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopByOccasionProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionProductPayload>
          }
          findFirst: {
            args: Prisma.ShopByOccasionProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopByOccasionProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionProductPayload>
          }
          findMany: {
            args: Prisma.ShopByOccasionProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionProductPayload>[]
          }
          create: {
            args: Prisma.ShopByOccasionProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionProductPayload>
          }
          createMany: {
            args: Prisma.ShopByOccasionProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShopByOccasionProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionProductPayload>
          }
          update: {
            args: Prisma.ShopByOccasionProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionProductPayload>
          }
          deleteMany: {
            args: Prisma.ShopByOccasionProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopByOccasionProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShopByOccasionProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopByOccasionProductPayload>
          }
          aggregate: {
            args: Prisma.ShopByOccasionProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopByOccasionProduct>
          }
          groupBy: {
            args: Prisma.ShopByOccasionProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopByOccasionProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopByOccasionProductCountArgs<ExtArgs>
            result: $Utils.Optional<ShopByOccasionProductCountAggregateOutputType> | number
          }
        }
      }
      ShopBySeason: {
        payload: Prisma.$ShopBySeasonPayload<ExtArgs>
        fields: Prisma.ShopBySeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopBySeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopBySeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonPayload>
          }
          findFirst: {
            args: Prisma.ShopBySeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopBySeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonPayload>
          }
          findMany: {
            args: Prisma.ShopBySeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonPayload>[]
          }
          create: {
            args: Prisma.ShopBySeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonPayload>
          }
          createMany: {
            args: Prisma.ShopBySeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShopBySeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonPayload>
          }
          update: {
            args: Prisma.ShopBySeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonPayload>
          }
          deleteMany: {
            args: Prisma.ShopBySeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopBySeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShopBySeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonPayload>
          }
          aggregate: {
            args: Prisma.ShopBySeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopBySeason>
          }
          groupBy: {
            args: Prisma.ShopBySeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopBySeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopBySeasonCountArgs<ExtArgs>
            result: $Utils.Optional<ShopBySeasonCountAggregateOutputType> | number
          }
        }
      }
      ShopBySeasonProduct: {
        payload: Prisma.$ShopBySeasonProductPayload<ExtArgs>
        fields: Prisma.ShopBySeasonProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopBySeasonProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopBySeasonProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonProductPayload>
          }
          findFirst: {
            args: Prisma.ShopBySeasonProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopBySeasonProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonProductPayload>
          }
          findMany: {
            args: Prisma.ShopBySeasonProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonProductPayload>[]
          }
          create: {
            args: Prisma.ShopBySeasonProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonProductPayload>
          }
          createMany: {
            args: Prisma.ShopBySeasonProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShopBySeasonProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonProductPayload>
          }
          update: {
            args: Prisma.ShopBySeasonProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonProductPayload>
          }
          deleteMany: {
            args: Prisma.ShopBySeasonProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopBySeasonProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShopBySeasonProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopBySeasonProductPayload>
          }
          aggregate: {
            args: Prisma.ShopBySeasonProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShopBySeasonProduct>
          }
          groupBy: {
            args: Prisma.ShopBySeasonProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopBySeasonProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopBySeasonProductCountArgs<ExtArgs>
            result: $Utils.Optional<ShopBySeasonProductCountAggregateOutputType> | number
          }
        }
      }
      Showcases: {
        payload: Prisma.$ShowcasesPayload<ExtArgs>
        fields: Prisma.ShowcasesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShowcasesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowcasesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShowcasesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowcasesPayload>
          }
          findFirst: {
            args: Prisma.ShowcasesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowcasesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShowcasesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowcasesPayload>
          }
          findMany: {
            args: Prisma.ShowcasesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowcasesPayload>[]
          }
          create: {
            args: Prisma.ShowcasesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowcasesPayload>
          }
          createMany: {
            args: Prisma.ShowcasesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShowcasesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowcasesPayload>
          }
          update: {
            args: Prisma.ShowcasesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowcasesPayload>
          }
          deleteMany: {
            args: Prisma.ShowcasesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShowcasesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShowcasesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowcasesPayload>
          }
          aggregate: {
            args: Prisma.ShowcasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShowcases>
          }
          groupBy: {
            args: Prisma.ShowcasesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShowcasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShowcasesCountArgs<ExtArgs>
            result: $Utils.Optional<ShowcasesCountAggregateOutputType> | number
          }
        }
      }
      SizeChart: {
        payload: Prisma.$SizeChartPayload<ExtArgs>
        fields: Prisma.SizeChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SizeChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SizeChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeChartPayload>
          }
          findFirst: {
            args: Prisma.SizeChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SizeChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeChartPayload>
          }
          findMany: {
            args: Prisma.SizeChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeChartPayload>[]
          }
          create: {
            args: Prisma.SizeChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeChartPayload>
          }
          createMany: {
            args: Prisma.SizeChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SizeChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeChartPayload>
          }
          update: {
            args: Prisma.SizeChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeChartPayload>
          }
          deleteMany: {
            args: Prisma.SizeChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SizeChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SizeChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeChartPayload>
          }
          aggregate: {
            args: Prisma.SizeChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSizeChart>
          }
          groupBy: {
            args: Prisma.SizeChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<SizeChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.SizeChartCountArgs<ExtArgs>
            result: $Utils.Optional<SizeChartCountAggregateOutputType> | number
          }
        }
      }
      SocialLinks: {
        payload: Prisma.$SocialLinksPayload<ExtArgs>
        fields: Prisma.SocialLinksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialLinksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialLinksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          findFirst: {
            args: Prisma.SocialLinksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialLinksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          findMany: {
            args: Prisma.SocialLinksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>[]
          }
          create: {
            args: Prisma.SocialLinksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          createMany: {
            args: Prisma.SocialLinksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocialLinksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          update: {
            args: Prisma.SocialLinksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          deleteMany: {
            args: Prisma.SocialLinksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialLinksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialLinksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinksPayload>
          }
          aggregate: {
            args: Prisma.SocialLinksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialLinks>
          }
          groupBy: {
            args: Prisma.SocialLinksGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialLinksGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialLinksCountArgs<ExtArgs>
            result: $Utils.Optional<SocialLinksCountAggregateOutputType> | number
          }
        }
      }
      StaticMessages: {
        payload: Prisma.$StaticMessagesPayload<ExtArgs>
        fields: Prisma.StaticMessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaticMessagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticMessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaticMessagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticMessagesPayload>
          }
          findFirst: {
            args: Prisma.StaticMessagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticMessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaticMessagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticMessagesPayload>
          }
          findMany: {
            args: Prisma.StaticMessagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticMessagesPayload>[]
          }
          create: {
            args: Prisma.StaticMessagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticMessagesPayload>
          }
          createMany: {
            args: Prisma.StaticMessagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StaticMessagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticMessagesPayload>
          }
          update: {
            args: Prisma.StaticMessagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticMessagesPayload>
          }
          deleteMany: {
            args: Prisma.StaticMessagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaticMessagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StaticMessagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaticMessagesPayload>
          }
          aggregate: {
            args: Prisma.StaticMessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaticMessages>
          }
          groupBy: {
            args: Prisma.StaticMessagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaticMessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaticMessagesCountArgs<ExtArgs>
            result: $Utils.Optional<StaticMessagesCountAggregateOutputType> | number
          }
        }
      }
      SubCategory: {
        payload: Prisma.$SubCategoryPayload<ExtArgs>
        fields: Prisma.SubCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findFirst: {
            args: Prisma.SubCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findMany: {
            args: Prisma.SubCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>[]
          }
          create: {
            args: Prisma.SubCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          createMany: {
            args: Prisma.SubCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          update: {
            args: Prisma.SubCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          aggregate: {
            args: Prisma.SubCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubCategory>
          }
          groupBy: {
            args: Prisma.SubCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      Tags: {
        payload: Prisma.$TagsPayload<ExtArgs>
        fields: Prisma.TagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findFirst: {
            args: Prisma.TagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findMany: {
            args: Prisma.TagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          create: {
            args: Prisma.TagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          createMany: {
            args: Prisma.TagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          update: {
            args: Prisma.TagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          deleteMany: {
            args: Prisma.TagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.TagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      Trending: {
        payload: Prisma.$TrendingPayload<ExtArgs>
        fields: Prisma.TrendingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrendingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrendingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingPayload>
          }
          findFirst: {
            args: Prisma.TrendingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrendingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingPayload>
          }
          findMany: {
            args: Prisma.TrendingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingPayload>[]
          }
          create: {
            args: Prisma.TrendingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingPayload>
          }
          createMany: {
            args: Prisma.TrendingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrendingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingPayload>
          }
          update: {
            args: Prisma.TrendingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingPayload>
          }
          deleteMany: {
            args: Prisma.TrendingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrendingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrendingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrendingPayload>
          }
          aggregate: {
            args: Prisma.TrendingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrending>
          }
          groupBy: {
            args: Prisma.TrendingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrendingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrendingCountArgs<ExtArgs>
            result: $Utils.Optional<TrendingCountAggregateOutputType> | number
          }
        }
      }
      UpdateHistory: {
        payload: Prisma.$UpdateHistoryPayload<ExtArgs>
        fields: Prisma.UpdateHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UpdateHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UpdateHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateHistoryPayload>
          }
          findFirst: {
            args: Prisma.UpdateHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UpdateHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateHistoryPayload>
          }
          findMany: {
            args: Prisma.UpdateHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateHistoryPayload>[]
          }
          create: {
            args: Prisma.UpdateHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateHistoryPayload>
          }
          createMany: {
            args: Prisma.UpdateHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UpdateHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateHistoryPayload>
          }
          update: {
            args: Prisma.UpdateHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateHistoryPayload>
          }
          deleteMany: {
            args: Prisma.UpdateHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UpdateHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UpdateHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateHistoryPayload>
          }
          aggregate: {
            args: Prisma.UpdateHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpdateHistory>
          }
          groupBy: {
            args: Prisma.UpdateHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UpdateHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UpdateHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UpdateHistoryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserAddress: {
        payload: Prisma.$UserAddressPayload<ExtArgs>
        fields: Prisma.UserAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findFirst: {
            args: Prisma.UserAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          findMany: {
            args: Prisma.UserAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>[]
          }
          create: {
            args: Prisma.UserAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          createMany: {
            args: Prisma.UserAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          update: {
            args: Prisma.UserAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          deleteMany: {
            args: Prisma.UserAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAddressPayload>
          }
          aggregate: {
            args: Prisma.UserAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAddress>
          }
          groupBy: {
            args: Prisma.UserAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAddressCountArgs<ExtArgs>
            result: $Utils.Optional<UserAddressCountAggregateOutputType> | number
          }
        }
      }
      UserPrivilege: {
        payload: Prisma.$UserPrivilegePayload<ExtArgs>
        fields: Prisma.UserPrivilegeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPrivilegeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivilegePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPrivilegeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivilegePayload>
          }
          findFirst: {
            args: Prisma.UserPrivilegeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivilegePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPrivilegeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivilegePayload>
          }
          findMany: {
            args: Prisma.UserPrivilegeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivilegePayload>[]
          }
          create: {
            args: Prisma.UserPrivilegeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivilegePayload>
          }
          createMany: {
            args: Prisma.UserPrivilegeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserPrivilegeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivilegePayload>
          }
          update: {
            args: Prisma.UserPrivilegeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivilegePayload>
          }
          deleteMany: {
            args: Prisma.UserPrivilegeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPrivilegeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPrivilegeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPrivilegePayload>
          }
          aggregate: {
            args: Prisma.UserPrivilegeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPrivilege>
          }
          groupBy: {
            args: Prisma.UserPrivilegeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPrivilegeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPrivilegeCountArgs<ExtArgs>
            result: $Utils.Optional<UserPrivilegeCountAggregateOutputType> | number
          }
        }
      }
      Vides: {
        payload: Prisma.$VidesPayload<ExtArgs>
        fields: Prisma.VidesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VidesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VidesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VidesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VidesPayload>
          }
          findFirst: {
            args: Prisma.VidesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VidesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VidesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VidesPayload>
          }
          findMany: {
            args: Prisma.VidesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VidesPayload>[]
          }
          create: {
            args: Prisma.VidesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VidesPayload>
          }
          createMany: {
            args: Prisma.VidesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VidesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VidesPayload>
          }
          update: {
            args: Prisma.VidesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VidesPayload>
          }
          deleteMany: {
            args: Prisma.VidesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VidesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VidesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VidesPayload>
          }
          aggregate: {
            args: Prisma.VidesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVides>
          }
          groupBy: {
            args: Prisma.VidesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VidesGroupByOutputType>[]
          }
          count: {
            args: Prisma.VidesCountArgs<ExtArgs>
            result: $Utils.Optional<VidesCountAggregateOutputType> | number
          }
        }
      }
      Visitor: {
        payload: Prisma.$VisitorPayload<ExtArgs>
        fields: Prisma.VisitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findFirst: {
            args: Prisma.VisitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          findMany: {
            args: Prisma.VisitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>[]
          }
          create: {
            args: Prisma.VisitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          createMany: {
            args: Prisma.VisitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VisitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          update: {
            args: Prisma.VisitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          deleteMany: {
            args: Prisma.VisitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitorPayload>
          }
          aggregate: {
            args: Prisma.VisitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitor>
          }
          groupBy: {
            args: Prisma.VisitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitorCountArgs<ExtArgs>
            result: $Utils.Optional<VisitorCountAggregateOutputType> | number
          }
        }
      }
      WishlistItem: {
        payload: Prisma.$WishlistItemPayload<ExtArgs>
        fields: Prisma.WishlistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WishlistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findFirst: {
            args: Prisma.WishlistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          findMany: {
            args: Prisma.WishlistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>[]
          }
          create: {
            args: Prisma.WishlistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          createMany: {
            args: Prisma.WishlistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WishlistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          update: {
            args: Prisma.WishlistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          deleteMany: {
            args: Prisma.WishlistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WishlistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WishlistItemPayload>
          }
          aggregate: {
            args: Prisma.WishlistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWishlistItem>
          }
          groupBy: {
            args: Prisma.WishlistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistItemCountArgs<ExtArgs>
            result: $Utils.Optional<WishlistItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    anchorText?: AnchorTextOmit
    announcements?: AnnouncementsOmit
    auditLog?: AuditLogOmit
    bestSelling?: BestSellingOmit
    callRequest?: CallRequestOmit
    cartItem?: CartItemOmit
    contactUs?: ContactUsOmit
    customerType?: CustomerTypeOmit
    deleteRequest?: DeleteRequestOmit
    discount?: DiscountOmit
    dropMessage?: DropMessageOmit
    exclusiveCollection?: ExclusiveCollectionOmit
    heroSliders?: HeroSlidersOmit
    imageWeek?: ImageWeekOmit
    logos?: LogosOmit
    message?: MessageOmit
    newArrivals?: NewArrivalsOmit
    newsletter?: NewsletterOmit
    notification?: NotificationOmit
    orderDetails?: OrderDetailsOmit
    orderItem?: OrderItemOmit
    otp?: OtpOmit
    paymentDetails?: PaymentDetailsOmit
    privilege?: PrivilegeOmit
    product?: ProductOmit
    productCategory?: ProductCategoryOmit
    productColor?: ProductColorOmit
    productFabric?: ProductFabricOmit
    productImage?: ProductImageOmit
    productInventory?: ProductInventoryOmit
    productReview?: ProductReviewOmit
    productSize?: ProductSizeOmit
    productWeek?: ProductWeekOmit
    quotes?: QuotesOmit
    returnRequest?: ReturnRequestOmit
    rewards?: RewardsOmit
    searchQuery?: SearchQueryOmit
    session?: SessionOmit
    shopByOccasion?: ShopByOccasionOmit
    shopByOccasionProduct?: ShopByOccasionProductOmit
    shopBySeason?: ShopBySeasonOmit
    shopBySeasonProduct?: ShopBySeasonProductOmit
    showcases?: ShowcasesOmit
    sizeChart?: SizeChartOmit
    socialLinks?: SocialLinksOmit
    staticMessages?: StaticMessagesOmit
    subCategory?: SubCategoryOmit
    supportTicket?: SupportTicketOmit
    tags?: TagsOmit
    trending?: TrendingOmit
    updateHistory?: UpdateHistoryOmit
    user?: UserOmit
    userAddress?: UserAddressOmit
    userPrivilege?: UserPrivilegeOmit
    vides?: VidesOmit
    visitor?: VisitorOmit
    wishlistItem?: WishlistItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerTypeCountOutputType
   */

  export type CustomerTypeCountOutputType = {
    Product: number
  }

  export type CustomerTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | CustomerTypeCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * CustomerTypeCountOutputType without action
   */
  export type CustomerTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTypeCountOutputType
     */
    select?: CustomerTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerTypeCountOutputType without action
   */
  export type CustomerTypeCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type DiscountCountOutputType
   */

  export type DiscountCountOutputType = {
    OrderDetails: number
  }

  export type DiscountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderDetails?: boolean | DiscountCountOutputTypeCountOrderDetailsArgs
  }

  // Custom InputTypes
  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountCountOutputType
     */
    select?: DiscountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeCountOrderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetailsWhereInput
  }


  /**
   * Count Type OrderDetailsCountOutputType
   */

  export type OrderDetailsCountOutputType = {
    OrderItem: number
    PaymentDetails: number
  }

  export type OrderDetailsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItem?: boolean | OrderDetailsCountOutputTypeCountOrderItemArgs
    PaymentDetails?: boolean | OrderDetailsCountOutputTypeCountPaymentDetailsArgs
  }

  // Custom InputTypes
  /**
   * OrderDetailsCountOutputType without action
   */
  export type OrderDetailsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetailsCountOutputType
     */
    select?: OrderDetailsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderDetailsCountOutputType without action
   */
  export type OrderDetailsCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderDetailsCountOutputType without action
   */
  export type OrderDetailsCountOutputTypeCountPaymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentDetailsWhereInput
  }


  /**
   * Count Type OrderItemCountOutputType
   */

  export type OrderItemCountOutputType = {
    ReturnRequest: number
  }

  export type OrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReturnRequest?: boolean | OrderItemCountOutputTypeCountReturnRequestArgs
  }

  // Custom InputTypes
  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemCountOutputType
     */
    select?: OrderItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountReturnRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnRequestWhereInput
  }


  /**
   * Count Type PrivilegeCountOutputType
   */

  export type PrivilegeCountOutputType = {
    UserPrivilege: number
  }

  export type PrivilegeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserPrivilege?: boolean | PrivilegeCountOutputTypeCountUserPrivilegeArgs
  }

  // Custom InputTypes
  /**
   * PrivilegeCountOutputType without action
   */
  export type PrivilegeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivilegeCountOutputType
     */
    select?: PrivilegeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrivilegeCountOutputType without action
   */
  export type PrivilegeCountOutputTypeCountUserPrivilegeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPrivilegeWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    CartItem: number
    Discount: number
    OrderItem: number
    ProductImage: number
    ProductInventory: number
    ProductReview: number
    WishlistItem: number
    ProductCategory: number
    Product_A: number
    Product_B: number
    SubCategory: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CartItem?: boolean | ProductCountOutputTypeCountCartItemArgs
    Discount?: boolean | ProductCountOutputTypeCountDiscountArgs
    OrderItem?: boolean | ProductCountOutputTypeCountOrderItemArgs
    ProductImage?: boolean | ProductCountOutputTypeCountProductImageArgs
    ProductInventory?: boolean | ProductCountOutputTypeCountProductInventoryArgs
    ProductReview?: boolean | ProductCountOutputTypeCountProductReviewArgs
    WishlistItem?: boolean | ProductCountOutputTypeCountWishlistItemArgs
    ProductCategory?: boolean | ProductCountOutputTypeCountProductCategoryArgs
    Product_A?: boolean | ProductCountOutputTypeCountProduct_AArgs
    Product_B?: boolean | ProductCountOutputTypeCountProduct_BArgs
    SubCategory?: boolean | ProductCountOutputTypeCountSubCategoryArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountDiscountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductInventoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_AArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_BArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSubCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    Quotes: number
    SubCategory: number
    Product: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Quotes?: boolean | ProductCategoryCountOutputTypeCountQuotesArgs
    SubCategory?: boolean | ProductCategoryCountOutputTypeCountSubCategoryArgs
    Product?: boolean | ProductCategoryCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotesWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountSubCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductColorCountOutputType
   */

  export type ProductColorCountOutputType = {
    CartItem: number
    OrderItem: number
    ProductImage: number
  }

  export type ProductColorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CartItem?: boolean | ProductColorCountOutputTypeCountCartItemArgs
    OrderItem?: boolean | ProductColorCountOutputTypeCountOrderItemArgs
    ProductImage?: boolean | ProductColorCountOutputTypeCountProductImageArgs
  }

  // Custom InputTypes
  /**
   * ProductColorCountOutputType without action
   */
  export type ProductColorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColorCountOutputType
     */
    select?: ProductColorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductColorCountOutputType without action
   */
  export type ProductColorCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductColorCountOutputType without action
   */
  export type ProductColorCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductColorCountOutputType without action
   */
  export type ProductColorCountOutputTypeCountProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
  }


  /**
   * Count Type ProductFabricCountOutputType
   */

  export type ProductFabricCountOutputType = {
    Product: number
  }

  export type ProductFabricCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductFabricCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductFabricCountOutputType without action
   */
  export type ProductFabricCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabricCountOutputType
     */
    select?: ProductFabricCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductFabricCountOutputType without action
   */
  export type ProductFabricCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductImageCountOutputType
   */

  export type ProductImageCountOutputType = {
    CartItem: number
    OrderItem: number
  }

  export type ProductImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CartItem?: boolean | ProductImageCountOutputTypeCountCartItemArgs
    OrderItem?: boolean | ProductImageCountOutputTypeCountOrderItemArgs
  }

  // Custom InputTypes
  /**
   * ProductImageCountOutputType without action
   */
  export type ProductImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageCountOutputType
     */
    select?: ProductImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductImageCountOutputType without action
   */
  export type ProductImageCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductImageCountOutputType without action
   */
  export type ProductImageCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type ProductSizeCountOutputType
   */

  export type ProductSizeCountOutputType = {
    OrderItem: number
    ProductInventory: number
  }

  export type ProductSizeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItem?: boolean | ProductSizeCountOutputTypeCountOrderItemArgs
    ProductInventory?: boolean | ProductSizeCountOutputTypeCountProductInventoryArgs
  }

  // Custom InputTypes
  /**
   * ProductSizeCountOutputType without action
   */
  export type ProductSizeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSizeCountOutputType
     */
    select?: ProductSizeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductSizeCountOutputType without action
   */
  export type ProductSizeCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductSizeCountOutputType without action
   */
  export type ProductSizeCountOutputTypeCountProductInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductInventoryWhereInput
  }


  /**
   * Count Type ShopByOccasionCountOutputType
   */

  export type ShopByOccasionCountOutputType = {
    ShopByOccasionProduct: number
  }

  export type ShopByOccasionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopByOccasionProduct?: boolean | ShopByOccasionCountOutputTypeCountShopByOccasionProductArgs
  }

  // Custom InputTypes
  /**
   * ShopByOccasionCountOutputType without action
   */
  export type ShopByOccasionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionCountOutputType
     */
    select?: ShopByOccasionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopByOccasionCountOutputType without action
   */
  export type ShopByOccasionCountOutputTypeCountShopByOccasionProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopByOccasionProductWhereInput
  }


  /**
   * Count Type ShopBySeasonCountOutputType
   */

  export type ShopBySeasonCountOutputType = {
    ShopBySeasonProduct: number
  }

  export type ShopBySeasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopBySeasonProduct?: boolean | ShopBySeasonCountOutputTypeCountShopBySeasonProductArgs
  }

  // Custom InputTypes
  /**
   * ShopBySeasonCountOutputType without action
   */
  export type ShopBySeasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonCountOutputType
     */
    select?: ShopBySeasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopBySeasonCountOutputType without action
   */
  export type ShopBySeasonCountOutputTypeCountShopBySeasonProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopBySeasonProductWhereInput
  }


  /**
   * Count Type SizeChartCountOutputType
   */

  export type SizeChartCountOutputType = {
    Product: number
  }

  export type SizeChartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | SizeChartCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * SizeChartCountOutputType without action
   */
  export type SizeChartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChartCountOutputType
     */
    select?: SizeChartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SizeChartCountOutputType without action
   */
  export type SizeChartCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type SubCategoryCountOutputType
   */

  export type SubCategoryCountOutputType = {
    Product: number
  }

  export type SubCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | SubCategoryCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryCountOutputType
     */
    select?: SubCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    AuditLog: number
    CartItem: number
    DeleteRequest: number
    DropMessage: number
    Message_Message_handledByIdToUser: number
    Message_Message_receiverIdToUser: number
    Message_Message_senderIdToUser: number
    Notification: number
    OrderDetails: number
    Otp: number
    Product: number
    ProductReview: number
    Rewards: number
    SearchQuery: number
    Session: number
    StaticMessages: number
    SupportTicket: number
    UpdateHistory: number
    other_User: number
    UserAddress: number
    UserPrivilege: number
    WishlistItem: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | UserCountOutputTypeCountAuditLogArgs
    CartItem?: boolean | UserCountOutputTypeCountCartItemArgs
    DeleteRequest?: boolean | UserCountOutputTypeCountDeleteRequestArgs
    DropMessage?: boolean | UserCountOutputTypeCountDropMessageArgs
    Message_Message_handledByIdToUser?: boolean | UserCountOutputTypeCountMessage_Message_handledByIdToUserArgs
    Message_Message_receiverIdToUser?: boolean | UserCountOutputTypeCountMessage_Message_receiverIdToUserArgs
    Message_Message_senderIdToUser?: boolean | UserCountOutputTypeCountMessage_Message_senderIdToUserArgs
    Notification?: boolean | UserCountOutputTypeCountNotificationArgs
    OrderDetails?: boolean | UserCountOutputTypeCountOrderDetailsArgs
    Otp?: boolean | UserCountOutputTypeCountOtpArgs
    Product?: boolean | UserCountOutputTypeCountProductArgs
    ProductReview?: boolean | UserCountOutputTypeCountProductReviewArgs
    Rewards?: boolean | UserCountOutputTypeCountRewardsArgs
    SearchQuery?: boolean | UserCountOutputTypeCountSearchQueryArgs
    Session?: boolean | UserCountOutputTypeCountSessionArgs
    StaticMessages?: boolean | UserCountOutputTypeCountStaticMessagesArgs
    SupportTicket?: boolean | UserCountOutputTypeCountSupportTicketArgs
    UpdateHistory?: boolean | UserCountOutputTypeCountUpdateHistoryArgs
    other_User?: boolean | UserCountOutputTypeCountOther_UserArgs
    UserAddress?: boolean | UserCountOutputTypeCountUserAddressArgs
    UserPrivilege?: boolean | UserCountOutputTypeCountUserPrivilegeArgs
    WishlistItem?: boolean | UserCountOutputTypeCountWishlistItemArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeleteRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeleteRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDropMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DropMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_Message_handledByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_Message_receiverIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessage_Message_senderIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetailsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearchQueryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchQueryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaticMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaticMessagesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdateHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdateHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOther_UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPrivilegeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPrivilegeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }


  /**
   * Count Type UserAddressCountOutputType
   */

  export type UserAddressCountOutputType = {
    OrderDetails: number
  }

  export type UserAddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderDetails?: boolean | UserAddressCountOutputTypeCountOrderDetailsArgs
  }

  // Custom InputTypes
  /**
   * UserAddressCountOutputType without action
   */
  export type UserAddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddressCountOutputType
     */
    select?: UserAddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserAddressCountOutputType without action
   */
  export type UserAddressCountOutputTypeCountOrderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetailsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AnchorText
   */

  export type AggregateAnchorText = {
    _count: AnchorTextCountAggregateOutputType | null
    _min: AnchorTextMinAggregateOutputType | null
    _max: AnchorTextMaxAggregateOutputType | null
  }

  export type AnchorTextMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    data: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnchorTextMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    data: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnchorTextCountAggregateOutputType = {
    id: number
    categoryId: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnchorTextMinAggregateInputType = {
    id?: true
    categoryId?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnchorTextMaxAggregateInputType = {
    id?: true
    categoryId?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnchorTextCountAggregateInputType = {
    id?: true
    categoryId?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnchorTextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnchorText to aggregate.
     */
    where?: AnchorTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnchorTexts to fetch.
     */
    orderBy?: AnchorTextOrderByWithRelationInput | AnchorTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnchorTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnchorTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnchorTexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnchorTexts
    **/
    _count?: true | AnchorTextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnchorTextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnchorTextMaxAggregateInputType
  }

  export type GetAnchorTextAggregateType<T extends AnchorTextAggregateArgs> = {
        [P in keyof T & keyof AggregateAnchorText]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnchorText[P]>
      : GetScalarType<T[P], AggregateAnchorText[P]>
  }




  export type AnchorTextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnchorTextWhereInput
    orderBy?: AnchorTextOrderByWithAggregationInput | AnchorTextOrderByWithAggregationInput[]
    by: AnchorTextScalarFieldEnum[] | AnchorTextScalarFieldEnum
    having?: AnchorTextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnchorTextCountAggregateInputType | true
    _min?: AnchorTextMinAggregateInputType
    _max?: AnchorTextMaxAggregateInputType
  }

  export type AnchorTextGroupByOutputType = {
    id: string
    categoryId: string
    data: string
    createdAt: Date
    updatedAt: Date
    _count: AnchorTextCountAggregateOutputType | null
    _min: AnchorTextMinAggregateOutputType | null
    _max: AnchorTextMaxAggregateOutputType | null
  }

  type GetAnchorTextGroupByPayload<T extends AnchorTextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnchorTextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnchorTextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnchorTextGroupByOutputType[P]>
            : GetScalarType<T[P], AnchorTextGroupByOutputType[P]>
        }
      >
    >


  export type AnchorTextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anchorText"]>



  export type AnchorTextSelectScalar = {
    id?: boolean
    categoryId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnchorTextOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["anchorText"]>
  export type AnchorTextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }

  export type $AnchorTextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnchorText"
    objects: {
      ProductCategory: Prisma.$ProductCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      data: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["anchorText"]>
    composites: {}
  }

  type AnchorTextGetPayload<S extends boolean | null | undefined | AnchorTextDefaultArgs> = $Result.GetResult<Prisma.$AnchorTextPayload, S>

  type AnchorTextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnchorTextFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnchorTextCountAggregateInputType | true
    }

  export interface AnchorTextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnchorText'], meta: { name: 'AnchorText' } }
    /**
     * Find zero or one AnchorText that matches the filter.
     * @param {AnchorTextFindUniqueArgs} args - Arguments to find a AnchorText
     * @example
     * // Get one AnchorText
     * const anchorText = await prisma.anchorText.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnchorTextFindUniqueArgs>(args: SelectSubset<T, AnchorTextFindUniqueArgs<ExtArgs>>): Prisma__AnchorTextClient<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnchorText that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnchorTextFindUniqueOrThrowArgs} args - Arguments to find a AnchorText
     * @example
     * // Get one AnchorText
     * const anchorText = await prisma.anchorText.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnchorTextFindUniqueOrThrowArgs>(args: SelectSubset<T, AnchorTextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnchorTextClient<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnchorText that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnchorTextFindFirstArgs} args - Arguments to find a AnchorText
     * @example
     * // Get one AnchorText
     * const anchorText = await prisma.anchorText.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnchorTextFindFirstArgs>(args?: SelectSubset<T, AnchorTextFindFirstArgs<ExtArgs>>): Prisma__AnchorTextClient<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnchorText that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnchorTextFindFirstOrThrowArgs} args - Arguments to find a AnchorText
     * @example
     * // Get one AnchorText
     * const anchorText = await prisma.anchorText.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnchorTextFindFirstOrThrowArgs>(args?: SelectSubset<T, AnchorTextFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnchorTextClient<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnchorTexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnchorTextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnchorTexts
     * const anchorTexts = await prisma.anchorText.findMany()
     * 
     * // Get first 10 AnchorTexts
     * const anchorTexts = await prisma.anchorText.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anchorTextWithIdOnly = await prisma.anchorText.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnchorTextFindManyArgs>(args?: SelectSubset<T, AnchorTextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnchorText.
     * @param {AnchorTextCreateArgs} args - Arguments to create a AnchorText.
     * @example
     * // Create one AnchorText
     * const AnchorText = await prisma.anchorText.create({
     *   data: {
     *     // ... data to create a AnchorText
     *   }
     * })
     * 
     */
    create<T extends AnchorTextCreateArgs>(args: SelectSubset<T, AnchorTextCreateArgs<ExtArgs>>): Prisma__AnchorTextClient<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnchorTexts.
     * @param {AnchorTextCreateManyArgs} args - Arguments to create many AnchorTexts.
     * @example
     * // Create many AnchorTexts
     * const anchorText = await prisma.anchorText.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnchorTextCreateManyArgs>(args?: SelectSubset<T, AnchorTextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AnchorText.
     * @param {AnchorTextDeleteArgs} args - Arguments to delete one AnchorText.
     * @example
     * // Delete one AnchorText
     * const AnchorText = await prisma.anchorText.delete({
     *   where: {
     *     // ... filter to delete one AnchorText
     *   }
     * })
     * 
     */
    delete<T extends AnchorTextDeleteArgs>(args: SelectSubset<T, AnchorTextDeleteArgs<ExtArgs>>): Prisma__AnchorTextClient<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnchorText.
     * @param {AnchorTextUpdateArgs} args - Arguments to update one AnchorText.
     * @example
     * // Update one AnchorText
     * const anchorText = await prisma.anchorText.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnchorTextUpdateArgs>(args: SelectSubset<T, AnchorTextUpdateArgs<ExtArgs>>): Prisma__AnchorTextClient<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnchorTexts.
     * @param {AnchorTextDeleteManyArgs} args - Arguments to filter AnchorTexts to delete.
     * @example
     * // Delete a few AnchorTexts
     * const { count } = await prisma.anchorText.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnchorTextDeleteManyArgs>(args?: SelectSubset<T, AnchorTextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnchorTexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnchorTextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnchorTexts
     * const anchorText = await prisma.anchorText.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnchorTextUpdateManyArgs>(args: SelectSubset<T, AnchorTextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnchorText.
     * @param {AnchorTextUpsertArgs} args - Arguments to update or create a AnchorText.
     * @example
     * // Update or create a AnchorText
     * const anchorText = await prisma.anchorText.upsert({
     *   create: {
     *     // ... data to create a AnchorText
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnchorText we want to update
     *   }
     * })
     */
    upsert<T extends AnchorTextUpsertArgs>(args: SelectSubset<T, AnchorTextUpsertArgs<ExtArgs>>): Prisma__AnchorTextClient<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnchorTexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnchorTextCountArgs} args - Arguments to filter AnchorTexts to count.
     * @example
     * // Count the number of AnchorTexts
     * const count = await prisma.anchorText.count({
     *   where: {
     *     // ... the filter for the AnchorTexts we want to count
     *   }
     * })
    **/
    count<T extends AnchorTextCountArgs>(
      args?: Subset<T, AnchorTextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnchorTextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnchorText.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnchorTextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnchorTextAggregateArgs>(args: Subset<T, AnchorTextAggregateArgs>): Prisma.PrismaPromise<GetAnchorTextAggregateType<T>>

    /**
     * Group by AnchorText.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnchorTextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnchorTextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnchorTextGroupByArgs['orderBy'] }
        : { orderBy?: AnchorTextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnchorTextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnchorTextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnchorText model
   */
  readonly fields: AnchorTextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnchorText.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnchorTextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProductCategory<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnchorText model
   */ 
  interface AnchorTextFieldRefs {
    readonly id: FieldRef<"AnchorText", 'String'>
    readonly categoryId: FieldRef<"AnchorText", 'String'>
    readonly data: FieldRef<"AnchorText", 'String'>
    readonly createdAt: FieldRef<"AnchorText", 'DateTime'>
    readonly updatedAt: FieldRef<"AnchorText", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnchorText findUnique
   */
  export type AnchorTextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    /**
     * Filter, which AnchorText to fetch.
     */
    where: AnchorTextWhereUniqueInput
  }

  /**
   * AnchorText findUniqueOrThrow
   */
  export type AnchorTextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    /**
     * Filter, which AnchorText to fetch.
     */
    where: AnchorTextWhereUniqueInput
  }

  /**
   * AnchorText findFirst
   */
  export type AnchorTextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    /**
     * Filter, which AnchorText to fetch.
     */
    where?: AnchorTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnchorTexts to fetch.
     */
    orderBy?: AnchorTextOrderByWithRelationInput | AnchorTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnchorTexts.
     */
    cursor?: AnchorTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnchorTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnchorTexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnchorTexts.
     */
    distinct?: AnchorTextScalarFieldEnum | AnchorTextScalarFieldEnum[]
  }

  /**
   * AnchorText findFirstOrThrow
   */
  export type AnchorTextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    /**
     * Filter, which AnchorText to fetch.
     */
    where?: AnchorTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnchorTexts to fetch.
     */
    orderBy?: AnchorTextOrderByWithRelationInput | AnchorTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnchorTexts.
     */
    cursor?: AnchorTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnchorTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnchorTexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnchorTexts.
     */
    distinct?: AnchorTextScalarFieldEnum | AnchorTextScalarFieldEnum[]
  }

  /**
   * AnchorText findMany
   */
  export type AnchorTextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    /**
     * Filter, which AnchorTexts to fetch.
     */
    where?: AnchorTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnchorTexts to fetch.
     */
    orderBy?: AnchorTextOrderByWithRelationInput | AnchorTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnchorTexts.
     */
    cursor?: AnchorTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnchorTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnchorTexts.
     */
    skip?: number
    distinct?: AnchorTextScalarFieldEnum | AnchorTextScalarFieldEnum[]
  }

  /**
   * AnchorText create
   */
  export type AnchorTextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    /**
     * The data needed to create a AnchorText.
     */
    data: XOR<AnchorTextCreateInput, AnchorTextUncheckedCreateInput>
  }

  /**
   * AnchorText createMany
   */
  export type AnchorTextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnchorTexts.
     */
    data: AnchorTextCreateManyInput | AnchorTextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnchorText update
   */
  export type AnchorTextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    /**
     * The data needed to update a AnchorText.
     */
    data: XOR<AnchorTextUpdateInput, AnchorTextUncheckedUpdateInput>
    /**
     * Choose, which AnchorText to update.
     */
    where: AnchorTextWhereUniqueInput
  }

  /**
   * AnchorText updateMany
   */
  export type AnchorTextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnchorTexts.
     */
    data: XOR<AnchorTextUpdateManyMutationInput, AnchorTextUncheckedUpdateManyInput>
    /**
     * Filter which AnchorTexts to update
     */
    where?: AnchorTextWhereInput
    /**
     * Limit how many AnchorTexts to update.
     */
    limit?: number
  }

  /**
   * AnchorText upsert
   */
  export type AnchorTextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    /**
     * The filter to search for the AnchorText to update in case it exists.
     */
    where: AnchorTextWhereUniqueInput
    /**
     * In case the AnchorText found by the `where` argument doesn't exist, create a new AnchorText with this data.
     */
    create: XOR<AnchorTextCreateInput, AnchorTextUncheckedCreateInput>
    /**
     * In case the AnchorText was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnchorTextUpdateInput, AnchorTextUncheckedUpdateInput>
  }

  /**
   * AnchorText delete
   */
  export type AnchorTextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    /**
     * Filter which AnchorText to delete.
     */
    where: AnchorTextWhereUniqueInput
  }

  /**
   * AnchorText deleteMany
   */
  export type AnchorTextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnchorTexts to delete
     */
    where?: AnchorTextWhereInput
    /**
     * Limit how many AnchorTexts to delete.
     */
    limit?: number
  }

  /**
   * AnchorText without action
   */
  export type AnchorTextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
  }


  /**
   * Model Announcements
   */

  export type AggregateAnnouncements = {
    _count: AnnouncementsCountAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  export type AnnouncementsMinAggregateOutputType = {
    id: string | null
    text: string | null
  }

  export type AnnouncementsMaxAggregateOutputType = {
    id: string | null
    text: string | null
  }

  export type AnnouncementsCountAggregateOutputType = {
    id: number
    text: number
    _all: number
  }


  export type AnnouncementsMinAggregateInputType = {
    id?: true
    text?: true
  }

  export type AnnouncementsMaxAggregateInputType = {
    id?: true
    text?: true
  }

  export type AnnouncementsCountAggregateInputType = {
    id?: true
    text?: true
    _all?: true
  }

  export type AnnouncementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to aggregate.
     */
    where?: AnnouncementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementsOrderByWithRelationInput | AnnouncementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type GetAnnouncementsAggregateType<T extends AnnouncementsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncements[P]>
      : GetScalarType<T[P], AggregateAnnouncements[P]>
  }




  export type AnnouncementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementsWhereInput
    orderBy?: AnnouncementsOrderByWithAggregationInput | AnnouncementsOrderByWithAggregationInput[]
    by: AnnouncementsScalarFieldEnum[] | AnnouncementsScalarFieldEnum
    having?: AnnouncementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementsCountAggregateInputType | true
    _min?: AnnouncementsMinAggregateInputType
    _max?: AnnouncementsMaxAggregateInputType
  }

  export type AnnouncementsGroupByOutputType = {
    id: string
    text: string | null
    _count: AnnouncementsCountAggregateOutputType | null
    _min: AnnouncementsMinAggregateOutputType | null
    _max: AnnouncementsMaxAggregateOutputType | null
  }

  type GetAnnouncementsGroupByPayload<T extends AnnouncementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementsGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
  }, ExtArgs["result"]["announcements"]>



  export type AnnouncementsSelectScalar = {
    id?: boolean
    text?: boolean
  }

  export type AnnouncementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text", ExtArgs["result"]["announcements"]>

  export type $AnnouncementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcements"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string | null
    }, ExtArgs["result"]["announcements"]>
    composites: {}
  }

  type AnnouncementsGetPayload<S extends boolean | null | undefined | AnnouncementsDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementsPayload, S>

  type AnnouncementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementsCountAggregateInputType | true
    }

  export interface AnnouncementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcements'], meta: { name: 'Announcements' } }
    /**
     * Find zero or one Announcements that matches the filter.
     * @param {AnnouncementsFindUniqueArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementsFindUniqueArgs>(args: SelectSubset<T, AnnouncementsFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementsFindUniqueOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementsFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsFindFirstArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementsFindFirstArgs>(args?: SelectSubset<T, AnnouncementsFindFirstArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsFindFirstOrThrowArgs} args - Arguments to find a Announcements
     * @example
     * // Get one Announcements
     * const announcements = await prisma.announcements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementsFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcements.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementsWithIdOnly = await prisma.announcements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementsFindManyArgs>(args?: SelectSubset<T, AnnouncementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcements.
     * @param {AnnouncementsCreateArgs} args - Arguments to create a Announcements.
     * @example
     * // Create one Announcements
     * const Announcements = await prisma.announcements.create({
     *   data: {
     *     // ... data to create a Announcements
     *   }
     * })
     * 
     */
    create<T extends AnnouncementsCreateArgs>(args: SelectSubset<T, AnnouncementsCreateArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementsCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcements = await prisma.announcements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementsCreateManyArgs>(args?: SelectSubset<T, AnnouncementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Announcements.
     * @param {AnnouncementsDeleteArgs} args - Arguments to delete one Announcements.
     * @example
     * // Delete one Announcements
     * const Announcements = await prisma.announcements.delete({
     *   where: {
     *     // ... filter to delete one Announcements
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementsDeleteArgs>(args: SelectSubset<T, AnnouncementsDeleteArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcements.
     * @param {AnnouncementsUpdateArgs} args - Arguments to update one Announcements.
     * @example
     * // Update one Announcements
     * const announcements = await prisma.announcements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementsUpdateArgs>(args: SelectSubset<T, AnnouncementsUpdateArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementsDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementsDeleteManyArgs>(args?: SelectSubset<T, AnnouncementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcements = await prisma.announcements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementsUpdateManyArgs>(args: SelectSubset<T, AnnouncementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Announcements.
     * @param {AnnouncementsUpsertArgs} args - Arguments to update or create a Announcements.
     * @example
     * // Update or create a Announcements
     * const announcements = await prisma.announcements.upsert({
     *   create: {
     *     // ... data to create a Announcements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcements we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementsUpsertArgs>(args: SelectSubset<T, AnnouncementsUpsertArgs<ExtArgs>>): Prisma__AnnouncementsClient<$Result.GetResult<Prisma.$AnnouncementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcements.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementsCountArgs>(
      args?: Subset<T, AnnouncementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementsAggregateArgs>(args: Subset<T, AnnouncementsAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementsAggregateType<T>>

    /**
     * Group by Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementsGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcements model
   */
  readonly fields: AnnouncementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcements model
   */ 
  interface AnnouncementsFieldRefs {
    readonly id: FieldRef<"Announcements", 'String'>
    readonly text: FieldRef<"Announcements", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Announcements findUnique
   */
  export type AnnouncementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where: AnnouncementsWhereUniqueInput
  }

  /**
   * Announcements findUniqueOrThrow
   */
  export type AnnouncementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where: AnnouncementsWhereUniqueInput
  }

  /**
   * Announcements findFirst
   */
  export type AnnouncementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementsOrderByWithRelationInput | AnnouncementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * Announcements findFirstOrThrow
   */
  export type AnnouncementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementsOrderByWithRelationInput | AnnouncementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * Announcements findMany
   */
  export type AnnouncementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementsOrderByWithRelationInput | AnnouncementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementsScalarFieldEnum | AnnouncementsScalarFieldEnum[]
  }

  /**
   * Announcements create
   */
  export type AnnouncementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * The data needed to create a Announcements.
     */
    data: XOR<AnnouncementsCreateInput, AnnouncementsUncheckedCreateInput>
  }

  /**
   * Announcements createMany
   */
  export type AnnouncementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementsCreateManyInput | AnnouncementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcements update
   */
  export type AnnouncementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * The data needed to update a Announcements.
     */
    data: XOR<AnnouncementsUpdateInput, AnnouncementsUncheckedUpdateInput>
    /**
     * Choose, which Announcements to update.
     */
    where: AnnouncementsWhereUniqueInput
  }

  /**
   * Announcements updateMany
   */
  export type AnnouncementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementsUpdateManyMutationInput, AnnouncementsUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementsWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcements upsert
   */
  export type AnnouncementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * The filter to search for the Announcements to update in case it exists.
     */
    where: AnnouncementsWhereUniqueInput
    /**
     * In case the Announcements found by the `where` argument doesn't exist, create a new Announcements with this data.
     */
    create: XOR<AnnouncementsCreateInput, AnnouncementsUncheckedCreateInput>
    /**
     * In case the Announcements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementsUpdateInput, AnnouncementsUncheckedUpdateInput>
  }

  /**
   * Announcements delete
   */
  export type AnnouncementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
    /**
     * Filter which Announcements to delete.
     */
    where: AnnouncementsWhereUniqueInput
  }

  /**
   * Announcements deleteMany
   */
  export type AnnouncementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementsWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcements without action
   */
  export type AnnouncementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcements
     */
    select?: AnnouncementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcements
     */
    omit?: AnnouncementsOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    description: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    description?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    description?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    description: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    User?: boolean | AuditLog$UserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>



  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "description" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | AuditLog$UserArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends AuditLog$UserArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly description: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.User
   */
  export type AuditLog$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model BestSelling
   */

  export type AggregateBestSelling = {
    _count: BestSellingCountAggregateOutputType | null
    _min: BestSellingMinAggregateOutputType | null
    _max: BestSellingMaxAggregateOutputType | null
  }

  export type BestSellingMinAggregateOutputType = {
    id: string | null
    title: string | null
    hyperLink: string | null
    price: string | null
  }

  export type BestSellingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    hyperLink: string | null
    price: string | null
  }

  export type BestSellingCountAggregateOutputType = {
    id: number
    title: number
    hyperLink: number
    price: number
    _all: number
  }


  export type BestSellingMinAggregateInputType = {
    id?: true
    title?: true
    hyperLink?: true
    price?: true
  }

  export type BestSellingMaxAggregateInputType = {
    id?: true
    title?: true
    hyperLink?: true
    price?: true
  }

  export type BestSellingCountAggregateInputType = {
    id?: true
    title?: true
    hyperLink?: true
    price?: true
    _all?: true
  }

  export type BestSellingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BestSelling to aggregate.
     */
    where?: BestSellingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BestSellings to fetch.
     */
    orderBy?: BestSellingOrderByWithRelationInput | BestSellingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BestSellingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BestSellings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BestSellings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BestSellings
    **/
    _count?: true | BestSellingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BestSellingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BestSellingMaxAggregateInputType
  }

  export type GetBestSellingAggregateType<T extends BestSellingAggregateArgs> = {
        [P in keyof T & keyof AggregateBestSelling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBestSelling[P]>
      : GetScalarType<T[P], AggregateBestSelling[P]>
  }




  export type BestSellingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BestSellingWhereInput
    orderBy?: BestSellingOrderByWithAggregationInput | BestSellingOrderByWithAggregationInput[]
    by: BestSellingScalarFieldEnum[] | BestSellingScalarFieldEnum
    having?: BestSellingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BestSellingCountAggregateInputType | true
    _min?: BestSellingMinAggregateInputType
    _max?: BestSellingMaxAggregateInputType
  }

  export type BestSellingGroupByOutputType = {
    id: string
    title: string
    hyperLink: string
    price: string
    _count: BestSellingCountAggregateOutputType | null
    _min: BestSellingMinAggregateOutputType | null
    _max: BestSellingMaxAggregateOutputType | null
  }

  type GetBestSellingGroupByPayload<T extends BestSellingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BestSellingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BestSellingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BestSellingGroupByOutputType[P]>
            : GetScalarType<T[P], BestSellingGroupByOutputType[P]>
        }
      >
    >


  export type BestSellingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    hyperLink?: boolean
    price?: boolean
  }, ExtArgs["result"]["bestSelling"]>



  export type BestSellingSelectScalar = {
    id?: boolean
    title?: boolean
    hyperLink?: boolean
    price?: boolean
  }

  export type BestSellingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "hyperLink" | "price", ExtArgs["result"]["bestSelling"]>

  export type $BestSellingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BestSelling"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      hyperLink: string
      price: string
    }, ExtArgs["result"]["bestSelling"]>
    composites: {}
  }

  type BestSellingGetPayload<S extends boolean | null | undefined | BestSellingDefaultArgs> = $Result.GetResult<Prisma.$BestSellingPayload, S>

  type BestSellingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BestSellingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BestSellingCountAggregateInputType | true
    }

  export interface BestSellingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BestSelling'], meta: { name: 'BestSelling' } }
    /**
     * Find zero or one BestSelling that matches the filter.
     * @param {BestSellingFindUniqueArgs} args - Arguments to find a BestSelling
     * @example
     * // Get one BestSelling
     * const bestSelling = await prisma.bestSelling.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BestSellingFindUniqueArgs>(args: SelectSubset<T, BestSellingFindUniqueArgs<ExtArgs>>): Prisma__BestSellingClient<$Result.GetResult<Prisma.$BestSellingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BestSelling that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BestSellingFindUniqueOrThrowArgs} args - Arguments to find a BestSelling
     * @example
     * // Get one BestSelling
     * const bestSelling = await prisma.bestSelling.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BestSellingFindUniqueOrThrowArgs>(args: SelectSubset<T, BestSellingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BestSellingClient<$Result.GetResult<Prisma.$BestSellingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BestSelling that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BestSellingFindFirstArgs} args - Arguments to find a BestSelling
     * @example
     * // Get one BestSelling
     * const bestSelling = await prisma.bestSelling.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BestSellingFindFirstArgs>(args?: SelectSubset<T, BestSellingFindFirstArgs<ExtArgs>>): Prisma__BestSellingClient<$Result.GetResult<Prisma.$BestSellingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BestSelling that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BestSellingFindFirstOrThrowArgs} args - Arguments to find a BestSelling
     * @example
     * // Get one BestSelling
     * const bestSelling = await prisma.bestSelling.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BestSellingFindFirstOrThrowArgs>(args?: SelectSubset<T, BestSellingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BestSellingClient<$Result.GetResult<Prisma.$BestSellingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BestSellings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BestSellingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BestSellings
     * const bestSellings = await prisma.bestSelling.findMany()
     * 
     * // Get first 10 BestSellings
     * const bestSellings = await prisma.bestSelling.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bestSellingWithIdOnly = await prisma.bestSelling.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BestSellingFindManyArgs>(args?: SelectSubset<T, BestSellingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BestSellingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BestSelling.
     * @param {BestSellingCreateArgs} args - Arguments to create a BestSelling.
     * @example
     * // Create one BestSelling
     * const BestSelling = await prisma.bestSelling.create({
     *   data: {
     *     // ... data to create a BestSelling
     *   }
     * })
     * 
     */
    create<T extends BestSellingCreateArgs>(args: SelectSubset<T, BestSellingCreateArgs<ExtArgs>>): Prisma__BestSellingClient<$Result.GetResult<Prisma.$BestSellingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BestSellings.
     * @param {BestSellingCreateManyArgs} args - Arguments to create many BestSellings.
     * @example
     * // Create many BestSellings
     * const bestSelling = await prisma.bestSelling.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BestSellingCreateManyArgs>(args?: SelectSubset<T, BestSellingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BestSelling.
     * @param {BestSellingDeleteArgs} args - Arguments to delete one BestSelling.
     * @example
     * // Delete one BestSelling
     * const BestSelling = await prisma.bestSelling.delete({
     *   where: {
     *     // ... filter to delete one BestSelling
     *   }
     * })
     * 
     */
    delete<T extends BestSellingDeleteArgs>(args: SelectSubset<T, BestSellingDeleteArgs<ExtArgs>>): Prisma__BestSellingClient<$Result.GetResult<Prisma.$BestSellingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BestSelling.
     * @param {BestSellingUpdateArgs} args - Arguments to update one BestSelling.
     * @example
     * // Update one BestSelling
     * const bestSelling = await prisma.bestSelling.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BestSellingUpdateArgs>(args: SelectSubset<T, BestSellingUpdateArgs<ExtArgs>>): Prisma__BestSellingClient<$Result.GetResult<Prisma.$BestSellingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BestSellings.
     * @param {BestSellingDeleteManyArgs} args - Arguments to filter BestSellings to delete.
     * @example
     * // Delete a few BestSellings
     * const { count } = await prisma.bestSelling.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BestSellingDeleteManyArgs>(args?: SelectSubset<T, BestSellingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BestSellings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BestSellingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BestSellings
     * const bestSelling = await prisma.bestSelling.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BestSellingUpdateManyArgs>(args: SelectSubset<T, BestSellingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BestSelling.
     * @param {BestSellingUpsertArgs} args - Arguments to update or create a BestSelling.
     * @example
     * // Update or create a BestSelling
     * const bestSelling = await prisma.bestSelling.upsert({
     *   create: {
     *     // ... data to create a BestSelling
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BestSelling we want to update
     *   }
     * })
     */
    upsert<T extends BestSellingUpsertArgs>(args: SelectSubset<T, BestSellingUpsertArgs<ExtArgs>>): Prisma__BestSellingClient<$Result.GetResult<Prisma.$BestSellingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BestSellings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BestSellingCountArgs} args - Arguments to filter BestSellings to count.
     * @example
     * // Count the number of BestSellings
     * const count = await prisma.bestSelling.count({
     *   where: {
     *     // ... the filter for the BestSellings we want to count
     *   }
     * })
    **/
    count<T extends BestSellingCountArgs>(
      args?: Subset<T, BestSellingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BestSellingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BestSelling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BestSellingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BestSellingAggregateArgs>(args: Subset<T, BestSellingAggregateArgs>): Prisma.PrismaPromise<GetBestSellingAggregateType<T>>

    /**
     * Group by BestSelling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BestSellingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BestSellingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BestSellingGroupByArgs['orderBy'] }
        : { orderBy?: BestSellingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BestSellingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBestSellingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BestSelling model
   */
  readonly fields: BestSellingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BestSelling.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BestSellingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BestSelling model
   */ 
  interface BestSellingFieldRefs {
    readonly id: FieldRef<"BestSelling", 'String'>
    readonly title: FieldRef<"BestSelling", 'String'>
    readonly hyperLink: FieldRef<"BestSelling", 'String'>
    readonly price: FieldRef<"BestSelling", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BestSelling findUnique
   */
  export type BestSellingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
    /**
     * Filter, which BestSelling to fetch.
     */
    where: BestSellingWhereUniqueInput
  }

  /**
   * BestSelling findUniqueOrThrow
   */
  export type BestSellingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
    /**
     * Filter, which BestSelling to fetch.
     */
    where: BestSellingWhereUniqueInput
  }

  /**
   * BestSelling findFirst
   */
  export type BestSellingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
    /**
     * Filter, which BestSelling to fetch.
     */
    where?: BestSellingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BestSellings to fetch.
     */
    orderBy?: BestSellingOrderByWithRelationInput | BestSellingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BestSellings.
     */
    cursor?: BestSellingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BestSellings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BestSellings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BestSellings.
     */
    distinct?: BestSellingScalarFieldEnum | BestSellingScalarFieldEnum[]
  }

  /**
   * BestSelling findFirstOrThrow
   */
  export type BestSellingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
    /**
     * Filter, which BestSelling to fetch.
     */
    where?: BestSellingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BestSellings to fetch.
     */
    orderBy?: BestSellingOrderByWithRelationInput | BestSellingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BestSellings.
     */
    cursor?: BestSellingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BestSellings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BestSellings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BestSellings.
     */
    distinct?: BestSellingScalarFieldEnum | BestSellingScalarFieldEnum[]
  }

  /**
   * BestSelling findMany
   */
  export type BestSellingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
    /**
     * Filter, which BestSellings to fetch.
     */
    where?: BestSellingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BestSellings to fetch.
     */
    orderBy?: BestSellingOrderByWithRelationInput | BestSellingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BestSellings.
     */
    cursor?: BestSellingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BestSellings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BestSellings.
     */
    skip?: number
    distinct?: BestSellingScalarFieldEnum | BestSellingScalarFieldEnum[]
  }

  /**
   * BestSelling create
   */
  export type BestSellingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
    /**
     * The data needed to create a BestSelling.
     */
    data: XOR<BestSellingCreateInput, BestSellingUncheckedCreateInput>
  }

  /**
   * BestSelling createMany
   */
  export type BestSellingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BestSellings.
     */
    data: BestSellingCreateManyInput | BestSellingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BestSelling update
   */
  export type BestSellingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
    /**
     * The data needed to update a BestSelling.
     */
    data: XOR<BestSellingUpdateInput, BestSellingUncheckedUpdateInput>
    /**
     * Choose, which BestSelling to update.
     */
    where: BestSellingWhereUniqueInput
  }

  /**
   * BestSelling updateMany
   */
  export type BestSellingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BestSellings.
     */
    data: XOR<BestSellingUpdateManyMutationInput, BestSellingUncheckedUpdateManyInput>
    /**
     * Filter which BestSellings to update
     */
    where?: BestSellingWhereInput
    /**
     * Limit how many BestSellings to update.
     */
    limit?: number
  }

  /**
   * BestSelling upsert
   */
  export type BestSellingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
    /**
     * The filter to search for the BestSelling to update in case it exists.
     */
    where: BestSellingWhereUniqueInput
    /**
     * In case the BestSelling found by the `where` argument doesn't exist, create a new BestSelling with this data.
     */
    create: XOR<BestSellingCreateInput, BestSellingUncheckedCreateInput>
    /**
     * In case the BestSelling was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BestSellingUpdateInput, BestSellingUncheckedUpdateInput>
  }

  /**
   * BestSelling delete
   */
  export type BestSellingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
    /**
     * Filter which BestSelling to delete.
     */
    where: BestSellingWhereUniqueInput
  }

  /**
   * BestSelling deleteMany
   */
  export type BestSellingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BestSellings to delete
     */
    where?: BestSellingWhereInput
    /**
     * Limit how many BestSellings to delete.
     */
    limit?: number
  }

  /**
   * BestSelling without action
   */
  export type BestSellingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BestSelling
     */
    select?: BestSellingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BestSelling
     */
    omit?: BestSellingOmit<ExtArgs> | null
  }


  /**
   * Model CallRequest
   */

  export type AggregateCallRequest = {
    _count: CallRequestCountAggregateOutputType | null
    _min: CallRequestMinAggregateOutputType | null
    _max: CallRequestMaxAggregateOutputType | null
  }

  export type CallRequestMinAggregateOutputType = {
    id: string | null
    mobileNumber: string | null
    orderId: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallRequestMaxAggregateOutputType = {
    id: string | null
    mobileNumber: string | null
    orderId: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallRequestCountAggregateOutputType = {
    id: number
    mobileNumber: number
    orderId: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CallRequestMinAggregateInputType = {
    id?: true
    mobileNumber?: true
    orderId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallRequestMaxAggregateInputType = {
    id?: true
    mobileNumber?: true
    orderId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallRequestCountAggregateInputType = {
    id?: true
    mobileNumber?: true
    orderId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CallRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallRequest to aggregate.
     */
    where?: CallRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRequests to fetch.
     */
    orderBy?: CallRequestOrderByWithRelationInput | CallRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallRequests
    **/
    _count?: true | CallRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallRequestMaxAggregateInputType
  }

  export type GetCallRequestAggregateType<T extends CallRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCallRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallRequest[P]>
      : GetScalarType<T[P], AggregateCallRequest[P]>
  }




  export type CallRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallRequestWhereInput
    orderBy?: CallRequestOrderByWithAggregationInput | CallRequestOrderByWithAggregationInput[]
    by: CallRequestScalarFieldEnum[] | CallRequestScalarFieldEnum
    having?: CallRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallRequestCountAggregateInputType | true
    _min?: CallRequestMinAggregateInputType
    _max?: CallRequestMaxAggregateInputType
  }

  export type CallRequestGroupByOutputType = {
    id: string
    mobileNumber: string
    orderId: string | null
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: CallRequestCountAggregateOutputType | null
    _min: CallRequestMinAggregateOutputType | null
    _max: CallRequestMaxAggregateOutputType | null
  }

  type GetCallRequestGroupByPayload<T extends CallRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CallRequestGroupByOutputType[P]>
        }
      >
    >


  export type CallRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobileNumber?: boolean
    orderId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["callRequest"]>



  export type CallRequestSelectScalar = {
    id?: boolean
    mobileNumber?: boolean
    orderId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CallRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mobileNumber" | "orderId" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["callRequest"]>

  export type $CallRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mobileNumber: string
      orderId: string | null
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["callRequest"]>
    composites: {}
  }

  type CallRequestGetPayload<S extends boolean | null | undefined | CallRequestDefaultArgs> = $Result.GetResult<Prisma.$CallRequestPayload, S>

  type CallRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallRequestCountAggregateInputType | true
    }

  export interface CallRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallRequest'], meta: { name: 'CallRequest' } }
    /**
     * Find zero or one CallRequest that matches the filter.
     * @param {CallRequestFindUniqueArgs} args - Arguments to find a CallRequest
     * @example
     * // Get one CallRequest
     * const callRequest = await prisma.callRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallRequestFindUniqueArgs>(args: SelectSubset<T, CallRequestFindUniqueArgs<ExtArgs>>): Prisma__CallRequestClient<$Result.GetResult<Prisma.$CallRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CallRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallRequestFindUniqueOrThrowArgs} args - Arguments to find a CallRequest
     * @example
     * // Get one CallRequest
     * const callRequest = await prisma.callRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CallRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallRequestClient<$Result.GetResult<Prisma.$CallRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRequestFindFirstArgs} args - Arguments to find a CallRequest
     * @example
     * // Get one CallRequest
     * const callRequest = await prisma.callRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallRequestFindFirstArgs>(args?: SelectSubset<T, CallRequestFindFirstArgs<ExtArgs>>): Prisma__CallRequestClient<$Result.GetResult<Prisma.$CallRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRequestFindFirstOrThrowArgs} args - Arguments to find a CallRequest
     * @example
     * // Get one CallRequest
     * const callRequest = await prisma.callRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CallRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallRequestClient<$Result.GetResult<Prisma.$CallRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CallRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallRequests
     * const callRequests = await prisma.callRequest.findMany()
     * 
     * // Get first 10 CallRequests
     * const callRequests = await prisma.callRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callRequestWithIdOnly = await prisma.callRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallRequestFindManyArgs>(args?: SelectSubset<T, CallRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CallRequest.
     * @param {CallRequestCreateArgs} args - Arguments to create a CallRequest.
     * @example
     * // Create one CallRequest
     * const CallRequest = await prisma.callRequest.create({
     *   data: {
     *     // ... data to create a CallRequest
     *   }
     * })
     * 
     */
    create<T extends CallRequestCreateArgs>(args: SelectSubset<T, CallRequestCreateArgs<ExtArgs>>): Prisma__CallRequestClient<$Result.GetResult<Prisma.$CallRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CallRequests.
     * @param {CallRequestCreateManyArgs} args - Arguments to create many CallRequests.
     * @example
     * // Create many CallRequests
     * const callRequest = await prisma.callRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallRequestCreateManyArgs>(args?: SelectSubset<T, CallRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CallRequest.
     * @param {CallRequestDeleteArgs} args - Arguments to delete one CallRequest.
     * @example
     * // Delete one CallRequest
     * const CallRequest = await prisma.callRequest.delete({
     *   where: {
     *     // ... filter to delete one CallRequest
     *   }
     * })
     * 
     */
    delete<T extends CallRequestDeleteArgs>(args: SelectSubset<T, CallRequestDeleteArgs<ExtArgs>>): Prisma__CallRequestClient<$Result.GetResult<Prisma.$CallRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CallRequest.
     * @param {CallRequestUpdateArgs} args - Arguments to update one CallRequest.
     * @example
     * // Update one CallRequest
     * const callRequest = await prisma.callRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallRequestUpdateArgs>(args: SelectSubset<T, CallRequestUpdateArgs<ExtArgs>>): Prisma__CallRequestClient<$Result.GetResult<Prisma.$CallRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CallRequests.
     * @param {CallRequestDeleteManyArgs} args - Arguments to filter CallRequests to delete.
     * @example
     * // Delete a few CallRequests
     * const { count } = await prisma.callRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallRequestDeleteManyArgs>(args?: SelectSubset<T, CallRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallRequests
     * const callRequest = await prisma.callRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallRequestUpdateManyArgs>(args: SelectSubset<T, CallRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CallRequest.
     * @param {CallRequestUpsertArgs} args - Arguments to update or create a CallRequest.
     * @example
     * // Update or create a CallRequest
     * const callRequest = await prisma.callRequest.upsert({
     *   create: {
     *     // ... data to create a CallRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallRequest we want to update
     *   }
     * })
     */
    upsert<T extends CallRequestUpsertArgs>(args: SelectSubset<T, CallRequestUpsertArgs<ExtArgs>>): Prisma__CallRequestClient<$Result.GetResult<Prisma.$CallRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CallRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRequestCountArgs} args - Arguments to filter CallRequests to count.
     * @example
     * // Count the number of CallRequests
     * const count = await prisma.callRequest.count({
     *   where: {
     *     // ... the filter for the CallRequests we want to count
     *   }
     * })
    **/
    count<T extends CallRequestCountArgs>(
      args?: Subset<T, CallRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallRequestAggregateArgs>(args: Subset<T, CallRequestAggregateArgs>): Prisma.PrismaPromise<GetCallRequestAggregateType<T>>

    /**
     * Group by CallRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallRequestGroupByArgs['orderBy'] }
        : { orderBy?: CallRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallRequest model
   */
  readonly fields: CallRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallRequest model
   */ 
  interface CallRequestFieldRefs {
    readonly id: FieldRef<"CallRequest", 'String'>
    readonly mobileNumber: FieldRef<"CallRequest", 'String'>
    readonly orderId: FieldRef<"CallRequest", 'String'>
    readonly isRead: FieldRef<"CallRequest", 'Boolean'>
    readonly createdAt: FieldRef<"CallRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"CallRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallRequest findUnique
   */
  export type CallRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
    /**
     * Filter, which CallRequest to fetch.
     */
    where: CallRequestWhereUniqueInput
  }

  /**
   * CallRequest findUniqueOrThrow
   */
  export type CallRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
    /**
     * Filter, which CallRequest to fetch.
     */
    where: CallRequestWhereUniqueInput
  }

  /**
   * CallRequest findFirst
   */
  export type CallRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
    /**
     * Filter, which CallRequest to fetch.
     */
    where?: CallRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRequests to fetch.
     */
    orderBy?: CallRequestOrderByWithRelationInput | CallRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallRequests.
     */
    cursor?: CallRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallRequests.
     */
    distinct?: CallRequestScalarFieldEnum | CallRequestScalarFieldEnum[]
  }

  /**
   * CallRequest findFirstOrThrow
   */
  export type CallRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
    /**
     * Filter, which CallRequest to fetch.
     */
    where?: CallRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRequests to fetch.
     */
    orderBy?: CallRequestOrderByWithRelationInput | CallRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallRequests.
     */
    cursor?: CallRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallRequests.
     */
    distinct?: CallRequestScalarFieldEnum | CallRequestScalarFieldEnum[]
  }

  /**
   * CallRequest findMany
   */
  export type CallRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
    /**
     * Filter, which CallRequests to fetch.
     */
    where?: CallRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRequests to fetch.
     */
    orderBy?: CallRequestOrderByWithRelationInput | CallRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallRequests.
     */
    cursor?: CallRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRequests.
     */
    skip?: number
    distinct?: CallRequestScalarFieldEnum | CallRequestScalarFieldEnum[]
  }

  /**
   * CallRequest create
   */
  export type CallRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a CallRequest.
     */
    data: XOR<CallRequestCreateInput, CallRequestUncheckedCreateInput>
  }

  /**
   * CallRequest createMany
   */
  export type CallRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallRequests.
     */
    data: CallRequestCreateManyInput | CallRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallRequest update
   */
  export type CallRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a CallRequest.
     */
    data: XOR<CallRequestUpdateInput, CallRequestUncheckedUpdateInput>
    /**
     * Choose, which CallRequest to update.
     */
    where: CallRequestWhereUniqueInput
  }

  /**
   * CallRequest updateMany
   */
  export type CallRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallRequests.
     */
    data: XOR<CallRequestUpdateManyMutationInput, CallRequestUncheckedUpdateManyInput>
    /**
     * Filter which CallRequests to update
     */
    where?: CallRequestWhereInput
    /**
     * Limit how many CallRequests to update.
     */
    limit?: number
  }

  /**
   * CallRequest upsert
   */
  export type CallRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the CallRequest to update in case it exists.
     */
    where: CallRequestWhereUniqueInput
    /**
     * In case the CallRequest found by the `where` argument doesn't exist, create a new CallRequest with this data.
     */
    create: XOR<CallRequestCreateInput, CallRequestUncheckedCreateInput>
    /**
     * In case the CallRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallRequestUpdateInput, CallRequestUncheckedUpdateInput>
  }

  /**
   * CallRequest delete
   */
  export type CallRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
    /**
     * Filter which CallRequest to delete.
     */
    where: CallRequestWhereUniqueInput
  }

  /**
   * CallRequest deleteMany
   */
  export type CallRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallRequests to delete
     */
    where?: CallRequestWhereInput
    /**
     * Limit how many CallRequests to delete.
     */
    limit?: number
  }

  /**
   * CallRequest without action
   */
  export type CallRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRequest
     */
    select?: CallRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRequest
     */
    omit?: CallRequestOmit<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type CartItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
    colorId: string | null
    sizeId: string | null
    imageId: string | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
    colorId: string | null
    sizeId: string | null
    imageId: string | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    quantity: number
    createdAt: number
    updatedAt: number
    colorId: number
    sizeId: number
    imageId: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    quantity?: true
  }

  export type CartItemSumAggregateInputType = {
    quantity?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    colorId?: true
    sizeId?: true
    imageId?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    colorId?: true
    sizeId?: true
    imageId?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    colorId?: true
    sizeId?: true
    imageId?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    userId: string
    productId: string
    quantity: number
    createdAt: Date
    updatedAt: Date
    colorId: string | null
    sizeId: string | null
    imageId: string | null
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    colorId?: boolean
    sizeId?: boolean
    imageId?: boolean
    ProductColor?: boolean | CartItem$ProductColorArgs<ExtArgs>
    ProductImage?: boolean | CartItem$ProductImageArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>



  export type CartItemSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    colorId?: boolean
    sizeId?: boolean
    imageId?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "quantity" | "createdAt" | "updatedAt" | "colorId" | "sizeId" | "imageId", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductColor?: boolean | CartItem$ProductColorArgs<ExtArgs>
    ProductImage?: boolean | CartItem$ProductImageArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      ProductColor: Prisma.$ProductColorPayload<ExtArgs> | null
      ProductImage: Prisma.$ProductImagePayload<ExtArgs> | null
      Product: Prisma.$ProductPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      quantity: number
      createdAt: Date
      updatedAt: Date
      colorId: string | null
      sizeId: string | null
      imageId: string | null
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProductColor<T extends CartItem$ProductColorArgs<ExtArgs> = {}>(args?: Subset<T, CartItem$ProductColorArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ProductImage<T extends CartItem$ProductImageArgs<ExtArgs> = {}>(args?: Subset<T, CartItem$ProductImageArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */ 
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly userId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CartItem", 'DateTime'>
    readonly colorId: FieldRef<"CartItem", 'String'>
    readonly sizeId: FieldRef<"CartItem", 'String'>
    readonly imageId: FieldRef<"CartItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem.ProductColor
   */
  export type CartItem$ProductColorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    where?: ProductColorWhereInput
  }

  /**
   * CartItem.ProductImage
   */
  export type CartItem$ProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model ContactUs
   */

  export type AggregateContactUs = {
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  export type ContactUsMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactUsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactUsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactUsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactUsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactUsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactUsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactUs to aggregate.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contactuses
    **/
    _count?: true | ContactUsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactUsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactUsMaxAggregateInputType
  }

  export type GetContactUsAggregateType<T extends ContactUsAggregateArgs> = {
        [P in keyof T & keyof AggregateContactUs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactUs[P]>
      : GetScalarType<T[P], AggregateContactUs[P]>
  }




  export type ContactUsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactUsWhereInput
    orderBy?: ContactUsOrderByWithAggregationInput | ContactUsOrderByWithAggregationInput[]
    by: ContactUsScalarFieldEnum[] | ContactUsScalarFieldEnum
    having?: ContactUsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactUsCountAggregateInputType | true
    _min?: ContactUsMinAggregateInputType
    _max?: ContactUsMaxAggregateInputType
  }

  export type ContactUsGroupByOutputType = {
    id: string
    name: string
    email: string
    message: string
    createdAt: Date
    updatedAt: Date
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  type GetContactUsGroupByPayload<T extends ContactUsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactUsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactUsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
        }
      >
    >


  export type ContactUsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactUs"]>



  export type ContactUsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactUsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["contactUs"]>

  export type $ContactUsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactUs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactUs"]>
    composites: {}
  }

  type ContactUsGetPayload<S extends boolean | null | undefined | ContactUsDefaultArgs> = $Result.GetResult<Prisma.$ContactUsPayload, S>

  type ContactUsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactUsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactUsCountAggregateInputType | true
    }

  export interface ContactUsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactUs'], meta: { name: 'ContactUs' } }
    /**
     * Find zero or one ContactUs that matches the filter.
     * @param {ContactUsFindUniqueArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactUsFindUniqueArgs>(args: SelectSubset<T, ContactUsFindUniqueArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactUs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactUsFindUniqueOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactUsFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactUsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactUs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactUsFindFirstArgs>(args?: SelectSubset<T, ContactUsFindFirstArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactUs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindFirstOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactUsFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactUsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contactuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactuses
     * const contactuses = await prisma.contactUs.findMany()
     * 
     * // Get first 10 Contactuses
     * const contactuses = await prisma.contactUs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactUsFindManyArgs>(args?: SelectSubset<T, ContactUsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactUs.
     * @param {ContactUsCreateArgs} args - Arguments to create a ContactUs.
     * @example
     * // Create one ContactUs
     * const ContactUs = await prisma.contactUs.create({
     *   data: {
     *     // ... data to create a ContactUs
     *   }
     * })
     * 
     */
    create<T extends ContactUsCreateArgs>(args: SelectSubset<T, ContactUsCreateArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contactuses.
     * @param {ContactUsCreateManyArgs} args - Arguments to create many Contactuses.
     * @example
     * // Create many Contactuses
     * const contactUs = await prisma.contactUs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactUsCreateManyArgs>(args?: SelectSubset<T, ContactUsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactUs.
     * @param {ContactUsDeleteArgs} args - Arguments to delete one ContactUs.
     * @example
     * // Delete one ContactUs
     * const ContactUs = await prisma.contactUs.delete({
     *   where: {
     *     // ... filter to delete one ContactUs
     *   }
     * })
     * 
     */
    delete<T extends ContactUsDeleteArgs>(args: SelectSubset<T, ContactUsDeleteArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactUs.
     * @param {ContactUsUpdateArgs} args - Arguments to update one ContactUs.
     * @example
     * // Update one ContactUs
     * const contactUs = await prisma.contactUs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUsUpdateArgs>(args: SelectSubset<T, ContactUsUpdateArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contactuses.
     * @param {ContactUsDeleteManyArgs} args - Arguments to filter Contactuses to delete.
     * @example
     * // Delete a few Contactuses
     * const { count } = await prisma.contactUs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactUsDeleteManyArgs>(args?: SelectSubset<T, ContactUsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUsUpdateManyArgs>(args: SelectSubset<T, ContactUsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactUs.
     * @param {ContactUsUpsertArgs} args - Arguments to update or create a ContactUs.
     * @example
     * // Update or create a ContactUs
     * const contactUs = await prisma.contactUs.upsert({
     *   create: {
     *     // ... data to create a ContactUs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactUs we want to update
     *   }
     * })
     */
    upsert<T extends ContactUsUpsertArgs>(args: SelectSubset<T, ContactUsUpsertArgs<ExtArgs>>): Prisma__ContactUsClient<$Result.GetResult<Prisma.$ContactUsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsCountArgs} args - Arguments to filter Contactuses to count.
     * @example
     * // Count the number of Contactuses
     * const count = await prisma.contactUs.count({
     *   where: {
     *     // ... the filter for the Contactuses we want to count
     *   }
     * })
    **/
    count<T extends ContactUsCountArgs>(
      args?: Subset<T, ContactUsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactUsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactUsAggregateArgs>(args: Subset<T, ContactUsAggregateArgs>): Prisma.PrismaPromise<GetContactUsAggregateType<T>>

    /**
     * Group by ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactUsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactUsGroupByArgs['orderBy'] }
        : { orderBy?: ContactUsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactUsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactUsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactUs model
   */
  readonly fields: ContactUsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactUs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactUsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactUs model
   */ 
  interface ContactUsFieldRefs {
    readonly id: FieldRef<"ContactUs", 'String'>
    readonly name: FieldRef<"ContactUs", 'String'>
    readonly email: FieldRef<"ContactUs", 'String'>
    readonly message: FieldRef<"ContactUs", 'String'>
    readonly createdAt: FieldRef<"ContactUs", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactUs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactUs findUnique
   */
  export type ContactUsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs findUniqueOrThrow
   */
  export type ContactUsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs findFirst
   */
  export type ContactUsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs findFirstOrThrow
   */
  export type ContactUsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which ContactUs to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs findMany
   */
  export type ContactUsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter, which Contactuses to fetch.
     */
    where?: ContactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contactuses to fetch.
     */
    orderBy?: ContactUsOrderByWithRelationInput | ContactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contactuses.
     */
    cursor?: ContactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contactuses.
     */
    skip?: number
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * ContactUs create
   */
  export type ContactUsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactUs.
     */
    data: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
  }

  /**
   * ContactUs createMany
   */
  export type ContactUsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contactuses.
     */
    data: ContactUsCreateManyInput | ContactUsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactUs update
   */
  export type ContactUsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactUs.
     */
    data: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
    /**
     * Choose, which ContactUs to update.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs updateMany
   */
  export type ContactUsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contactuses.
     */
    data: XOR<ContactUsUpdateManyMutationInput, ContactUsUncheckedUpdateManyInput>
    /**
     * Filter which Contactuses to update
     */
    where?: ContactUsWhereInput
    /**
     * Limit how many Contactuses to update.
     */
    limit?: number
  }

  /**
   * ContactUs upsert
   */
  export type ContactUsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactUs to update in case it exists.
     */
    where: ContactUsWhereUniqueInput
    /**
     * In case the ContactUs found by the `where` argument doesn't exist, create a new ContactUs with this data.
     */
    create: XOR<ContactUsCreateInput, ContactUsUncheckedCreateInput>
    /**
     * In case the ContactUs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUsUpdateInput, ContactUsUncheckedUpdateInput>
  }

  /**
   * ContactUs delete
   */
  export type ContactUsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
    /**
     * Filter which ContactUs to delete.
     */
    where: ContactUsWhereUniqueInput
  }

  /**
   * ContactUs deleteMany
   */
  export type ContactUsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contactuses to delete
     */
    where?: ContactUsWhereInput
    /**
     * Limit how many Contactuses to delete.
     */
    limit?: number
  }

  /**
   * ContactUs without action
   */
  export type ContactUsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUs
     */
    select?: ContactUsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUs
     */
    omit?: ContactUsOmit<ExtArgs> | null
  }


  /**
   * Model CustomerType
   */

  export type AggregateCustomerType = {
    _count: CustomerTypeCountAggregateOutputType | null
    _min: CustomerTypeMinAggregateOutputType | null
    _max: CustomerTypeMaxAggregateOutputType | null
  }

  export type CustomerTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    productId: string | null
  }

  export type CustomerTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    productId: string | null
  }

  export type CustomerTypeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    productId: number
    _all: number
  }


  export type CustomerTypeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    productId?: true
  }

  export type CustomerTypeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    productId?: true
  }

  export type CustomerTypeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    productId?: true
    _all?: true
  }

  export type CustomerTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerType to aggregate.
     */
    where?: CustomerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTypes to fetch.
     */
    orderBy?: CustomerTypeOrderByWithRelationInput | CustomerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerTypes
    **/
    _count?: true | CustomerTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerTypeMaxAggregateInputType
  }

  export type GetCustomerTypeAggregateType<T extends CustomerTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerType[P]>
      : GetScalarType<T[P], AggregateCustomerType[P]>
  }




  export type CustomerTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerTypeWhereInput
    orderBy?: CustomerTypeOrderByWithAggregationInput | CustomerTypeOrderByWithAggregationInput[]
    by: CustomerTypeScalarFieldEnum[] | CustomerTypeScalarFieldEnum
    having?: CustomerTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerTypeCountAggregateInputType | true
    _min?: CustomerTypeMinAggregateInputType
    _max?: CustomerTypeMaxAggregateInputType
  }

  export type CustomerTypeGroupByOutputType = {
    id: string
    name: string
    slug: string
    productId: string | null
    _count: CustomerTypeCountAggregateOutputType | null
    _min: CustomerTypeMinAggregateOutputType | null
    _max: CustomerTypeMaxAggregateOutputType | null
  }

  type GetCustomerTypeGroupByPayload<T extends CustomerTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerTypeGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerTypeGroupByOutputType[P]>
        }
      >
    >


  export type CustomerTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    productId?: boolean
    Product?: boolean | CustomerType$ProductArgs<ExtArgs>
    _count?: boolean | CustomerTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerType"]>



  export type CustomerTypeSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    productId?: boolean
  }

  export type CustomerTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "productId", ExtArgs["result"]["customerType"]>
  export type CustomerTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | CustomerType$ProductArgs<ExtArgs>
    _count?: boolean | CustomerTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerType"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      productId: string | null
    }, ExtArgs["result"]["customerType"]>
    composites: {}
  }

  type CustomerTypeGetPayload<S extends boolean | null | undefined | CustomerTypeDefaultArgs> = $Result.GetResult<Prisma.$CustomerTypePayload, S>

  type CustomerTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerTypeCountAggregateInputType | true
    }

  export interface CustomerTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerType'], meta: { name: 'CustomerType' } }
    /**
     * Find zero or one CustomerType that matches the filter.
     * @param {CustomerTypeFindUniqueArgs} args - Arguments to find a CustomerType
     * @example
     * // Get one CustomerType
     * const customerType = await prisma.customerType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerTypeFindUniqueArgs>(args: SelectSubset<T, CustomerTypeFindUniqueArgs<ExtArgs>>): Prisma__CustomerTypeClient<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerTypeFindUniqueOrThrowArgs} args - Arguments to find a CustomerType
     * @example
     * // Get one CustomerType
     * const customerType = await prisma.customerType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerTypeClient<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTypeFindFirstArgs} args - Arguments to find a CustomerType
     * @example
     * // Get one CustomerType
     * const customerType = await prisma.customerType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerTypeFindFirstArgs>(args?: SelectSubset<T, CustomerTypeFindFirstArgs<ExtArgs>>): Prisma__CustomerTypeClient<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTypeFindFirstOrThrowArgs} args - Arguments to find a CustomerType
     * @example
     * // Get one CustomerType
     * const customerType = await prisma.customerType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerTypeClient<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerTypes
     * const customerTypes = await prisma.customerType.findMany()
     * 
     * // Get first 10 CustomerTypes
     * const customerTypes = await prisma.customerType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerTypeWithIdOnly = await prisma.customerType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerTypeFindManyArgs>(args?: SelectSubset<T, CustomerTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerType.
     * @param {CustomerTypeCreateArgs} args - Arguments to create a CustomerType.
     * @example
     * // Create one CustomerType
     * const CustomerType = await prisma.customerType.create({
     *   data: {
     *     // ... data to create a CustomerType
     *   }
     * })
     * 
     */
    create<T extends CustomerTypeCreateArgs>(args: SelectSubset<T, CustomerTypeCreateArgs<ExtArgs>>): Prisma__CustomerTypeClient<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerTypes.
     * @param {CustomerTypeCreateManyArgs} args - Arguments to create many CustomerTypes.
     * @example
     * // Create many CustomerTypes
     * const customerType = await prisma.customerType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerTypeCreateManyArgs>(args?: SelectSubset<T, CustomerTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerType.
     * @param {CustomerTypeDeleteArgs} args - Arguments to delete one CustomerType.
     * @example
     * // Delete one CustomerType
     * const CustomerType = await prisma.customerType.delete({
     *   where: {
     *     // ... filter to delete one CustomerType
     *   }
     * })
     * 
     */
    delete<T extends CustomerTypeDeleteArgs>(args: SelectSubset<T, CustomerTypeDeleteArgs<ExtArgs>>): Prisma__CustomerTypeClient<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerType.
     * @param {CustomerTypeUpdateArgs} args - Arguments to update one CustomerType.
     * @example
     * // Update one CustomerType
     * const customerType = await prisma.customerType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerTypeUpdateArgs>(args: SelectSubset<T, CustomerTypeUpdateArgs<ExtArgs>>): Prisma__CustomerTypeClient<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerTypes.
     * @param {CustomerTypeDeleteManyArgs} args - Arguments to filter CustomerTypes to delete.
     * @example
     * // Delete a few CustomerTypes
     * const { count } = await prisma.customerType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerTypeDeleteManyArgs>(args?: SelectSubset<T, CustomerTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerTypes
     * const customerType = await prisma.customerType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerTypeUpdateManyArgs>(args: SelectSubset<T, CustomerTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerType.
     * @param {CustomerTypeUpsertArgs} args - Arguments to update or create a CustomerType.
     * @example
     * // Update or create a CustomerType
     * const customerType = await prisma.customerType.upsert({
     *   create: {
     *     // ... data to create a CustomerType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerType we want to update
     *   }
     * })
     */
    upsert<T extends CustomerTypeUpsertArgs>(args: SelectSubset<T, CustomerTypeUpsertArgs<ExtArgs>>): Prisma__CustomerTypeClient<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTypeCountArgs} args - Arguments to filter CustomerTypes to count.
     * @example
     * // Count the number of CustomerTypes
     * const count = await prisma.customerType.count({
     *   where: {
     *     // ... the filter for the CustomerTypes we want to count
     *   }
     * })
    **/
    count<T extends CustomerTypeCountArgs>(
      args?: Subset<T, CustomerTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerTypeAggregateArgs>(args: Subset<T, CustomerTypeAggregateArgs>): Prisma.PrismaPromise<GetCustomerTypeAggregateType<T>>

    /**
     * Group by CustomerType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerTypeGroupByArgs['orderBy'] }
        : { orderBy?: CustomerTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerType model
   */
  readonly fields: CustomerTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends CustomerType$ProductArgs<ExtArgs> = {}>(args?: Subset<T, CustomerType$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerType model
   */ 
  interface CustomerTypeFieldRefs {
    readonly id: FieldRef<"CustomerType", 'String'>
    readonly name: FieldRef<"CustomerType", 'String'>
    readonly slug: FieldRef<"CustomerType", 'String'>
    readonly productId: FieldRef<"CustomerType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CustomerType findUnique
   */
  export type CustomerTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    /**
     * Filter, which CustomerType to fetch.
     */
    where: CustomerTypeWhereUniqueInput
  }

  /**
   * CustomerType findUniqueOrThrow
   */
  export type CustomerTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    /**
     * Filter, which CustomerType to fetch.
     */
    where: CustomerTypeWhereUniqueInput
  }

  /**
   * CustomerType findFirst
   */
  export type CustomerTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    /**
     * Filter, which CustomerType to fetch.
     */
    where?: CustomerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTypes to fetch.
     */
    orderBy?: CustomerTypeOrderByWithRelationInput | CustomerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerTypes.
     */
    cursor?: CustomerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerTypes.
     */
    distinct?: CustomerTypeScalarFieldEnum | CustomerTypeScalarFieldEnum[]
  }

  /**
   * CustomerType findFirstOrThrow
   */
  export type CustomerTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    /**
     * Filter, which CustomerType to fetch.
     */
    where?: CustomerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTypes to fetch.
     */
    orderBy?: CustomerTypeOrderByWithRelationInput | CustomerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerTypes.
     */
    cursor?: CustomerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerTypes.
     */
    distinct?: CustomerTypeScalarFieldEnum | CustomerTypeScalarFieldEnum[]
  }

  /**
   * CustomerType findMany
   */
  export type CustomerTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTypes to fetch.
     */
    where?: CustomerTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTypes to fetch.
     */
    orderBy?: CustomerTypeOrderByWithRelationInput | CustomerTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerTypes.
     */
    cursor?: CustomerTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTypes.
     */
    skip?: number
    distinct?: CustomerTypeScalarFieldEnum | CustomerTypeScalarFieldEnum[]
  }

  /**
   * CustomerType create
   */
  export type CustomerTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerType.
     */
    data: XOR<CustomerTypeCreateInput, CustomerTypeUncheckedCreateInput>
  }

  /**
   * CustomerType createMany
   */
  export type CustomerTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerTypes.
     */
    data: CustomerTypeCreateManyInput | CustomerTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerType update
   */
  export type CustomerTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerType.
     */
    data: XOR<CustomerTypeUpdateInput, CustomerTypeUncheckedUpdateInput>
    /**
     * Choose, which CustomerType to update.
     */
    where: CustomerTypeWhereUniqueInput
  }

  /**
   * CustomerType updateMany
   */
  export type CustomerTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerTypes.
     */
    data: XOR<CustomerTypeUpdateManyMutationInput, CustomerTypeUncheckedUpdateManyInput>
    /**
     * Filter which CustomerTypes to update
     */
    where?: CustomerTypeWhereInput
    /**
     * Limit how many CustomerTypes to update.
     */
    limit?: number
  }

  /**
   * CustomerType upsert
   */
  export type CustomerTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerType to update in case it exists.
     */
    where: CustomerTypeWhereUniqueInput
    /**
     * In case the CustomerType found by the `where` argument doesn't exist, create a new CustomerType with this data.
     */
    create: XOR<CustomerTypeCreateInput, CustomerTypeUncheckedCreateInput>
    /**
     * In case the CustomerType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerTypeUpdateInput, CustomerTypeUncheckedUpdateInput>
  }

  /**
   * CustomerType delete
   */
  export type CustomerTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    /**
     * Filter which CustomerType to delete.
     */
    where: CustomerTypeWhereUniqueInput
  }

  /**
   * CustomerType deleteMany
   */
  export type CustomerTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerTypes to delete
     */
    where?: CustomerTypeWhereInput
    /**
     * Limit how many CustomerTypes to delete.
     */
    limit?: number
  }

  /**
   * CustomerType.Product
   */
  export type CustomerType$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * CustomerType without action
   */
  export type CustomerTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
  }


  /**
   * Model DeleteRequest
   */

  export type AggregateDeleteRequest = {
    _count: DeleteRequestCountAggregateOutputType | null
    _min: DeleteRequestMinAggregateOutputType | null
    _max: DeleteRequestMaxAggregateOutputType | null
  }

  export type DeleteRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userEmail: string | null
    reason: string | null
    status: $Enums.DeleteRequest_status | null
    createdAt: Date | null
  }

  export type DeleteRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userEmail: string | null
    reason: string | null
    status: $Enums.DeleteRequest_status | null
    createdAt: Date | null
  }

  export type DeleteRequestCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    userEmail: number
    reason: number
    status: number
    createdAt: number
    _all: number
  }


  export type DeleteRequestMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userEmail?: true
    reason?: true
    status?: true
    createdAt?: true
  }

  export type DeleteRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userEmail?: true
    reason?: true
    status?: true
    createdAt?: true
  }

  export type DeleteRequestCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userEmail?: true
    reason?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type DeleteRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeleteRequest to aggregate.
     */
    where?: DeleteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeleteRequests to fetch.
     */
    orderBy?: DeleteRequestOrderByWithRelationInput | DeleteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeleteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeleteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeleteRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeleteRequests
    **/
    _count?: true | DeleteRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeleteRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeleteRequestMaxAggregateInputType
  }

  export type GetDeleteRequestAggregateType<T extends DeleteRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDeleteRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeleteRequest[P]>
      : GetScalarType<T[P], AggregateDeleteRequest[P]>
  }




  export type DeleteRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeleteRequestWhereInput
    orderBy?: DeleteRequestOrderByWithAggregationInput | DeleteRequestOrderByWithAggregationInput[]
    by: DeleteRequestScalarFieldEnum[] | DeleteRequestScalarFieldEnum
    having?: DeleteRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeleteRequestCountAggregateInputType | true
    _min?: DeleteRequestMinAggregateInputType
    _max?: DeleteRequestMaxAggregateInputType
  }

  export type DeleteRequestGroupByOutputType = {
    id: string
    userId: string | null
    userName: string | null
    userEmail: string | null
    reason: string | null
    status: $Enums.DeleteRequest_status
    createdAt: Date
    _count: DeleteRequestCountAggregateOutputType | null
    _min: DeleteRequestMinAggregateOutputType | null
    _max: DeleteRequestMaxAggregateOutputType | null
  }

  type GetDeleteRequestGroupByPayload<T extends DeleteRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeleteRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeleteRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeleteRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DeleteRequestGroupByOutputType[P]>
        }
      >
    >


  export type DeleteRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    User?: boolean | DeleteRequest$UserArgs<ExtArgs>
  }, ExtArgs["result"]["deleteRequest"]>



  export type DeleteRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type DeleteRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userName" | "userEmail" | "reason" | "status" | "createdAt", ExtArgs["result"]["deleteRequest"]>
  export type DeleteRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | DeleteRequest$UserArgs<ExtArgs>
  }

  export type $DeleteRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeleteRequest"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      userName: string | null
      userEmail: string | null
      reason: string | null
      status: $Enums.DeleteRequest_status
      createdAt: Date
    }, ExtArgs["result"]["deleteRequest"]>
    composites: {}
  }

  type DeleteRequestGetPayload<S extends boolean | null | undefined | DeleteRequestDefaultArgs> = $Result.GetResult<Prisma.$DeleteRequestPayload, S>

  type DeleteRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeleteRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeleteRequestCountAggregateInputType | true
    }

  export interface DeleteRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeleteRequest'], meta: { name: 'DeleteRequest' } }
    /**
     * Find zero or one DeleteRequest that matches the filter.
     * @param {DeleteRequestFindUniqueArgs} args - Arguments to find a DeleteRequest
     * @example
     * // Get one DeleteRequest
     * const deleteRequest = await prisma.deleteRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeleteRequestFindUniqueArgs>(args: SelectSubset<T, DeleteRequestFindUniqueArgs<ExtArgs>>): Prisma__DeleteRequestClient<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeleteRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeleteRequestFindUniqueOrThrowArgs} args - Arguments to find a DeleteRequest
     * @example
     * // Get one DeleteRequest
     * const deleteRequest = await prisma.deleteRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeleteRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DeleteRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeleteRequestClient<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeleteRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleteRequestFindFirstArgs} args - Arguments to find a DeleteRequest
     * @example
     * // Get one DeleteRequest
     * const deleteRequest = await prisma.deleteRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeleteRequestFindFirstArgs>(args?: SelectSubset<T, DeleteRequestFindFirstArgs<ExtArgs>>): Prisma__DeleteRequestClient<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeleteRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleteRequestFindFirstOrThrowArgs} args - Arguments to find a DeleteRequest
     * @example
     * // Get one DeleteRequest
     * const deleteRequest = await prisma.deleteRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeleteRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DeleteRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeleteRequestClient<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeleteRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleteRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeleteRequests
     * const deleteRequests = await prisma.deleteRequest.findMany()
     * 
     * // Get first 10 DeleteRequests
     * const deleteRequests = await prisma.deleteRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deleteRequestWithIdOnly = await prisma.deleteRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeleteRequestFindManyArgs>(args?: SelectSubset<T, DeleteRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeleteRequest.
     * @param {DeleteRequestCreateArgs} args - Arguments to create a DeleteRequest.
     * @example
     * // Create one DeleteRequest
     * const DeleteRequest = await prisma.deleteRequest.create({
     *   data: {
     *     // ... data to create a DeleteRequest
     *   }
     * })
     * 
     */
    create<T extends DeleteRequestCreateArgs>(args: SelectSubset<T, DeleteRequestCreateArgs<ExtArgs>>): Prisma__DeleteRequestClient<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeleteRequests.
     * @param {DeleteRequestCreateManyArgs} args - Arguments to create many DeleteRequests.
     * @example
     * // Create many DeleteRequests
     * const deleteRequest = await prisma.deleteRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeleteRequestCreateManyArgs>(args?: SelectSubset<T, DeleteRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeleteRequest.
     * @param {DeleteRequestDeleteArgs} args - Arguments to delete one DeleteRequest.
     * @example
     * // Delete one DeleteRequest
     * const DeleteRequest = await prisma.deleteRequest.delete({
     *   where: {
     *     // ... filter to delete one DeleteRequest
     *   }
     * })
     * 
     */
    delete<T extends DeleteRequestDeleteArgs>(args: SelectSubset<T, DeleteRequestDeleteArgs<ExtArgs>>): Prisma__DeleteRequestClient<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeleteRequest.
     * @param {DeleteRequestUpdateArgs} args - Arguments to update one DeleteRequest.
     * @example
     * // Update one DeleteRequest
     * const deleteRequest = await prisma.deleteRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeleteRequestUpdateArgs>(args: SelectSubset<T, DeleteRequestUpdateArgs<ExtArgs>>): Prisma__DeleteRequestClient<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeleteRequests.
     * @param {DeleteRequestDeleteManyArgs} args - Arguments to filter DeleteRequests to delete.
     * @example
     * // Delete a few DeleteRequests
     * const { count } = await prisma.deleteRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeleteRequestDeleteManyArgs>(args?: SelectSubset<T, DeleteRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeleteRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleteRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeleteRequests
     * const deleteRequest = await prisma.deleteRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeleteRequestUpdateManyArgs>(args: SelectSubset<T, DeleteRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeleteRequest.
     * @param {DeleteRequestUpsertArgs} args - Arguments to update or create a DeleteRequest.
     * @example
     * // Update or create a DeleteRequest
     * const deleteRequest = await prisma.deleteRequest.upsert({
     *   create: {
     *     // ... data to create a DeleteRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeleteRequest we want to update
     *   }
     * })
     */
    upsert<T extends DeleteRequestUpsertArgs>(args: SelectSubset<T, DeleteRequestUpsertArgs<ExtArgs>>): Prisma__DeleteRequestClient<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeleteRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleteRequestCountArgs} args - Arguments to filter DeleteRequests to count.
     * @example
     * // Count the number of DeleteRequests
     * const count = await prisma.deleteRequest.count({
     *   where: {
     *     // ... the filter for the DeleteRequests we want to count
     *   }
     * })
    **/
    count<T extends DeleteRequestCountArgs>(
      args?: Subset<T, DeleteRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeleteRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeleteRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleteRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeleteRequestAggregateArgs>(args: Subset<T, DeleteRequestAggregateArgs>): Prisma.PrismaPromise<GetDeleteRequestAggregateType<T>>

    /**
     * Group by DeleteRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleteRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeleteRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeleteRequestGroupByArgs['orderBy'] }
        : { orderBy?: DeleteRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeleteRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeleteRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeleteRequest model
   */
  readonly fields: DeleteRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeleteRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeleteRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends DeleteRequest$UserArgs<ExtArgs> = {}>(args?: Subset<T, DeleteRequest$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeleteRequest model
   */ 
  interface DeleteRequestFieldRefs {
    readonly id: FieldRef<"DeleteRequest", 'String'>
    readonly userId: FieldRef<"DeleteRequest", 'String'>
    readonly userName: FieldRef<"DeleteRequest", 'String'>
    readonly userEmail: FieldRef<"DeleteRequest", 'String'>
    readonly reason: FieldRef<"DeleteRequest", 'String'>
    readonly status: FieldRef<"DeleteRequest", 'DeleteRequest_status'>
    readonly createdAt: FieldRef<"DeleteRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeleteRequest findUnique
   */
  export type DeleteRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeleteRequest to fetch.
     */
    where: DeleteRequestWhereUniqueInput
  }

  /**
   * DeleteRequest findUniqueOrThrow
   */
  export type DeleteRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeleteRequest to fetch.
     */
    where: DeleteRequestWhereUniqueInput
  }

  /**
   * DeleteRequest findFirst
   */
  export type DeleteRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeleteRequest to fetch.
     */
    where?: DeleteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeleteRequests to fetch.
     */
    orderBy?: DeleteRequestOrderByWithRelationInput | DeleteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeleteRequests.
     */
    cursor?: DeleteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeleteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeleteRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeleteRequests.
     */
    distinct?: DeleteRequestScalarFieldEnum | DeleteRequestScalarFieldEnum[]
  }

  /**
   * DeleteRequest findFirstOrThrow
   */
  export type DeleteRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeleteRequest to fetch.
     */
    where?: DeleteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeleteRequests to fetch.
     */
    orderBy?: DeleteRequestOrderByWithRelationInput | DeleteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeleteRequests.
     */
    cursor?: DeleteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeleteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeleteRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeleteRequests.
     */
    distinct?: DeleteRequestScalarFieldEnum | DeleteRequestScalarFieldEnum[]
  }

  /**
   * DeleteRequest findMany
   */
  export type DeleteRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    /**
     * Filter, which DeleteRequests to fetch.
     */
    where?: DeleteRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeleteRequests to fetch.
     */
    orderBy?: DeleteRequestOrderByWithRelationInput | DeleteRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeleteRequests.
     */
    cursor?: DeleteRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeleteRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeleteRequests.
     */
    skip?: number
    distinct?: DeleteRequestScalarFieldEnum | DeleteRequestScalarFieldEnum[]
  }

  /**
   * DeleteRequest create
   */
  export type DeleteRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DeleteRequest.
     */
    data: XOR<DeleteRequestCreateInput, DeleteRequestUncheckedCreateInput>
  }

  /**
   * DeleteRequest createMany
   */
  export type DeleteRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeleteRequests.
     */
    data: DeleteRequestCreateManyInput | DeleteRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeleteRequest update
   */
  export type DeleteRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DeleteRequest.
     */
    data: XOR<DeleteRequestUpdateInput, DeleteRequestUncheckedUpdateInput>
    /**
     * Choose, which DeleteRequest to update.
     */
    where: DeleteRequestWhereUniqueInput
  }

  /**
   * DeleteRequest updateMany
   */
  export type DeleteRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeleteRequests.
     */
    data: XOR<DeleteRequestUpdateManyMutationInput, DeleteRequestUncheckedUpdateManyInput>
    /**
     * Filter which DeleteRequests to update
     */
    where?: DeleteRequestWhereInput
    /**
     * Limit how many DeleteRequests to update.
     */
    limit?: number
  }

  /**
   * DeleteRequest upsert
   */
  export type DeleteRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DeleteRequest to update in case it exists.
     */
    where: DeleteRequestWhereUniqueInput
    /**
     * In case the DeleteRequest found by the `where` argument doesn't exist, create a new DeleteRequest with this data.
     */
    create: XOR<DeleteRequestCreateInput, DeleteRequestUncheckedCreateInput>
    /**
     * In case the DeleteRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeleteRequestUpdateInput, DeleteRequestUncheckedUpdateInput>
  }

  /**
   * DeleteRequest delete
   */
  export type DeleteRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    /**
     * Filter which DeleteRequest to delete.
     */
    where: DeleteRequestWhereUniqueInput
  }

  /**
   * DeleteRequest deleteMany
   */
  export type DeleteRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeleteRequests to delete
     */
    where?: DeleteRequestWhereInput
    /**
     * Limit how many DeleteRequests to delete.
     */
    limit?: number
  }

  /**
   * DeleteRequest.User
   */
  export type DeleteRequest$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DeleteRequest without action
   */
  export type DeleteRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
  }


  /**
   * Model Discount
   */

  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    amount: number | null
    maxPrice: number | null
    minPrice: number | null
    orders: number | null
  }

  export type DiscountSumAggregateOutputType = {
    amount: number | null
    maxPrice: number | null
    minPrice: number | null
    orders: number | null
  }

  export type DiscountMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    amount: number | null
    type: $Enums.Discount_type | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
    maxPrice: number | null
    minPrice: number | null
    isActive: boolean | null
    isSpecial: boolean | null
    orders: number | null
    isWebAvailable: boolean | null
    isCODAvailable: boolean | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    amount: number | null
    type: $Enums.Discount_type | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
    maxPrice: number | null
    minPrice: number | null
    isActive: boolean | null
    isSpecial: boolean | null
    orders: number | null
    isWebAvailable: boolean | null
    isCODAvailable: boolean | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    code: number
    description: number
    amount: number
    type: number
    createdAt: number
    updatedAt: number
    productId: number
    maxPrice: number
    minPrice: number
    isActive: number
    isSpecial: number
    orders: number
    userEmails: number
    isWebAvailable: number
    isCODAvailable: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    amount?: true
    maxPrice?: true
    minPrice?: true
    orders?: true
  }

  export type DiscountSumAggregateInputType = {
    amount?: true
    maxPrice?: true
    minPrice?: true
    orders?: true
  }

  export type DiscountMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    amount?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    maxPrice?: true
    minPrice?: true
    isActive?: true
    isSpecial?: true
    orders?: true
    isWebAvailable?: true
    isCODAvailable?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    amount?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    maxPrice?: true
    minPrice?: true
    isActive?: true
    isSpecial?: true
    orders?: true
    isWebAvailable?: true
    isCODAvailable?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    amount?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    maxPrice?: true
    minPrice?: true
    isActive?: true
    isSpecial?: true
    orders?: true
    userEmails?: true
    isWebAvailable?: true
    isCODAvailable?: true
    _all?: true
  }

  export type DiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discount to aggregate.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithAggregationInput | DiscountOrderByWithAggregationInput[]
    by: DiscountScalarFieldEnum[] | DiscountScalarFieldEnum
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }

  export type DiscountGroupByOutputType = {
    id: string
    code: string
    description: string | null
    amount: number
    type: $Enums.Discount_type
    createdAt: Date
    updatedAt: Date
    productId: string | null
    maxPrice: number | null
    minPrice: number | null
    isActive: boolean
    isSpecial: boolean
    orders: number | null
    userEmails: JsonValue
    isWebAvailable: boolean
    isCODAvailable: boolean
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    maxPrice?: boolean
    minPrice?: boolean
    isActive?: boolean
    isSpecial?: boolean
    orders?: boolean
    userEmails?: boolean
    isWebAvailable?: boolean
    isCODAvailable?: boolean
    Product?: boolean | Discount$ProductArgs<ExtArgs>
    OrderDetails?: boolean | Discount$OrderDetailsArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>



  export type DiscountSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    maxPrice?: boolean
    minPrice?: boolean
    isActive?: boolean
    isSpecial?: boolean
    orders?: boolean
    userEmails?: boolean
    isWebAvailable?: boolean
    isCODAvailable?: boolean
  }

  export type DiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "amount" | "type" | "createdAt" | "updatedAt" | "productId" | "maxPrice" | "minPrice" | "isActive" | "isSpecial" | "orders" | "userEmails" | "isWebAvailable" | "isCODAvailable", ExtArgs["result"]["discount"]>
  export type DiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | Discount$ProductArgs<ExtArgs>
    OrderDetails?: boolean | Discount$OrderDetailsArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discount"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs> | null
      OrderDetails: Prisma.$OrderDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      amount: number
      type: $Enums.Discount_type
      createdAt: Date
      updatedAt: Date
      productId: string | null
      maxPrice: number | null
      minPrice: number | null
      isActive: boolean
      isSpecial: boolean
      orders: number | null
      userEmails: Prisma.JsonValue
      isWebAvailable: boolean
      isCODAvailable: boolean
    }, ExtArgs["result"]["discount"]>
    composites: {}
  }

  type DiscountGetPayload<S extends boolean | null | undefined | DiscountDefaultArgs> = $Result.GetResult<Prisma.$DiscountPayload, S>

  type DiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountCountAggregateInputType | true
    }

  export interface DiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discount'], meta: { name: 'Discount' } }
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountFindUniqueArgs>(args: SelectSubset<T, DiscountFindUniqueArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountFindUniqueOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountFindFirstArgs>(args?: SelectSubset<T, DiscountFindFirstArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountFindManyArgs>(args?: SelectSubset<T, DiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
     */
    create<T extends DiscountCreateArgs>(args: SelectSubset<T, DiscountCreateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discounts.
     * @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountCreateManyArgs>(args?: SelectSubset<T, DiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
     */
    delete<T extends DiscountDeleteArgs>(args: SelectSubset<T, DiscountDeleteArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountUpdateArgs>(args: SelectSubset<T, DiscountUpdateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountDeleteManyArgs>(args?: SelectSubset<T, DiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountUpdateManyArgs>(args: SelectSubset<T, DiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
     */
    upsert<T extends DiscountUpsertArgs>(args: SelectSubset<T, DiscountUpsertArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): Prisma.PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discount model
   */
  readonly fields: DiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends Discount$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Discount$ProductArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    OrderDetails<T extends Discount$OrderDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Discount$OrderDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discount model
   */ 
  interface DiscountFieldRefs {
    readonly id: FieldRef<"Discount", 'String'>
    readonly code: FieldRef<"Discount", 'String'>
    readonly description: FieldRef<"Discount", 'String'>
    readonly amount: FieldRef<"Discount", 'Float'>
    readonly type: FieldRef<"Discount", 'Discount_type'>
    readonly createdAt: FieldRef<"Discount", 'DateTime'>
    readonly updatedAt: FieldRef<"Discount", 'DateTime'>
    readonly productId: FieldRef<"Discount", 'String'>
    readonly maxPrice: FieldRef<"Discount", 'Float'>
    readonly minPrice: FieldRef<"Discount", 'Float'>
    readonly isActive: FieldRef<"Discount", 'Boolean'>
    readonly isSpecial: FieldRef<"Discount", 'Boolean'>
    readonly orders: FieldRef<"Discount", 'Int'>
    readonly userEmails: FieldRef<"Discount", 'Json'>
    readonly isWebAvailable: FieldRef<"Discount", 'Boolean'>
    readonly isCODAvailable: FieldRef<"Discount", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findUniqueOrThrow
   */
  export type DiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findFirstOrThrow
   */
  export type DiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discounts to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount create
   */
  export type DiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a Discount.
     */
    data: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }

  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discount update
   */
  export type DiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a Discount.
     */
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the Discount to update in case it exists.
     */
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     */
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }

  /**
   * Discount delete
   */
  export type DiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter which Discount to delete.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discounts to delete
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to delete.
     */
    limit?: number
  }

  /**
   * Discount.Product
   */
  export type Discount$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Discount.OrderDetails
   */
  export type Discount$OrderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    where?: OrderDetailsWhereInput
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    cursor?: OrderDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * Discount without action
   */
  export type DiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
  }


  /**
   * Model DropMessage
   */

  export type AggregateDropMessage = {
    _count: DropMessageCountAggregateOutputType | null
    _min: DropMessageMinAggregateOutputType | null
    _max: DropMessageMaxAggregateOutputType | null
  }

  export type DropMessageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
  }

  export type DropMessageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
  }

  export type DropMessageCountAggregateOutputType = {
    id: number
    userId: number
    startedAt: number
    endedAt: number
    createdAt: number
    _all: number
  }


  export type DropMessageMinAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
  }

  export type DropMessageMaxAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
  }

  export type DropMessageCountAggregateInputType = {
    id?: true
    userId?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    _all?: true
  }

  export type DropMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropMessage to aggregate.
     */
    where?: DropMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropMessages to fetch.
     */
    orderBy?: DropMessageOrderByWithRelationInput | DropMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DropMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DropMessages
    **/
    _count?: true | DropMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DropMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DropMessageMaxAggregateInputType
  }

  export type GetDropMessageAggregateType<T extends DropMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDropMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDropMessage[P]>
      : GetScalarType<T[P], AggregateDropMessage[P]>
  }




  export type DropMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DropMessageWhereInput
    orderBy?: DropMessageOrderByWithAggregationInput | DropMessageOrderByWithAggregationInput[]
    by: DropMessageScalarFieldEnum[] | DropMessageScalarFieldEnum
    having?: DropMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DropMessageCountAggregateInputType | true
    _min?: DropMessageMinAggregateInputType
    _max?: DropMessageMaxAggregateInputType
  }

  export type DropMessageGroupByOutputType = {
    id: string
    userId: string
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date
    _count: DropMessageCountAggregateOutputType | null
    _min: DropMessageMinAggregateOutputType | null
    _max: DropMessageMaxAggregateOutputType | null
  }

  type GetDropMessageGroupByPayload<T extends DropMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DropMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DropMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DropMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DropMessageGroupByOutputType[P]>
        }
      >
    >


  export type DropMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dropMessage"]>



  export type DropMessageSelectScalar = {
    id?: boolean
    userId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
  }

  export type DropMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startedAt" | "endedAt" | "createdAt", ExtArgs["result"]["dropMessage"]>
  export type DropMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DropMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DropMessage"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      startedAt: Date | null
      endedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["dropMessage"]>
    composites: {}
  }

  type DropMessageGetPayload<S extends boolean | null | undefined | DropMessageDefaultArgs> = $Result.GetResult<Prisma.$DropMessagePayload, S>

  type DropMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DropMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DropMessageCountAggregateInputType | true
    }

  export interface DropMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DropMessage'], meta: { name: 'DropMessage' } }
    /**
     * Find zero or one DropMessage that matches the filter.
     * @param {DropMessageFindUniqueArgs} args - Arguments to find a DropMessage
     * @example
     * // Get one DropMessage
     * const dropMessage = await prisma.dropMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DropMessageFindUniqueArgs>(args: SelectSubset<T, DropMessageFindUniqueArgs<ExtArgs>>): Prisma__DropMessageClient<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DropMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DropMessageFindUniqueOrThrowArgs} args - Arguments to find a DropMessage
     * @example
     * // Get one DropMessage
     * const dropMessage = await prisma.dropMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DropMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DropMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DropMessageClient<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DropMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropMessageFindFirstArgs} args - Arguments to find a DropMessage
     * @example
     * // Get one DropMessage
     * const dropMessage = await prisma.dropMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DropMessageFindFirstArgs>(args?: SelectSubset<T, DropMessageFindFirstArgs<ExtArgs>>): Prisma__DropMessageClient<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DropMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropMessageFindFirstOrThrowArgs} args - Arguments to find a DropMessage
     * @example
     * // Get one DropMessage
     * const dropMessage = await prisma.dropMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DropMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DropMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DropMessageClient<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DropMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DropMessages
     * const dropMessages = await prisma.dropMessage.findMany()
     * 
     * // Get first 10 DropMessages
     * const dropMessages = await prisma.dropMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dropMessageWithIdOnly = await prisma.dropMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DropMessageFindManyArgs>(args?: SelectSubset<T, DropMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DropMessage.
     * @param {DropMessageCreateArgs} args - Arguments to create a DropMessage.
     * @example
     * // Create one DropMessage
     * const DropMessage = await prisma.dropMessage.create({
     *   data: {
     *     // ... data to create a DropMessage
     *   }
     * })
     * 
     */
    create<T extends DropMessageCreateArgs>(args: SelectSubset<T, DropMessageCreateArgs<ExtArgs>>): Prisma__DropMessageClient<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DropMessages.
     * @param {DropMessageCreateManyArgs} args - Arguments to create many DropMessages.
     * @example
     * // Create many DropMessages
     * const dropMessage = await prisma.dropMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DropMessageCreateManyArgs>(args?: SelectSubset<T, DropMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DropMessage.
     * @param {DropMessageDeleteArgs} args - Arguments to delete one DropMessage.
     * @example
     * // Delete one DropMessage
     * const DropMessage = await prisma.dropMessage.delete({
     *   where: {
     *     // ... filter to delete one DropMessage
     *   }
     * })
     * 
     */
    delete<T extends DropMessageDeleteArgs>(args: SelectSubset<T, DropMessageDeleteArgs<ExtArgs>>): Prisma__DropMessageClient<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DropMessage.
     * @param {DropMessageUpdateArgs} args - Arguments to update one DropMessage.
     * @example
     * // Update one DropMessage
     * const dropMessage = await prisma.dropMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DropMessageUpdateArgs>(args: SelectSubset<T, DropMessageUpdateArgs<ExtArgs>>): Prisma__DropMessageClient<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DropMessages.
     * @param {DropMessageDeleteManyArgs} args - Arguments to filter DropMessages to delete.
     * @example
     * // Delete a few DropMessages
     * const { count } = await prisma.dropMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DropMessageDeleteManyArgs>(args?: SelectSubset<T, DropMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DropMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DropMessages
     * const dropMessage = await prisma.dropMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DropMessageUpdateManyArgs>(args: SelectSubset<T, DropMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DropMessage.
     * @param {DropMessageUpsertArgs} args - Arguments to update or create a DropMessage.
     * @example
     * // Update or create a DropMessage
     * const dropMessage = await prisma.dropMessage.upsert({
     *   create: {
     *     // ... data to create a DropMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DropMessage we want to update
     *   }
     * })
     */
    upsert<T extends DropMessageUpsertArgs>(args: SelectSubset<T, DropMessageUpsertArgs<ExtArgs>>): Prisma__DropMessageClient<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DropMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropMessageCountArgs} args - Arguments to filter DropMessages to count.
     * @example
     * // Count the number of DropMessages
     * const count = await prisma.dropMessage.count({
     *   where: {
     *     // ... the filter for the DropMessages we want to count
     *   }
     * })
    **/
    count<T extends DropMessageCountArgs>(
      args?: Subset<T, DropMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DropMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DropMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DropMessageAggregateArgs>(args: Subset<T, DropMessageAggregateArgs>): Prisma.PrismaPromise<GetDropMessageAggregateType<T>>

    /**
     * Group by DropMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DropMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DropMessageGroupByArgs['orderBy'] }
        : { orderBy?: DropMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DropMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDropMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DropMessage model
   */
  readonly fields: DropMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DropMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DropMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DropMessage model
   */ 
  interface DropMessageFieldRefs {
    readonly id: FieldRef<"DropMessage", 'String'>
    readonly userId: FieldRef<"DropMessage", 'String'>
    readonly startedAt: FieldRef<"DropMessage", 'DateTime'>
    readonly endedAt: FieldRef<"DropMessage", 'DateTime'>
    readonly createdAt: FieldRef<"DropMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DropMessage findUnique
   */
  export type DropMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    /**
     * Filter, which DropMessage to fetch.
     */
    where: DropMessageWhereUniqueInput
  }

  /**
   * DropMessage findUniqueOrThrow
   */
  export type DropMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    /**
     * Filter, which DropMessage to fetch.
     */
    where: DropMessageWhereUniqueInput
  }

  /**
   * DropMessage findFirst
   */
  export type DropMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    /**
     * Filter, which DropMessage to fetch.
     */
    where?: DropMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropMessages to fetch.
     */
    orderBy?: DropMessageOrderByWithRelationInput | DropMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropMessages.
     */
    cursor?: DropMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropMessages.
     */
    distinct?: DropMessageScalarFieldEnum | DropMessageScalarFieldEnum[]
  }

  /**
   * DropMessage findFirstOrThrow
   */
  export type DropMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    /**
     * Filter, which DropMessage to fetch.
     */
    where?: DropMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropMessages to fetch.
     */
    orderBy?: DropMessageOrderByWithRelationInput | DropMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropMessages.
     */
    cursor?: DropMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropMessages.
     */
    distinct?: DropMessageScalarFieldEnum | DropMessageScalarFieldEnum[]
  }

  /**
   * DropMessage findMany
   */
  export type DropMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    /**
     * Filter, which DropMessages to fetch.
     */
    where?: DropMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropMessages to fetch.
     */
    orderBy?: DropMessageOrderByWithRelationInput | DropMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DropMessages.
     */
    cursor?: DropMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropMessages.
     */
    skip?: number
    distinct?: DropMessageScalarFieldEnum | DropMessageScalarFieldEnum[]
  }

  /**
   * DropMessage create
   */
  export type DropMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a DropMessage.
     */
    data: XOR<DropMessageCreateInput, DropMessageUncheckedCreateInput>
  }

  /**
   * DropMessage createMany
   */
  export type DropMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DropMessages.
     */
    data: DropMessageCreateManyInput | DropMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DropMessage update
   */
  export type DropMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a DropMessage.
     */
    data: XOR<DropMessageUpdateInput, DropMessageUncheckedUpdateInput>
    /**
     * Choose, which DropMessage to update.
     */
    where: DropMessageWhereUniqueInput
  }

  /**
   * DropMessage updateMany
   */
  export type DropMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DropMessages.
     */
    data: XOR<DropMessageUpdateManyMutationInput, DropMessageUncheckedUpdateManyInput>
    /**
     * Filter which DropMessages to update
     */
    where?: DropMessageWhereInput
    /**
     * Limit how many DropMessages to update.
     */
    limit?: number
  }

  /**
   * DropMessage upsert
   */
  export type DropMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the DropMessage to update in case it exists.
     */
    where: DropMessageWhereUniqueInput
    /**
     * In case the DropMessage found by the `where` argument doesn't exist, create a new DropMessage with this data.
     */
    create: XOR<DropMessageCreateInput, DropMessageUncheckedCreateInput>
    /**
     * In case the DropMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DropMessageUpdateInput, DropMessageUncheckedUpdateInput>
  }

  /**
   * DropMessage delete
   */
  export type DropMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    /**
     * Filter which DropMessage to delete.
     */
    where: DropMessageWhereUniqueInput
  }

  /**
   * DropMessage deleteMany
   */
  export type DropMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropMessages to delete
     */
    where?: DropMessageWhereInput
    /**
     * Limit how many DropMessages to delete.
     */
    limit?: number
  }

  /**
   * DropMessage without action
   */
  export type DropMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
  }


  /**
   * Model ExclusiveCollection
   */

  export type AggregateExclusiveCollection = {
    _count: ExclusiveCollectionCountAggregateOutputType | null
    _avg: ExclusiveCollectionAvgAggregateOutputType | null
    _sum: ExclusiveCollectionSumAggregateOutputType | null
    _min: ExclusiveCollectionMinAggregateOutputType | null
    _max: ExclusiveCollectionMaxAggregateOutputType | null
  }

  export type ExclusiveCollectionAvgAggregateOutputType = {
    mrp: number | null
    price: number | null
  }

  export type ExclusiveCollectionSumAggregateOutputType = {
    mrp: number | null
    price: number | null
  }

  export type ExclusiveCollectionMinAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
    categoryHyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mrp: number | null
    price: number | null
  }

  export type ExclusiveCollectionMaxAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
    categoryHyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mrp: number | null
    price: number | null
  }

  export type ExclusiveCollectionCountAggregateOutputType = {
    id: number
    imageUrl: number
    hyperLink: number
    categoryHyperLink: number
    createdAt: number
    updatedAt: number
    mrp: number
    price: number
    _all: number
  }


  export type ExclusiveCollectionAvgAggregateInputType = {
    mrp?: true
    price?: true
  }

  export type ExclusiveCollectionSumAggregateInputType = {
    mrp?: true
    price?: true
  }

  export type ExclusiveCollectionMinAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    categoryHyperLink?: true
    createdAt?: true
    updatedAt?: true
    mrp?: true
    price?: true
  }

  export type ExclusiveCollectionMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    categoryHyperLink?: true
    createdAt?: true
    updatedAt?: true
    mrp?: true
    price?: true
  }

  export type ExclusiveCollectionCountAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    categoryHyperLink?: true
    createdAt?: true
    updatedAt?: true
    mrp?: true
    price?: true
    _all?: true
  }

  export type ExclusiveCollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExclusiveCollection to aggregate.
     */
    where?: ExclusiveCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExclusiveCollections to fetch.
     */
    orderBy?: ExclusiveCollectionOrderByWithRelationInput | ExclusiveCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExclusiveCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExclusiveCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExclusiveCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExclusiveCollections
    **/
    _count?: true | ExclusiveCollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExclusiveCollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExclusiveCollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExclusiveCollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExclusiveCollectionMaxAggregateInputType
  }

  export type GetExclusiveCollectionAggregateType<T extends ExclusiveCollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateExclusiveCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExclusiveCollection[P]>
      : GetScalarType<T[P], AggregateExclusiveCollection[P]>
  }




  export type ExclusiveCollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExclusiveCollectionWhereInput
    orderBy?: ExclusiveCollectionOrderByWithAggregationInput | ExclusiveCollectionOrderByWithAggregationInput[]
    by: ExclusiveCollectionScalarFieldEnum[] | ExclusiveCollectionScalarFieldEnum
    having?: ExclusiveCollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExclusiveCollectionCountAggregateInputType | true
    _avg?: ExclusiveCollectionAvgAggregateInputType
    _sum?: ExclusiveCollectionSumAggregateInputType
    _min?: ExclusiveCollectionMinAggregateInputType
    _max?: ExclusiveCollectionMaxAggregateInputType
  }

  export type ExclusiveCollectionGroupByOutputType = {
    id: string
    imageUrl: string | null
    hyperLink: string | null
    categoryHyperLink: string | null
    createdAt: Date
    updatedAt: Date
    mrp: number | null
    price: number | null
    _count: ExclusiveCollectionCountAggregateOutputType | null
    _avg: ExclusiveCollectionAvgAggregateOutputType | null
    _sum: ExclusiveCollectionSumAggregateOutputType | null
    _min: ExclusiveCollectionMinAggregateOutputType | null
    _max: ExclusiveCollectionMaxAggregateOutputType | null
  }

  type GetExclusiveCollectionGroupByPayload<T extends ExclusiveCollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExclusiveCollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExclusiveCollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExclusiveCollectionGroupByOutputType[P]>
            : GetScalarType<T[P], ExclusiveCollectionGroupByOutputType[P]>
        }
      >
    >


  export type ExclusiveCollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    categoryHyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mrp?: boolean
    price?: boolean
  }, ExtArgs["result"]["exclusiveCollection"]>



  export type ExclusiveCollectionSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    categoryHyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mrp?: boolean
    price?: boolean
  }

  export type ExclusiveCollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "imageUrl" | "hyperLink" | "categoryHyperLink" | "createdAt" | "updatedAt" | "mrp" | "price", ExtArgs["result"]["exclusiveCollection"]>

  export type $ExclusiveCollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExclusiveCollection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imageUrl: string | null
      hyperLink: string | null
      categoryHyperLink: string | null
      createdAt: Date
      updatedAt: Date
      mrp: number | null
      price: number | null
    }, ExtArgs["result"]["exclusiveCollection"]>
    composites: {}
  }

  type ExclusiveCollectionGetPayload<S extends boolean | null | undefined | ExclusiveCollectionDefaultArgs> = $Result.GetResult<Prisma.$ExclusiveCollectionPayload, S>

  type ExclusiveCollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExclusiveCollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExclusiveCollectionCountAggregateInputType | true
    }

  export interface ExclusiveCollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExclusiveCollection'], meta: { name: 'ExclusiveCollection' } }
    /**
     * Find zero or one ExclusiveCollection that matches the filter.
     * @param {ExclusiveCollectionFindUniqueArgs} args - Arguments to find a ExclusiveCollection
     * @example
     * // Get one ExclusiveCollection
     * const exclusiveCollection = await prisma.exclusiveCollection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExclusiveCollectionFindUniqueArgs>(args: SelectSubset<T, ExclusiveCollectionFindUniqueArgs<ExtArgs>>): Prisma__ExclusiveCollectionClient<$Result.GetResult<Prisma.$ExclusiveCollectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExclusiveCollection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExclusiveCollectionFindUniqueOrThrowArgs} args - Arguments to find a ExclusiveCollection
     * @example
     * // Get one ExclusiveCollection
     * const exclusiveCollection = await prisma.exclusiveCollection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExclusiveCollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExclusiveCollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExclusiveCollectionClient<$Result.GetResult<Prisma.$ExclusiveCollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExclusiveCollection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExclusiveCollectionFindFirstArgs} args - Arguments to find a ExclusiveCollection
     * @example
     * // Get one ExclusiveCollection
     * const exclusiveCollection = await prisma.exclusiveCollection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExclusiveCollectionFindFirstArgs>(args?: SelectSubset<T, ExclusiveCollectionFindFirstArgs<ExtArgs>>): Prisma__ExclusiveCollectionClient<$Result.GetResult<Prisma.$ExclusiveCollectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExclusiveCollection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExclusiveCollectionFindFirstOrThrowArgs} args - Arguments to find a ExclusiveCollection
     * @example
     * // Get one ExclusiveCollection
     * const exclusiveCollection = await prisma.exclusiveCollection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExclusiveCollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExclusiveCollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExclusiveCollectionClient<$Result.GetResult<Prisma.$ExclusiveCollectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExclusiveCollections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExclusiveCollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExclusiveCollections
     * const exclusiveCollections = await prisma.exclusiveCollection.findMany()
     * 
     * // Get first 10 ExclusiveCollections
     * const exclusiveCollections = await prisma.exclusiveCollection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exclusiveCollectionWithIdOnly = await prisma.exclusiveCollection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExclusiveCollectionFindManyArgs>(args?: SelectSubset<T, ExclusiveCollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExclusiveCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExclusiveCollection.
     * @param {ExclusiveCollectionCreateArgs} args - Arguments to create a ExclusiveCollection.
     * @example
     * // Create one ExclusiveCollection
     * const ExclusiveCollection = await prisma.exclusiveCollection.create({
     *   data: {
     *     // ... data to create a ExclusiveCollection
     *   }
     * })
     * 
     */
    create<T extends ExclusiveCollectionCreateArgs>(args: SelectSubset<T, ExclusiveCollectionCreateArgs<ExtArgs>>): Prisma__ExclusiveCollectionClient<$Result.GetResult<Prisma.$ExclusiveCollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExclusiveCollections.
     * @param {ExclusiveCollectionCreateManyArgs} args - Arguments to create many ExclusiveCollections.
     * @example
     * // Create many ExclusiveCollections
     * const exclusiveCollection = await prisma.exclusiveCollection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExclusiveCollectionCreateManyArgs>(args?: SelectSubset<T, ExclusiveCollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExclusiveCollection.
     * @param {ExclusiveCollectionDeleteArgs} args - Arguments to delete one ExclusiveCollection.
     * @example
     * // Delete one ExclusiveCollection
     * const ExclusiveCollection = await prisma.exclusiveCollection.delete({
     *   where: {
     *     // ... filter to delete one ExclusiveCollection
     *   }
     * })
     * 
     */
    delete<T extends ExclusiveCollectionDeleteArgs>(args: SelectSubset<T, ExclusiveCollectionDeleteArgs<ExtArgs>>): Prisma__ExclusiveCollectionClient<$Result.GetResult<Prisma.$ExclusiveCollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExclusiveCollection.
     * @param {ExclusiveCollectionUpdateArgs} args - Arguments to update one ExclusiveCollection.
     * @example
     * // Update one ExclusiveCollection
     * const exclusiveCollection = await prisma.exclusiveCollection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExclusiveCollectionUpdateArgs>(args: SelectSubset<T, ExclusiveCollectionUpdateArgs<ExtArgs>>): Prisma__ExclusiveCollectionClient<$Result.GetResult<Prisma.$ExclusiveCollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExclusiveCollections.
     * @param {ExclusiveCollectionDeleteManyArgs} args - Arguments to filter ExclusiveCollections to delete.
     * @example
     * // Delete a few ExclusiveCollections
     * const { count } = await prisma.exclusiveCollection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExclusiveCollectionDeleteManyArgs>(args?: SelectSubset<T, ExclusiveCollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExclusiveCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExclusiveCollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExclusiveCollections
     * const exclusiveCollection = await prisma.exclusiveCollection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExclusiveCollectionUpdateManyArgs>(args: SelectSubset<T, ExclusiveCollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExclusiveCollection.
     * @param {ExclusiveCollectionUpsertArgs} args - Arguments to update or create a ExclusiveCollection.
     * @example
     * // Update or create a ExclusiveCollection
     * const exclusiveCollection = await prisma.exclusiveCollection.upsert({
     *   create: {
     *     // ... data to create a ExclusiveCollection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExclusiveCollection we want to update
     *   }
     * })
     */
    upsert<T extends ExclusiveCollectionUpsertArgs>(args: SelectSubset<T, ExclusiveCollectionUpsertArgs<ExtArgs>>): Prisma__ExclusiveCollectionClient<$Result.GetResult<Prisma.$ExclusiveCollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExclusiveCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExclusiveCollectionCountArgs} args - Arguments to filter ExclusiveCollections to count.
     * @example
     * // Count the number of ExclusiveCollections
     * const count = await prisma.exclusiveCollection.count({
     *   where: {
     *     // ... the filter for the ExclusiveCollections we want to count
     *   }
     * })
    **/
    count<T extends ExclusiveCollectionCountArgs>(
      args?: Subset<T, ExclusiveCollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExclusiveCollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExclusiveCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExclusiveCollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExclusiveCollectionAggregateArgs>(args: Subset<T, ExclusiveCollectionAggregateArgs>): Prisma.PrismaPromise<GetExclusiveCollectionAggregateType<T>>

    /**
     * Group by ExclusiveCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExclusiveCollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExclusiveCollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExclusiveCollectionGroupByArgs['orderBy'] }
        : { orderBy?: ExclusiveCollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExclusiveCollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExclusiveCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExclusiveCollection model
   */
  readonly fields: ExclusiveCollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExclusiveCollection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExclusiveCollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExclusiveCollection model
   */ 
  interface ExclusiveCollectionFieldRefs {
    readonly id: FieldRef<"ExclusiveCollection", 'String'>
    readonly imageUrl: FieldRef<"ExclusiveCollection", 'String'>
    readonly hyperLink: FieldRef<"ExclusiveCollection", 'String'>
    readonly categoryHyperLink: FieldRef<"ExclusiveCollection", 'String'>
    readonly createdAt: FieldRef<"ExclusiveCollection", 'DateTime'>
    readonly updatedAt: FieldRef<"ExclusiveCollection", 'DateTime'>
    readonly mrp: FieldRef<"ExclusiveCollection", 'Float'>
    readonly price: FieldRef<"ExclusiveCollection", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ExclusiveCollection findUnique
   */
  export type ExclusiveCollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
    /**
     * Filter, which ExclusiveCollection to fetch.
     */
    where: ExclusiveCollectionWhereUniqueInput
  }

  /**
   * ExclusiveCollection findUniqueOrThrow
   */
  export type ExclusiveCollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
    /**
     * Filter, which ExclusiveCollection to fetch.
     */
    where: ExclusiveCollectionWhereUniqueInput
  }

  /**
   * ExclusiveCollection findFirst
   */
  export type ExclusiveCollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
    /**
     * Filter, which ExclusiveCollection to fetch.
     */
    where?: ExclusiveCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExclusiveCollections to fetch.
     */
    orderBy?: ExclusiveCollectionOrderByWithRelationInput | ExclusiveCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExclusiveCollections.
     */
    cursor?: ExclusiveCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExclusiveCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExclusiveCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExclusiveCollections.
     */
    distinct?: ExclusiveCollectionScalarFieldEnum | ExclusiveCollectionScalarFieldEnum[]
  }

  /**
   * ExclusiveCollection findFirstOrThrow
   */
  export type ExclusiveCollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
    /**
     * Filter, which ExclusiveCollection to fetch.
     */
    where?: ExclusiveCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExclusiveCollections to fetch.
     */
    orderBy?: ExclusiveCollectionOrderByWithRelationInput | ExclusiveCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExclusiveCollections.
     */
    cursor?: ExclusiveCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExclusiveCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExclusiveCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExclusiveCollections.
     */
    distinct?: ExclusiveCollectionScalarFieldEnum | ExclusiveCollectionScalarFieldEnum[]
  }

  /**
   * ExclusiveCollection findMany
   */
  export type ExclusiveCollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
    /**
     * Filter, which ExclusiveCollections to fetch.
     */
    where?: ExclusiveCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExclusiveCollections to fetch.
     */
    orderBy?: ExclusiveCollectionOrderByWithRelationInput | ExclusiveCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExclusiveCollections.
     */
    cursor?: ExclusiveCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExclusiveCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExclusiveCollections.
     */
    skip?: number
    distinct?: ExclusiveCollectionScalarFieldEnum | ExclusiveCollectionScalarFieldEnum[]
  }

  /**
   * ExclusiveCollection create
   */
  export type ExclusiveCollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
    /**
     * The data needed to create a ExclusiveCollection.
     */
    data: XOR<ExclusiveCollectionCreateInput, ExclusiveCollectionUncheckedCreateInput>
  }

  /**
   * ExclusiveCollection createMany
   */
  export type ExclusiveCollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExclusiveCollections.
     */
    data: ExclusiveCollectionCreateManyInput | ExclusiveCollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExclusiveCollection update
   */
  export type ExclusiveCollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
    /**
     * The data needed to update a ExclusiveCollection.
     */
    data: XOR<ExclusiveCollectionUpdateInput, ExclusiveCollectionUncheckedUpdateInput>
    /**
     * Choose, which ExclusiveCollection to update.
     */
    where: ExclusiveCollectionWhereUniqueInput
  }

  /**
   * ExclusiveCollection updateMany
   */
  export type ExclusiveCollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExclusiveCollections.
     */
    data: XOR<ExclusiveCollectionUpdateManyMutationInput, ExclusiveCollectionUncheckedUpdateManyInput>
    /**
     * Filter which ExclusiveCollections to update
     */
    where?: ExclusiveCollectionWhereInput
    /**
     * Limit how many ExclusiveCollections to update.
     */
    limit?: number
  }

  /**
   * ExclusiveCollection upsert
   */
  export type ExclusiveCollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
    /**
     * The filter to search for the ExclusiveCollection to update in case it exists.
     */
    where: ExclusiveCollectionWhereUniqueInput
    /**
     * In case the ExclusiveCollection found by the `where` argument doesn't exist, create a new ExclusiveCollection with this data.
     */
    create: XOR<ExclusiveCollectionCreateInput, ExclusiveCollectionUncheckedCreateInput>
    /**
     * In case the ExclusiveCollection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExclusiveCollectionUpdateInput, ExclusiveCollectionUncheckedUpdateInput>
  }

  /**
   * ExclusiveCollection delete
   */
  export type ExclusiveCollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
    /**
     * Filter which ExclusiveCollection to delete.
     */
    where: ExclusiveCollectionWhereUniqueInput
  }

  /**
   * ExclusiveCollection deleteMany
   */
  export type ExclusiveCollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExclusiveCollections to delete
     */
    where?: ExclusiveCollectionWhereInput
    /**
     * Limit how many ExclusiveCollections to delete.
     */
    limit?: number
  }

  /**
   * ExclusiveCollection without action
   */
  export type ExclusiveCollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExclusiveCollection
     */
    select?: ExclusiveCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExclusiveCollection
     */
    omit?: ExclusiveCollectionOmit<ExtArgs> | null
  }


  /**
   * Model HeroSliders
   */

  export type AggregateHeroSliders = {
    _count: HeroSlidersCountAggregateOutputType | null
    _min: HeroSlidersMinAggregateOutputType | null
    _max: HeroSlidersMaxAggregateOutputType | null
  }

  export type HeroSlidersMinAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
    categoryHyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroSlidersMaxAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
    categoryHyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroSlidersCountAggregateOutputType = {
    id: number
    imageUrl: number
    hyperLink: number
    categoryHyperLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HeroSlidersMinAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    categoryHyperLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroSlidersMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    categoryHyperLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroSlidersCountAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    categoryHyperLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HeroSlidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroSliders to aggregate.
     */
    where?: HeroSlidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSliders to fetch.
     */
    orderBy?: HeroSlidersOrderByWithRelationInput | HeroSlidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeroSlidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeroSliders
    **/
    _count?: true | HeroSlidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeroSlidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeroSlidersMaxAggregateInputType
  }

  export type GetHeroSlidersAggregateType<T extends HeroSlidersAggregateArgs> = {
        [P in keyof T & keyof AggregateHeroSliders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroSliders[P]>
      : GetScalarType<T[P], AggregateHeroSliders[P]>
  }




  export type HeroSlidersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroSlidersWhereInput
    orderBy?: HeroSlidersOrderByWithAggregationInput | HeroSlidersOrderByWithAggregationInput[]
    by: HeroSlidersScalarFieldEnum[] | HeroSlidersScalarFieldEnum
    having?: HeroSlidersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeroSlidersCountAggregateInputType | true
    _min?: HeroSlidersMinAggregateInputType
    _max?: HeroSlidersMaxAggregateInputType
  }

  export type HeroSlidersGroupByOutputType = {
    id: string
    imageUrl: string
    hyperLink: string
    categoryHyperLink: string | null
    createdAt: Date
    updatedAt: Date
    _count: HeroSlidersCountAggregateOutputType | null
    _min: HeroSlidersMinAggregateOutputType | null
    _max: HeroSlidersMaxAggregateOutputType | null
  }

  type GetHeroSlidersGroupByPayload<T extends HeroSlidersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeroSlidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeroSlidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroSlidersGroupByOutputType[P]>
            : GetScalarType<T[P], HeroSlidersGroupByOutputType[P]>
        }
      >
    >


  export type HeroSlidersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    categoryHyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["heroSliders"]>



  export type HeroSlidersSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    categoryHyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HeroSlidersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "imageUrl" | "hyperLink" | "categoryHyperLink" | "createdAt" | "updatedAt", ExtArgs["result"]["heroSliders"]>

  export type $HeroSlidersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeroSliders"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imageUrl: string
      hyperLink: string
      categoryHyperLink: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["heroSliders"]>
    composites: {}
  }

  type HeroSlidersGetPayload<S extends boolean | null | undefined | HeroSlidersDefaultArgs> = $Result.GetResult<Prisma.$HeroSlidersPayload, S>

  type HeroSlidersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HeroSlidersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HeroSlidersCountAggregateInputType | true
    }

  export interface HeroSlidersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeroSliders'], meta: { name: 'HeroSliders' } }
    /**
     * Find zero or one HeroSliders that matches the filter.
     * @param {HeroSlidersFindUniqueArgs} args - Arguments to find a HeroSliders
     * @example
     * // Get one HeroSliders
     * const heroSliders = await prisma.heroSliders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroSlidersFindUniqueArgs>(args: SelectSubset<T, HeroSlidersFindUniqueArgs<ExtArgs>>): Prisma__HeroSlidersClient<$Result.GetResult<Prisma.$HeroSlidersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HeroSliders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HeroSlidersFindUniqueOrThrowArgs} args - Arguments to find a HeroSliders
     * @example
     * // Get one HeroSliders
     * const heroSliders = await prisma.heroSliders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroSlidersFindUniqueOrThrowArgs>(args: SelectSubset<T, HeroSlidersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeroSlidersClient<$Result.GetResult<Prisma.$HeroSlidersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroSliders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlidersFindFirstArgs} args - Arguments to find a HeroSliders
     * @example
     * // Get one HeroSliders
     * const heroSliders = await prisma.heroSliders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroSlidersFindFirstArgs>(args?: SelectSubset<T, HeroSlidersFindFirstArgs<ExtArgs>>): Prisma__HeroSlidersClient<$Result.GetResult<Prisma.$HeroSlidersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroSliders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlidersFindFirstOrThrowArgs} args - Arguments to find a HeroSliders
     * @example
     * // Get one HeroSliders
     * const heroSliders = await prisma.heroSliders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroSlidersFindFirstOrThrowArgs>(args?: SelectSubset<T, HeroSlidersFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeroSlidersClient<$Result.GetResult<Prisma.$HeroSlidersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HeroSliders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlidersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroSliders
     * const heroSliders = await prisma.heroSliders.findMany()
     * 
     * // Get first 10 HeroSliders
     * const heroSliders = await prisma.heroSliders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heroSlidersWithIdOnly = await prisma.heroSliders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeroSlidersFindManyArgs>(args?: SelectSubset<T, HeroSlidersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroSlidersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HeroSliders.
     * @param {HeroSlidersCreateArgs} args - Arguments to create a HeroSliders.
     * @example
     * // Create one HeroSliders
     * const HeroSliders = await prisma.heroSliders.create({
     *   data: {
     *     // ... data to create a HeroSliders
     *   }
     * })
     * 
     */
    create<T extends HeroSlidersCreateArgs>(args: SelectSubset<T, HeroSlidersCreateArgs<ExtArgs>>): Prisma__HeroSlidersClient<$Result.GetResult<Prisma.$HeroSlidersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HeroSliders.
     * @param {HeroSlidersCreateManyArgs} args - Arguments to create many HeroSliders.
     * @example
     * // Create many HeroSliders
     * const heroSliders = await prisma.heroSliders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeroSlidersCreateManyArgs>(args?: SelectSubset<T, HeroSlidersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HeroSliders.
     * @param {HeroSlidersDeleteArgs} args - Arguments to delete one HeroSliders.
     * @example
     * // Delete one HeroSliders
     * const HeroSliders = await prisma.heroSliders.delete({
     *   where: {
     *     // ... filter to delete one HeroSliders
     *   }
     * })
     * 
     */
    delete<T extends HeroSlidersDeleteArgs>(args: SelectSubset<T, HeroSlidersDeleteArgs<ExtArgs>>): Prisma__HeroSlidersClient<$Result.GetResult<Prisma.$HeroSlidersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HeroSliders.
     * @param {HeroSlidersUpdateArgs} args - Arguments to update one HeroSliders.
     * @example
     * // Update one HeroSliders
     * const heroSliders = await prisma.heroSliders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeroSlidersUpdateArgs>(args: SelectSubset<T, HeroSlidersUpdateArgs<ExtArgs>>): Prisma__HeroSlidersClient<$Result.GetResult<Prisma.$HeroSlidersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HeroSliders.
     * @param {HeroSlidersDeleteManyArgs} args - Arguments to filter HeroSliders to delete.
     * @example
     * // Delete a few HeroSliders
     * const { count } = await prisma.heroSliders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeroSlidersDeleteManyArgs>(args?: SelectSubset<T, HeroSlidersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlidersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroSliders
     * const heroSliders = await prisma.heroSliders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeroSlidersUpdateManyArgs>(args: SelectSubset<T, HeroSlidersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HeroSliders.
     * @param {HeroSlidersUpsertArgs} args - Arguments to update or create a HeroSliders.
     * @example
     * // Update or create a HeroSliders
     * const heroSliders = await prisma.heroSliders.upsert({
     *   create: {
     *     // ... data to create a HeroSliders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroSliders we want to update
     *   }
     * })
     */
    upsert<T extends HeroSlidersUpsertArgs>(args: SelectSubset<T, HeroSlidersUpsertArgs<ExtArgs>>): Prisma__HeroSlidersClient<$Result.GetResult<Prisma.$HeroSlidersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HeroSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlidersCountArgs} args - Arguments to filter HeroSliders to count.
     * @example
     * // Count the number of HeroSliders
     * const count = await prisma.heroSliders.count({
     *   where: {
     *     // ... the filter for the HeroSliders we want to count
     *   }
     * })
    **/
    count<T extends HeroSlidersCountArgs>(
      args?: Subset<T, HeroSlidersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeroSlidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeroSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeroSlidersAggregateArgs>(args: Subset<T, HeroSlidersAggregateArgs>): Prisma.PrismaPromise<GetHeroSlidersAggregateType<T>>

    /**
     * Group by HeroSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroSlidersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeroSlidersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroSlidersGroupByArgs['orderBy'] }
        : { orderBy?: HeroSlidersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeroSlidersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeroSlidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeroSliders model
   */
  readonly fields: HeroSlidersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroSliders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroSlidersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeroSliders model
   */ 
  interface HeroSlidersFieldRefs {
    readonly id: FieldRef<"HeroSliders", 'String'>
    readonly imageUrl: FieldRef<"HeroSliders", 'String'>
    readonly hyperLink: FieldRef<"HeroSliders", 'String'>
    readonly categoryHyperLink: FieldRef<"HeroSliders", 'String'>
    readonly createdAt: FieldRef<"HeroSliders", 'DateTime'>
    readonly updatedAt: FieldRef<"HeroSliders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HeroSliders findUnique
   */
  export type HeroSlidersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
    /**
     * Filter, which HeroSliders to fetch.
     */
    where: HeroSlidersWhereUniqueInput
  }

  /**
   * HeroSliders findUniqueOrThrow
   */
  export type HeroSlidersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
    /**
     * Filter, which HeroSliders to fetch.
     */
    where: HeroSlidersWhereUniqueInput
  }

  /**
   * HeroSliders findFirst
   */
  export type HeroSlidersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
    /**
     * Filter, which HeroSliders to fetch.
     */
    where?: HeroSlidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSliders to fetch.
     */
    orderBy?: HeroSlidersOrderByWithRelationInput | HeroSlidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroSliders.
     */
    cursor?: HeroSlidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroSliders.
     */
    distinct?: HeroSlidersScalarFieldEnum | HeroSlidersScalarFieldEnum[]
  }

  /**
   * HeroSliders findFirstOrThrow
   */
  export type HeroSlidersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
    /**
     * Filter, which HeroSliders to fetch.
     */
    where?: HeroSlidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSliders to fetch.
     */
    orderBy?: HeroSlidersOrderByWithRelationInput | HeroSlidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroSliders.
     */
    cursor?: HeroSlidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroSliders.
     */
    distinct?: HeroSlidersScalarFieldEnum | HeroSlidersScalarFieldEnum[]
  }

  /**
   * HeroSliders findMany
   */
  export type HeroSlidersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
    /**
     * Filter, which HeroSliders to fetch.
     */
    where?: HeroSlidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroSliders to fetch.
     */
    orderBy?: HeroSlidersOrderByWithRelationInput | HeroSlidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeroSliders.
     */
    cursor?: HeroSlidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroSliders.
     */
    skip?: number
    distinct?: HeroSlidersScalarFieldEnum | HeroSlidersScalarFieldEnum[]
  }

  /**
   * HeroSliders create
   */
  export type HeroSlidersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
    /**
     * The data needed to create a HeroSliders.
     */
    data: XOR<HeroSlidersCreateInput, HeroSlidersUncheckedCreateInput>
  }

  /**
   * HeroSliders createMany
   */
  export type HeroSlidersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeroSliders.
     */
    data: HeroSlidersCreateManyInput | HeroSlidersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroSliders update
   */
  export type HeroSlidersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
    /**
     * The data needed to update a HeroSliders.
     */
    data: XOR<HeroSlidersUpdateInput, HeroSlidersUncheckedUpdateInput>
    /**
     * Choose, which HeroSliders to update.
     */
    where: HeroSlidersWhereUniqueInput
  }

  /**
   * HeroSliders updateMany
   */
  export type HeroSlidersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeroSliders.
     */
    data: XOR<HeroSlidersUpdateManyMutationInput, HeroSlidersUncheckedUpdateManyInput>
    /**
     * Filter which HeroSliders to update
     */
    where?: HeroSlidersWhereInput
    /**
     * Limit how many HeroSliders to update.
     */
    limit?: number
  }

  /**
   * HeroSliders upsert
   */
  export type HeroSlidersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
    /**
     * The filter to search for the HeroSliders to update in case it exists.
     */
    where: HeroSlidersWhereUniqueInput
    /**
     * In case the HeroSliders found by the `where` argument doesn't exist, create a new HeroSliders with this data.
     */
    create: XOR<HeroSlidersCreateInput, HeroSlidersUncheckedCreateInput>
    /**
     * In case the HeroSliders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroSlidersUpdateInput, HeroSlidersUncheckedUpdateInput>
  }

  /**
   * HeroSliders delete
   */
  export type HeroSlidersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
    /**
     * Filter which HeroSliders to delete.
     */
    where: HeroSlidersWhereUniqueInput
  }

  /**
   * HeroSliders deleteMany
   */
  export type HeroSlidersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroSliders to delete
     */
    where?: HeroSlidersWhereInput
    /**
     * Limit how many HeroSliders to delete.
     */
    limit?: number
  }

  /**
   * HeroSliders without action
   */
  export type HeroSlidersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroSliders
     */
    select?: HeroSlidersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroSliders
     */
    omit?: HeroSlidersOmit<ExtArgs> | null
  }


  /**
   * Model ImageWeek
   */

  export type AggregateImageWeek = {
    _count: ImageWeekCountAggregateOutputType | null
    _min: ImageWeekMinAggregateOutputType | null
    _max: ImageWeekMaxAggregateOutputType | null
  }

  export type ImageWeekMinAggregateOutputType = {
    id: string | null
    hyperLink: string | null
    imageUrl: string | null
  }

  export type ImageWeekMaxAggregateOutputType = {
    id: string | null
    hyperLink: string | null
    imageUrl: string | null
  }

  export type ImageWeekCountAggregateOutputType = {
    id: number
    hyperLink: number
    imageUrl: number
    _all: number
  }


  export type ImageWeekMinAggregateInputType = {
    id?: true
    hyperLink?: true
    imageUrl?: true
  }

  export type ImageWeekMaxAggregateInputType = {
    id?: true
    hyperLink?: true
    imageUrl?: true
  }

  export type ImageWeekCountAggregateInputType = {
    id?: true
    hyperLink?: true
    imageUrl?: true
    _all?: true
  }

  export type ImageWeekAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageWeek to aggregate.
     */
    where?: ImageWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageWeeks to fetch.
     */
    orderBy?: ImageWeekOrderByWithRelationInput | ImageWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageWeeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImageWeeks
    **/
    _count?: true | ImageWeekCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageWeekMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageWeekMaxAggregateInputType
  }

  export type GetImageWeekAggregateType<T extends ImageWeekAggregateArgs> = {
        [P in keyof T & keyof AggregateImageWeek]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImageWeek[P]>
      : GetScalarType<T[P], AggregateImageWeek[P]>
  }




  export type ImageWeekGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWeekWhereInput
    orderBy?: ImageWeekOrderByWithAggregationInput | ImageWeekOrderByWithAggregationInput[]
    by: ImageWeekScalarFieldEnum[] | ImageWeekScalarFieldEnum
    having?: ImageWeekScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageWeekCountAggregateInputType | true
    _min?: ImageWeekMinAggregateInputType
    _max?: ImageWeekMaxAggregateInputType
  }

  export type ImageWeekGroupByOutputType = {
    id: string
    hyperLink: string | null
    imageUrl: string | null
    _count: ImageWeekCountAggregateOutputType | null
    _min: ImageWeekMinAggregateOutputType | null
    _max: ImageWeekMaxAggregateOutputType | null
  }

  type GetImageWeekGroupByPayload<T extends ImageWeekGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageWeekGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageWeekGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageWeekGroupByOutputType[P]>
            : GetScalarType<T[P], ImageWeekGroupByOutputType[P]>
        }
      >
    >


  export type ImageWeekSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hyperLink?: boolean
    imageUrl?: boolean
  }, ExtArgs["result"]["imageWeek"]>



  export type ImageWeekSelectScalar = {
    id?: boolean
    hyperLink?: boolean
    imageUrl?: boolean
  }

  export type ImageWeekOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hyperLink" | "imageUrl", ExtArgs["result"]["imageWeek"]>

  export type $ImageWeekPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImageWeek"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hyperLink: string | null
      imageUrl: string | null
    }, ExtArgs["result"]["imageWeek"]>
    composites: {}
  }

  type ImageWeekGetPayload<S extends boolean | null | undefined | ImageWeekDefaultArgs> = $Result.GetResult<Prisma.$ImageWeekPayload, S>

  type ImageWeekCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageWeekFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageWeekCountAggregateInputType | true
    }

  export interface ImageWeekDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImageWeek'], meta: { name: 'ImageWeek' } }
    /**
     * Find zero or one ImageWeek that matches the filter.
     * @param {ImageWeekFindUniqueArgs} args - Arguments to find a ImageWeek
     * @example
     * // Get one ImageWeek
     * const imageWeek = await prisma.imageWeek.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageWeekFindUniqueArgs>(args: SelectSubset<T, ImageWeekFindUniqueArgs<ExtArgs>>): Prisma__ImageWeekClient<$Result.GetResult<Prisma.$ImageWeekPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImageWeek that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageWeekFindUniqueOrThrowArgs} args - Arguments to find a ImageWeek
     * @example
     * // Get one ImageWeek
     * const imageWeek = await prisma.imageWeek.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageWeekFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageWeekFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageWeekClient<$Result.GetResult<Prisma.$ImageWeekPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImageWeek that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageWeekFindFirstArgs} args - Arguments to find a ImageWeek
     * @example
     * // Get one ImageWeek
     * const imageWeek = await prisma.imageWeek.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageWeekFindFirstArgs>(args?: SelectSubset<T, ImageWeekFindFirstArgs<ExtArgs>>): Prisma__ImageWeekClient<$Result.GetResult<Prisma.$ImageWeekPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImageWeek that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageWeekFindFirstOrThrowArgs} args - Arguments to find a ImageWeek
     * @example
     * // Get one ImageWeek
     * const imageWeek = await prisma.imageWeek.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageWeekFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageWeekFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageWeekClient<$Result.GetResult<Prisma.$ImageWeekPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImageWeeks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageWeekFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImageWeeks
     * const imageWeeks = await prisma.imageWeek.findMany()
     * 
     * // Get first 10 ImageWeeks
     * const imageWeeks = await prisma.imageWeek.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWeekWithIdOnly = await prisma.imageWeek.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageWeekFindManyArgs>(args?: SelectSubset<T, ImageWeekFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImageWeekPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImageWeek.
     * @param {ImageWeekCreateArgs} args - Arguments to create a ImageWeek.
     * @example
     * // Create one ImageWeek
     * const ImageWeek = await prisma.imageWeek.create({
     *   data: {
     *     // ... data to create a ImageWeek
     *   }
     * })
     * 
     */
    create<T extends ImageWeekCreateArgs>(args: SelectSubset<T, ImageWeekCreateArgs<ExtArgs>>): Prisma__ImageWeekClient<$Result.GetResult<Prisma.$ImageWeekPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImageWeeks.
     * @param {ImageWeekCreateManyArgs} args - Arguments to create many ImageWeeks.
     * @example
     * // Create many ImageWeeks
     * const imageWeek = await prisma.imageWeek.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageWeekCreateManyArgs>(args?: SelectSubset<T, ImageWeekCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImageWeek.
     * @param {ImageWeekDeleteArgs} args - Arguments to delete one ImageWeek.
     * @example
     * // Delete one ImageWeek
     * const ImageWeek = await prisma.imageWeek.delete({
     *   where: {
     *     // ... filter to delete one ImageWeek
     *   }
     * })
     * 
     */
    delete<T extends ImageWeekDeleteArgs>(args: SelectSubset<T, ImageWeekDeleteArgs<ExtArgs>>): Prisma__ImageWeekClient<$Result.GetResult<Prisma.$ImageWeekPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImageWeek.
     * @param {ImageWeekUpdateArgs} args - Arguments to update one ImageWeek.
     * @example
     * // Update one ImageWeek
     * const imageWeek = await prisma.imageWeek.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageWeekUpdateArgs>(args: SelectSubset<T, ImageWeekUpdateArgs<ExtArgs>>): Prisma__ImageWeekClient<$Result.GetResult<Prisma.$ImageWeekPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImageWeeks.
     * @param {ImageWeekDeleteManyArgs} args - Arguments to filter ImageWeeks to delete.
     * @example
     * // Delete a few ImageWeeks
     * const { count } = await prisma.imageWeek.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageWeekDeleteManyArgs>(args?: SelectSubset<T, ImageWeekDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImageWeeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageWeekUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImageWeeks
     * const imageWeek = await prisma.imageWeek.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageWeekUpdateManyArgs>(args: SelectSubset<T, ImageWeekUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImageWeek.
     * @param {ImageWeekUpsertArgs} args - Arguments to update or create a ImageWeek.
     * @example
     * // Update or create a ImageWeek
     * const imageWeek = await prisma.imageWeek.upsert({
     *   create: {
     *     // ... data to create a ImageWeek
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImageWeek we want to update
     *   }
     * })
     */
    upsert<T extends ImageWeekUpsertArgs>(args: SelectSubset<T, ImageWeekUpsertArgs<ExtArgs>>): Prisma__ImageWeekClient<$Result.GetResult<Prisma.$ImageWeekPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImageWeeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageWeekCountArgs} args - Arguments to filter ImageWeeks to count.
     * @example
     * // Count the number of ImageWeeks
     * const count = await prisma.imageWeek.count({
     *   where: {
     *     // ... the filter for the ImageWeeks we want to count
     *   }
     * })
    **/
    count<T extends ImageWeekCountArgs>(
      args?: Subset<T, ImageWeekCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageWeekCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImageWeek.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageWeekAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageWeekAggregateArgs>(args: Subset<T, ImageWeekAggregateArgs>): Prisma.PrismaPromise<GetImageWeekAggregateType<T>>

    /**
     * Group by ImageWeek.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageWeekGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageWeekGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageWeekGroupByArgs['orderBy'] }
        : { orderBy?: ImageWeekGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageWeekGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageWeekGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImageWeek model
   */
  readonly fields: ImageWeekFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImageWeek.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageWeekClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImageWeek model
   */ 
  interface ImageWeekFieldRefs {
    readonly id: FieldRef<"ImageWeek", 'String'>
    readonly hyperLink: FieldRef<"ImageWeek", 'String'>
    readonly imageUrl: FieldRef<"ImageWeek", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImageWeek findUnique
   */
  export type ImageWeekFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
    /**
     * Filter, which ImageWeek to fetch.
     */
    where: ImageWeekWhereUniqueInput
  }

  /**
   * ImageWeek findUniqueOrThrow
   */
  export type ImageWeekFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
    /**
     * Filter, which ImageWeek to fetch.
     */
    where: ImageWeekWhereUniqueInput
  }

  /**
   * ImageWeek findFirst
   */
  export type ImageWeekFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
    /**
     * Filter, which ImageWeek to fetch.
     */
    where?: ImageWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageWeeks to fetch.
     */
    orderBy?: ImageWeekOrderByWithRelationInput | ImageWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageWeeks.
     */
    cursor?: ImageWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageWeeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageWeeks.
     */
    distinct?: ImageWeekScalarFieldEnum | ImageWeekScalarFieldEnum[]
  }

  /**
   * ImageWeek findFirstOrThrow
   */
  export type ImageWeekFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
    /**
     * Filter, which ImageWeek to fetch.
     */
    where?: ImageWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageWeeks to fetch.
     */
    orderBy?: ImageWeekOrderByWithRelationInput | ImageWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImageWeeks.
     */
    cursor?: ImageWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageWeeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImageWeeks.
     */
    distinct?: ImageWeekScalarFieldEnum | ImageWeekScalarFieldEnum[]
  }

  /**
   * ImageWeek findMany
   */
  export type ImageWeekFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
    /**
     * Filter, which ImageWeeks to fetch.
     */
    where?: ImageWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImageWeeks to fetch.
     */
    orderBy?: ImageWeekOrderByWithRelationInput | ImageWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImageWeeks.
     */
    cursor?: ImageWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImageWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImageWeeks.
     */
    skip?: number
    distinct?: ImageWeekScalarFieldEnum | ImageWeekScalarFieldEnum[]
  }

  /**
   * ImageWeek create
   */
  export type ImageWeekCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
    /**
     * The data needed to create a ImageWeek.
     */
    data: XOR<ImageWeekCreateInput, ImageWeekUncheckedCreateInput>
  }

  /**
   * ImageWeek createMany
   */
  export type ImageWeekCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImageWeeks.
     */
    data: ImageWeekCreateManyInput | ImageWeekCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImageWeek update
   */
  export type ImageWeekUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
    /**
     * The data needed to update a ImageWeek.
     */
    data: XOR<ImageWeekUpdateInput, ImageWeekUncheckedUpdateInput>
    /**
     * Choose, which ImageWeek to update.
     */
    where: ImageWeekWhereUniqueInput
  }

  /**
   * ImageWeek updateMany
   */
  export type ImageWeekUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImageWeeks.
     */
    data: XOR<ImageWeekUpdateManyMutationInput, ImageWeekUncheckedUpdateManyInput>
    /**
     * Filter which ImageWeeks to update
     */
    where?: ImageWeekWhereInput
    /**
     * Limit how many ImageWeeks to update.
     */
    limit?: number
  }

  /**
   * ImageWeek upsert
   */
  export type ImageWeekUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
    /**
     * The filter to search for the ImageWeek to update in case it exists.
     */
    where: ImageWeekWhereUniqueInput
    /**
     * In case the ImageWeek found by the `where` argument doesn't exist, create a new ImageWeek with this data.
     */
    create: XOR<ImageWeekCreateInput, ImageWeekUncheckedCreateInput>
    /**
     * In case the ImageWeek was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageWeekUpdateInput, ImageWeekUncheckedUpdateInput>
  }

  /**
   * ImageWeek delete
   */
  export type ImageWeekDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
    /**
     * Filter which ImageWeek to delete.
     */
    where: ImageWeekWhereUniqueInput
  }

  /**
   * ImageWeek deleteMany
   */
  export type ImageWeekDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImageWeeks to delete
     */
    where?: ImageWeekWhereInput
    /**
     * Limit how many ImageWeeks to delete.
     */
    limit?: number
  }

  /**
   * ImageWeek without action
   */
  export type ImageWeekDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageWeek
     */
    select?: ImageWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImageWeek
     */
    omit?: ImageWeekOmit<ExtArgs> | null
  }


  /**
   * Model Logos
   */

  export type AggregateLogos = {
    _count: LogosCountAggregateOutputType | null
    _min: LogosMinAggregateOutputType | null
    _max: LogosMaxAggregateOutputType | null
  }

  export type LogosMinAggregateOutputType = {
    id: string | null
    logoUrl: string | null
    isActive: boolean | null
    altText: string | null
  }

  export type LogosMaxAggregateOutputType = {
    id: string | null
    logoUrl: string | null
    isActive: boolean | null
    altText: string | null
  }

  export type LogosCountAggregateOutputType = {
    id: number
    logoUrl: number
    isActive: number
    altText: number
    _all: number
  }


  export type LogosMinAggregateInputType = {
    id?: true
    logoUrl?: true
    isActive?: true
    altText?: true
  }

  export type LogosMaxAggregateInputType = {
    id?: true
    logoUrl?: true
    isActive?: true
    altText?: true
  }

  export type LogosCountAggregateInputType = {
    id?: true
    logoUrl?: true
    isActive?: true
    altText?: true
    _all?: true
  }

  export type LogosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logos to aggregate.
     */
    where?: LogosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logos to fetch.
     */
    orderBy?: LogosOrderByWithRelationInput | LogosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logos
    **/
    _count?: true | LogosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogosMaxAggregateInputType
  }

  export type GetLogosAggregateType<T extends LogosAggregateArgs> = {
        [P in keyof T & keyof AggregateLogos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogos[P]>
      : GetScalarType<T[P], AggregateLogos[P]>
  }




  export type LogosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogosWhereInput
    orderBy?: LogosOrderByWithAggregationInput | LogosOrderByWithAggregationInput[]
    by: LogosScalarFieldEnum[] | LogosScalarFieldEnum
    having?: LogosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogosCountAggregateInputType | true
    _min?: LogosMinAggregateInputType
    _max?: LogosMaxAggregateInputType
  }

  export type LogosGroupByOutputType = {
    id: string
    logoUrl: string
    isActive: boolean
    altText: string | null
    _count: LogosCountAggregateOutputType | null
    _min: LogosMinAggregateOutputType | null
    _max: LogosMaxAggregateOutputType | null
  }

  type GetLogosGroupByPayload<T extends LogosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogosGroupByOutputType[P]>
            : GetScalarType<T[P], LogosGroupByOutputType[P]>
        }
      >
    >


  export type LogosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logoUrl?: boolean
    isActive?: boolean
    altText?: boolean
  }, ExtArgs["result"]["logos"]>



  export type LogosSelectScalar = {
    id?: boolean
    logoUrl?: boolean
    isActive?: boolean
    altText?: boolean
  }

  export type LogosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logoUrl" | "isActive" | "altText", ExtArgs["result"]["logos"]>

  export type $LogosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Logos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      logoUrl: string
      isActive: boolean
      altText: string | null
    }, ExtArgs["result"]["logos"]>
    composites: {}
  }

  type LogosGetPayload<S extends boolean | null | undefined | LogosDefaultArgs> = $Result.GetResult<Prisma.$LogosPayload, S>

  type LogosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogosCountAggregateInputType | true
    }

  export interface LogosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Logos'], meta: { name: 'Logos' } }
    /**
     * Find zero or one Logos that matches the filter.
     * @param {LogosFindUniqueArgs} args - Arguments to find a Logos
     * @example
     * // Get one Logos
     * const logos = await prisma.logos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogosFindUniqueArgs>(args: SelectSubset<T, LogosFindUniqueArgs<ExtArgs>>): Prisma__LogosClient<$Result.GetResult<Prisma.$LogosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Logos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogosFindUniqueOrThrowArgs} args - Arguments to find a Logos
     * @example
     * // Get one Logos
     * const logos = await prisma.logos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogosFindUniqueOrThrowArgs>(args: SelectSubset<T, LogosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogosClient<$Result.GetResult<Prisma.$LogosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogosFindFirstArgs} args - Arguments to find a Logos
     * @example
     * // Get one Logos
     * const logos = await prisma.logos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogosFindFirstArgs>(args?: SelectSubset<T, LogosFindFirstArgs<ExtArgs>>): Prisma__LogosClient<$Result.GetResult<Prisma.$LogosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogosFindFirstOrThrowArgs} args - Arguments to find a Logos
     * @example
     * // Get one Logos
     * const logos = await prisma.logos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogosFindFirstOrThrowArgs>(args?: SelectSubset<T, LogosFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogosClient<$Result.GetResult<Prisma.$LogosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logos
     * const logos = await prisma.logos.findMany()
     * 
     * // Get first 10 Logos
     * const logos = await prisma.logos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logosWithIdOnly = await prisma.logos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogosFindManyArgs>(args?: SelectSubset<T, LogosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Logos.
     * @param {LogosCreateArgs} args - Arguments to create a Logos.
     * @example
     * // Create one Logos
     * const Logos = await prisma.logos.create({
     *   data: {
     *     // ... data to create a Logos
     *   }
     * })
     * 
     */
    create<T extends LogosCreateArgs>(args: SelectSubset<T, LogosCreateArgs<ExtArgs>>): Prisma__LogosClient<$Result.GetResult<Prisma.$LogosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logos.
     * @param {LogosCreateManyArgs} args - Arguments to create many Logos.
     * @example
     * // Create many Logos
     * const logos = await prisma.logos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogosCreateManyArgs>(args?: SelectSubset<T, LogosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logos.
     * @param {LogosDeleteArgs} args - Arguments to delete one Logos.
     * @example
     * // Delete one Logos
     * const Logos = await prisma.logos.delete({
     *   where: {
     *     // ... filter to delete one Logos
     *   }
     * })
     * 
     */
    delete<T extends LogosDeleteArgs>(args: SelectSubset<T, LogosDeleteArgs<ExtArgs>>): Prisma__LogosClient<$Result.GetResult<Prisma.$LogosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Logos.
     * @param {LogosUpdateArgs} args - Arguments to update one Logos.
     * @example
     * // Update one Logos
     * const logos = await prisma.logos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogosUpdateArgs>(args: SelectSubset<T, LogosUpdateArgs<ExtArgs>>): Prisma__LogosClient<$Result.GetResult<Prisma.$LogosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logos.
     * @param {LogosDeleteManyArgs} args - Arguments to filter Logos to delete.
     * @example
     * // Delete a few Logos
     * const { count } = await prisma.logos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogosDeleteManyArgs>(args?: SelectSubset<T, LogosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logos
     * const logos = await prisma.logos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogosUpdateManyArgs>(args: SelectSubset<T, LogosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logos.
     * @param {LogosUpsertArgs} args - Arguments to update or create a Logos.
     * @example
     * // Update or create a Logos
     * const logos = await prisma.logos.upsert({
     *   create: {
     *     // ... data to create a Logos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logos we want to update
     *   }
     * })
     */
    upsert<T extends LogosUpsertArgs>(args: SelectSubset<T, LogosUpsertArgs<ExtArgs>>): Prisma__LogosClient<$Result.GetResult<Prisma.$LogosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogosCountArgs} args - Arguments to filter Logos to count.
     * @example
     * // Count the number of Logos
     * const count = await prisma.logos.count({
     *   where: {
     *     // ... the filter for the Logos we want to count
     *   }
     * })
    **/
    count<T extends LogosCountArgs>(
      args?: Subset<T, LogosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogosAggregateArgs>(args: Subset<T, LogosAggregateArgs>): Prisma.PrismaPromise<GetLogosAggregateType<T>>

    /**
     * Group by Logos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogosGroupByArgs['orderBy'] }
        : { orderBy?: LogosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Logos model
   */
  readonly fields: LogosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Logos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Logos model
   */ 
  interface LogosFieldRefs {
    readonly id: FieldRef<"Logos", 'String'>
    readonly logoUrl: FieldRef<"Logos", 'String'>
    readonly isActive: FieldRef<"Logos", 'Boolean'>
    readonly altText: FieldRef<"Logos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Logos findUnique
   */
  export type LogosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
    /**
     * Filter, which Logos to fetch.
     */
    where: LogosWhereUniqueInput
  }

  /**
   * Logos findUniqueOrThrow
   */
  export type LogosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
    /**
     * Filter, which Logos to fetch.
     */
    where: LogosWhereUniqueInput
  }

  /**
   * Logos findFirst
   */
  export type LogosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
    /**
     * Filter, which Logos to fetch.
     */
    where?: LogosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logos to fetch.
     */
    orderBy?: LogosOrderByWithRelationInput | LogosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logos.
     */
    cursor?: LogosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logos.
     */
    distinct?: LogosScalarFieldEnum | LogosScalarFieldEnum[]
  }

  /**
   * Logos findFirstOrThrow
   */
  export type LogosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
    /**
     * Filter, which Logos to fetch.
     */
    where?: LogosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logos to fetch.
     */
    orderBy?: LogosOrderByWithRelationInput | LogosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logos.
     */
    cursor?: LogosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logos.
     */
    distinct?: LogosScalarFieldEnum | LogosScalarFieldEnum[]
  }

  /**
   * Logos findMany
   */
  export type LogosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
    /**
     * Filter, which Logos to fetch.
     */
    where?: LogosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logos to fetch.
     */
    orderBy?: LogosOrderByWithRelationInput | LogosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logos.
     */
    cursor?: LogosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logos.
     */
    skip?: number
    distinct?: LogosScalarFieldEnum | LogosScalarFieldEnum[]
  }

  /**
   * Logos create
   */
  export type LogosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
    /**
     * The data needed to create a Logos.
     */
    data: XOR<LogosCreateInput, LogosUncheckedCreateInput>
  }

  /**
   * Logos createMany
   */
  export type LogosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logos.
     */
    data: LogosCreateManyInput | LogosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Logos update
   */
  export type LogosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
    /**
     * The data needed to update a Logos.
     */
    data: XOR<LogosUpdateInput, LogosUncheckedUpdateInput>
    /**
     * Choose, which Logos to update.
     */
    where: LogosWhereUniqueInput
  }

  /**
   * Logos updateMany
   */
  export type LogosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logos.
     */
    data: XOR<LogosUpdateManyMutationInput, LogosUncheckedUpdateManyInput>
    /**
     * Filter which Logos to update
     */
    where?: LogosWhereInput
    /**
     * Limit how many Logos to update.
     */
    limit?: number
  }

  /**
   * Logos upsert
   */
  export type LogosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
    /**
     * The filter to search for the Logos to update in case it exists.
     */
    where: LogosWhereUniqueInput
    /**
     * In case the Logos found by the `where` argument doesn't exist, create a new Logos with this data.
     */
    create: XOR<LogosCreateInput, LogosUncheckedCreateInput>
    /**
     * In case the Logos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogosUpdateInput, LogosUncheckedUpdateInput>
  }

  /**
   * Logos delete
   */
  export type LogosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
    /**
     * Filter which Logos to delete.
     */
    where: LogosWhereUniqueInput
  }

  /**
   * Logos deleteMany
   */
  export type LogosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logos to delete
     */
    where?: LogosWhereInput
    /**
     * Limit how many Logos to delete.
     */
    limit?: number
  }

  /**
   * Logos without action
   */
  export type LogosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logos
     */
    select?: LogosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logos
     */
    omit?: LogosOmit<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    message: string | null
    createdAt: Date | null
    handledById: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    message: string | null
    createdAt: Date | null
    handledById: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    message: number
    createdAt: number
    handledById: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    message?: true
    createdAt?: true
    handledById?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    message?: true
    createdAt?: true
    handledById?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    message?: true
    createdAt?: true
    handledById?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    message: string
    createdAt: Date
    handledById: string | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    message?: boolean
    createdAt?: boolean
    handledById?: boolean
    User_Message_handledByIdToUser?: boolean | Message$User_Message_handledByIdToUserArgs<ExtArgs>
    User_Message_receiverIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Message_senderIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>



  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    message?: boolean
    createdAt?: boolean
    handledById?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "message" | "createdAt" | "handledById", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User_Message_handledByIdToUser?: boolean | Message$User_Message_handledByIdToUserArgs<ExtArgs>
    User_Message_receiverIdToUser?: boolean | UserDefaultArgs<ExtArgs>
    User_Message_senderIdToUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      User_Message_handledByIdToUser: Prisma.$UserPayload<ExtArgs> | null
      User_Message_receiverIdToUser: Prisma.$UserPayload<ExtArgs>
      User_Message_senderIdToUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      message: string
      createdAt: Date
      handledById: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User_Message_handledByIdToUser<T extends Message$User_Message_handledByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, Message$User_Message_handledByIdToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User_Message_receiverIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User_Message_senderIdToUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
    readonly message: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly handledById: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.User_Message_handledByIdToUser
   */
  export type Message$User_Message_handledByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model NewArrivals
   */

  export type AggregateNewArrivals = {
    _count: NewArrivalsCountAggregateOutputType | null
    _avg: NewArrivalsAvgAggregateOutputType | null
    _sum: NewArrivalsSumAggregateOutputType | null
    _min: NewArrivalsMinAggregateOutputType | null
    _max: NewArrivalsMaxAggregateOutputType | null
  }

  export type NewArrivalsAvgAggregateOutputType = {
    mrp: number | null
    price: number | null
  }

  export type NewArrivalsSumAggregateOutputType = {
    mrp: number | null
    price: number | null
  }

  export type NewArrivalsMinAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    mrp: number | null
    price: number | null
    title: string | null
  }

  export type NewArrivalsMaxAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    mrp: number | null
    price: number | null
    title: string | null
  }

  export type NewArrivalsCountAggregateOutputType = {
    id: number
    imageUrl: number
    hyperLink: number
    createdAt: number
    updatedAt: number
    description: number
    mrp: number
    price: number
    title: number
    _all: number
  }


  export type NewArrivalsAvgAggregateInputType = {
    mrp?: true
    price?: true
  }

  export type NewArrivalsSumAggregateInputType = {
    mrp?: true
    price?: true
  }

  export type NewArrivalsMinAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    mrp?: true
    price?: true
    title?: true
  }

  export type NewArrivalsMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    mrp?: true
    price?: true
    title?: true
  }

  export type NewArrivalsCountAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    mrp?: true
    price?: true
    title?: true
    _all?: true
  }

  export type NewArrivalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewArrivals to aggregate.
     */
    where?: NewArrivalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewArrivals to fetch.
     */
    orderBy?: NewArrivalsOrderByWithRelationInput | NewArrivalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewArrivalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewArrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewArrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewArrivals
    **/
    _count?: true | NewArrivalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewArrivalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewArrivalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewArrivalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewArrivalsMaxAggregateInputType
  }

  export type GetNewArrivalsAggregateType<T extends NewArrivalsAggregateArgs> = {
        [P in keyof T & keyof AggregateNewArrivals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewArrivals[P]>
      : GetScalarType<T[P], AggregateNewArrivals[P]>
  }




  export type NewArrivalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewArrivalsWhereInput
    orderBy?: NewArrivalsOrderByWithAggregationInput | NewArrivalsOrderByWithAggregationInput[]
    by: NewArrivalsScalarFieldEnum[] | NewArrivalsScalarFieldEnum
    having?: NewArrivalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewArrivalsCountAggregateInputType | true
    _avg?: NewArrivalsAvgAggregateInputType
    _sum?: NewArrivalsSumAggregateInputType
    _min?: NewArrivalsMinAggregateInputType
    _max?: NewArrivalsMaxAggregateInputType
  }

  export type NewArrivalsGroupByOutputType = {
    id: string
    imageUrl: string | null
    hyperLink: string | null
    createdAt: Date
    updatedAt: Date
    description: string | null
    mrp: number | null
    price: number | null
    title: string | null
    _count: NewArrivalsCountAggregateOutputType | null
    _avg: NewArrivalsAvgAggregateOutputType | null
    _sum: NewArrivalsSumAggregateOutputType | null
    _min: NewArrivalsMinAggregateOutputType | null
    _max: NewArrivalsMaxAggregateOutputType | null
  }

  type GetNewArrivalsGroupByPayload<T extends NewArrivalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewArrivalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewArrivalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewArrivalsGroupByOutputType[P]>
            : GetScalarType<T[P], NewArrivalsGroupByOutputType[P]>
        }
      >
    >


  export type NewArrivalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    mrp?: boolean
    price?: boolean
    title?: boolean
  }, ExtArgs["result"]["newArrivals"]>



  export type NewArrivalsSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    mrp?: boolean
    price?: boolean
    title?: boolean
  }

  export type NewArrivalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "imageUrl" | "hyperLink" | "createdAt" | "updatedAt" | "description" | "mrp" | "price" | "title", ExtArgs["result"]["newArrivals"]>

  export type $NewArrivalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewArrivals"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imageUrl: string | null
      hyperLink: string | null
      createdAt: Date
      updatedAt: Date
      description: string | null
      mrp: number | null
      price: number | null
      title: string | null
    }, ExtArgs["result"]["newArrivals"]>
    composites: {}
  }

  type NewArrivalsGetPayload<S extends boolean | null | undefined | NewArrivalsDefaultArgs> = $Result.GetResult<Prisma.$NewArrivalsPayload, S>

  type NewArrivalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewArrivalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewArrivalsCountAggregateInputType | true
    }

  export interface NewArrivalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewArrivals'], meta: { name: 'NewArrivals' } }
    /**
     * Find zero or one NewArrivals that matches the filter.
     * @param {NewArrivalsFindUniqueArgs} args - Arguments to find a NewArrivals
     * @example
     * // Get one NewArrivals
     * const newArrivals = await prisma.newArrivals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewArrivalsFindUniqueArgs>(args: SelectSubset<T, NewArrivalsFindUniqueArgs<ExtArgs>>): Prisma__NewArrivalsClient<$Result.GetResult<Prisma.$NewArrivalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NewArrivals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewArrivalsFindUniqueOrThrowArgs} args - Arguments to find a NewArrivals
     * @example
     * // Get one NewArrivals
     * const newArrivals = await prisma.newArrivals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewArrivalsFindUniqueOrThrowArgs>(args: SelectSubset<T, NewArrivalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewArrivalsClient<$Result.GetResult<Prisma.$NewArrivalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewArrivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewArrivalsFindFirstArgs} args - Arguments to find a NewArrivals
     * @example
     * // Get one NewArrivals
     * const newArrivals = await prisma.newArrivals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewArrivalsFindFirstArgs>(args?: SelectSubset<T, NewArrivalsFindFirstArgs<ExtArgs>>): Prisma__NewArrivalsClient<$Result.GetResult<Prisma.$NewArrivalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NewArrivals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewArrivalsFindFirstOrThrowArgs} args - Arguments to find a NewArrivals
     * @example
     * // Get one NewArrivals
     * const newArrivals = await prisma.newArrivals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewArrivalsFindFirstOrThrowArgs>(args?: SelectSubset<T, NewArrivalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewArrivalsClient<$Result.GetResult<Prisma.$NewArrivalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NewArrivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewArrivalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewArrivals
     * const newArrivals = await prisma.newArrivals.findMany()
     * 
     * // Get first 10 NewArrivals
     * const newArrivals = await prisma.newArrivals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newArrivalsWithIdOnly = await prisma.newArrivals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewArrivalsFindManyArgs>(args?: SelectSubset<T, NewArrivalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewArrivalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NewArrivals.
     * @param {NewArrivalsCreateArgs} args - Arguments to create a NewArrivals.
     * @example
     * // Create one NewArrivals
     * const NewArrivals = await prisma.newArrivals.create({
     *   data: {
     *     // ... data to create a NewArrivals
     *   }
     * })
     * 
     */
    create<T extends NewArrivalsCreateArgs>(args: SelectSubset<T, NewArrivalsCreateArgs<ExtArgs>>): Prisma__NewArrivalsClient<$Result.GetResult<Prisma.$NewArrivalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NewArrivals.
     * @param {NewArrivalsCreateManyArgs} args - Arguments to create many NewArrivals.
     * @example
     * // Create many NewArrivals
     * const newArrivals = await prisma.newArrivals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewArrivalsCreateManyArgs>(args?: SelectSubset<T, NewArrivalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NewArrivals.
     * @param {NewArrivalsDeleteArgs} args - Arguments to delete one NewArrivals.
     * @example
     * // Delete one NewArrivals
     * const NewArrivals = await prisma.newArrivals.delete({
     *   where: {
     *     // ... filter to delete one NewArrivals
     *   }
     * })
     * 
     */
    delete<T extends NewArrivalsDeleteArgs>(args: SelectSubset<T, NewArrivalsDeleteArgs<ExtArgs>>): Prisma__NewArrivalsClient<$Result.GetResult<Prisma.$NewArrivalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NewArrivals.
     * @param {NewArrivalsUpdateArgs} args - Arguments to update one NewArrivals.
     * @example
     * // Update one NewArrivals
     * const newArrivals = await prisma.newArrivals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewArrivalsUpdateArgs>(args: SelectSubset<T, NewArrivalsUpdateArgs<ExtArgs>>): Prisma__NewArrivalsClient<$Result.GetResult<Prisma.$NewArrivalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NewArrivals.
     * @param {NewArrivalsDeleteManyArgs} args - Arguments to filter NewArrivals to delete.
     * @example
     * // Delete a few NewArrivals
     * const { count } = await prisma.newArrivals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewArrivalsDeleteManyArgs>(args?: SelectSubset<T, NewArrivalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewArrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewArrivalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewArrivals
     * const newArrivals = await prisma.newArrivals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewArrivalsUpdateManyArgs>(args: SelectSubset<T, NewArrivalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewArrivals.
     * @param {NewArrivalsUpsertArgs} args - Arguments to update or create a NewArrivals.
     * @example
     * // Update or create a NewArrivals
     * const newArrivals = await prisma.newArrivals.upsert({
     *   create: {
     *     // ... data to create a NewArrivals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewArrivals we want to update
     *   }
     * })
     */
    upsert<T extends NewArrivalsUpsertArgs>(args: SelectSubset<T, NewArrivalsUpsertArgs<ExtArgs>>): Prisma__NewArrivalsClient<$Result.GetResult<Prisma.$NewArrivalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NewArrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewArrivalsCountArgs} args - Arguments to filter NewArrivals to count.
     * @example
     * // Count the number of NewArrivals
     * const count = await prisma.newArrivals.count({
     *   where: {
     *     // ... the filter for the NewArrivals we want to count
     *   }
     * })
    **/
    count<T extends NewArrivalsCountArgs>(
      args?: Subset<T, NewArrivalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewArrivalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewArrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewArrivalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewArrivalsAggregateArgs>(args: Subset<T, NewArrivalsAggregateArgs>): Prisma.PrismaPromise<GetNewArrivalsAggregateType<T>>

    /**
     * Group by NewArrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewArrivalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewArrivalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewArrivalsGroupByArgs['orderBy'] }
        : { orderBy?: NewArrivalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewArrivalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewArrivalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewArrivals model
   */
  readonly fields: NewArrivalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewArrivals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewArrivalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewArrivals model
   */ 
  interface NewArrivalsFieldRefs {
    readonly id: FieldRef<"NewArrivals", 'String'>
    readonly imageUrl: FieldRef<"NewArrivals", 'String'>
    readonly hyperLink: FieldRef<"NewArrivals", 'String'>
    readonly createdAt: FieldRef<"NewArrivals", 'DateTime'>
    readonly updatedAt: FieldRef<"NewArrivals", 'DateTime'>
    readonly description: FieldRef<"NewArrivals", 'String'>
    readonly mrp: FieldRef<"NewArrivals", 'Float'>
    readonly price: FieldRef<"NewArrivals", 'Float'>
    readonly title: FieldRef<"NewArrivals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NewArrivals findUnique
   */
  export type NewArrivalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
    /**
     * Filter, which NewArrivals to fetch.
     */
    where: NewArrivalsWhereUniqueInput
  }

  /**
   * NewArrivals findUniqueOrThrow
   */
  export type NewArrivalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
    /**
     * Filter, which NewArrivals to fetch.
     */
    where: NewArrivalsWhereUniqueInput
  }

  /**
   * NewArrivals findFirst
   */
  export type NewArrivalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
    /**
     * Filter, which NewArrivals to fetch.
     */
    where?: NewArrivalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewArrivals to fetch.
     */
    orderBy?: NewArrivalsOrderByWithRelationInput | NewArrivalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewArrivals.
     */
    cursor?: NewArrivalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewArrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewArrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewArrivals.
     */
    distinct?: NewArrivalsScalarFieldEnum | NewArrivalsScalarFieldEnum[]
  }

  /**
   * NewArrivals findFirstOrThrow
   */
  export type NewArrivalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
    /**
     * Filter, which NewArrivals to fetch.
     */
    where?: NewArrivalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewArrivals to fetch.
     */
    orderBy?: NewArrivalsOrderByWithRelationInput | NewArrivalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewArrivals.
     */
    cursor?: NewArrivalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewArrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewArrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewArrivals.
     */
    distinct?: NewArrivalsScalarFieldEnum | NewArrivalsScalarFieldEnum[]
  }

  /**
   * NewArrivals findMany
   */
  export type NewArrivalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
    /**
     * Filter, which NewArrivals to fetch.
     */
    where?: NewArrivalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewArrivals to fetch.
     */
    orderBy?: NewArrivalsOrderByWithRelationInput | NewArrivalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewArrivals.
     */
    cursor?: NewArrivalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewArrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewArrivals.
     */
    skip?: number
    distinct?: NewArrivalsScalarFieldEnum | NewArrivalsScalarFieldEnum[]
  }

  /**
   * NewArrivals create
   */
  export type NewArrivalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
    /**
     * The data needed to create a NewArrivals.
     */
    data: XOR<NewArrivalsCreateInput, NewArrivalsUncheckedCreateInput>
  }

  /**
   * NewArrivals createMany
   */
  export type NewArrivalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewArrivals.
     */
    data: NewArrivalsCreateManyInput | NewArrivalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NewArrivals update
   */
  export type NewArrivalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
    /**
     * The data needed to update a NewArrivals.
     */
    data: XOR<NewArrivalsUpdateInput, NewArrivalsUncheckedUpdateInput>
    /**
     * Choose, which NewArrivals to update.
     */
    where: NewArrivalsWhereUniqueInput
  }

  /**
   * NewArrivals updateMany
   */
  export type NewArrivalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewArrivals.
     */
    data: XOR<NewArrivalsUpdateManyMutationInput, NewArrivalsUncheckedUpdateManyInput>
    /**
     * Filter which NewArrivals to update
     */
    where?: NewArrivalsWhereInput
    /**
     * Limit how many NewArrivals to update.
     */
    limit?: number
  }

  /**
   * NewArrivals upsert
   */
  export type NewArrivalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
    /**
     * The filter to search for the NewArrivals to update in case it exists.
     */
    where: NewArrivalsWhereUniqueInput
    /**
     * In case the NewArrivals found by the `where` argument doesn't exist, create a new NewArrivals with this data.
     */
    create: XOR<NewArrivalsCreateInput, NewArrivalsUncheckedCreateInput>
    /**
     * In case the NewArrivals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewArrivalsUpdateInput, NewArrivalsUncheckedUpdateInput>
  }

  /**
   * NewArrivals delete
   */
  export type NewArrivalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
    /**
     * Filter which NewArrivals to delete.
     */
    where: NewArrivalsWhereUniqueInput
  }

  /**
   * NewArrivals deleteMany
   */
  export type NewArrivalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewArrivals to delete
     */
    where?: NewArrivalsWhereInput
    /**
     * Limit how many NewArrivals to delete.
     */
    limit?: number
  }

  /**
   * NewArrivals without action
   */
  export type NewArrivalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewArrivals
     */
    select?: NewArrivalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NewArrivals
     */
    omit?: NewArrivalsOmit<ExtArgs> | null
  }


  /**
   * Model Newsletter
   */

  export type AggregateNewsletter = {
    _count: NewsletterCountAggregateOutputType | null
    _min: NewsletterMinAggregateOutputType | null
    _max: NewsletterMaxAggregateOutputType | null
  }

  export type NewsletterMinAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterMaxAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsletterCountAggregateOutputType = {
    id: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsletterMinAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterMaxAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsletterCountAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsletterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Newsletter to aggregate.
     */
    where?: NewsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newsletters to fetch.
     */
    orderBy?: NewsletterOrderByWithRelationInput | NewsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Newsletters
    **/
    _count?: true | NewsletterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsletterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsletterMaxAggregateInputType
  }

  export type GetNewsletterAggregateType<T extends NewsletterAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsletter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsletter[P]>
      : GetScalarType<T[P], AggregateNewsletter[P]>
  }




  export type NewsletterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsletterWhereInput
    orderBy?: NewsletterOrderByWithAggregationInput | NewsletterOrderByWithAggregationInput[]
    by: NewsletterScalarFieldEnum[] | NewsletterScalarFieldEnum
    having?: NewsletterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsletterCountAggregateInputType | true
    _min?: NewsletterMinAggregateInputType
    _max?: NewsletterMaxAggregateInputType
  }

  export type NewsletterGroupByOutputType = {
    id: string
    email: string
    createdAt: Date
    updatedAt: Date
    _count: NewsletterCountAggregateOutputType | null
    _min: NewsletterMinAggregateOutputType | null
    _max: NewsletterMaxAggregateOutputType | null
  }

  type GetNewsletterGroupByPayload<T extends NewsletterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsletterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsletterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsletterGroupByOutputType[P]>
            : GetScalarType<T[P], NewsletterGroupByOutputType[P]>
        }
      >
    >


  export type NewsletterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsletter"]>



  export type NewsletterSelectScalar = {
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NewsletterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["newsletter"]>

  export type $NewsletterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Newsletter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["newsletter"]>
    composites: {}
  }

  type NewsletterGetPayload<S extends boolean | null | undefined | NewsletterDefaultArgs> = $Result.GetResult<Prisma.$NewsletterPayload, S>

  type NewsletterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NewsletterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NewsletterCountAggregateInputType | true
    }

  export interface NewsletterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Newsletter'], meta: { name: 'Newsletter' } }
    /**
     * Find zero or one Newsletter that matches the filter.
     * @param {NewsletterFindUniqueArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsletterFindUniqueArgs>(args: SelectSubset<T, NewsletterFindUniqueArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Newsletter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NewsletterFindUniqueOrThrowArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsletterFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsletterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Newsletter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterFindFirstArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsletterFindFirstArgs>(args?: SelectSubset<T, NewsletterFindFirstArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Newsletter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterFindFirstOrThrowArgs} args - Arguments to find a Newsletter
     * @example
     * // Get one Newsletter
     * const newsletter = await prisma.newsletter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsletterFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsletterFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Newsletters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newsletters
     * const newsletters = await prisma.newsletter.findMany()
     * 
     * // Get first 10 Newsletters
     * const newsletters = await prisma.newsletter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsletterWithIdOnly = await prisma.newsletter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsletterFindManyArgs>(args?: SelectSubset<T, NewsletterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Newsletter.
     * @param {NewsletterCreateArgs} args - Arguments to create a Newsletter.
     * @example
     * // Create one Newsletter
     * const Newsletter = await prisma.newsletter.create({
     *   data: {
     *     // ... data to create a Newsletter
     *   }
     * })
     * 
     */
    create<T extends NewsletterCreateArgs>(args: SelectSubset<T, NewsletterCreateArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Newsletters.
     * @param {NewsletterCreateManyArgs} args - Arguments to create many Newsletters.
     * @example
     * // Create many Newsletters
     * const newsletter = await prisma.newsletter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsletterCreateManyArgs>(args?: SelectSubset<T, NewsletterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Newsletter.
     * @param {NewsletterDeleteArgs} args - Arguments to delete one Newsletter.
     * @example
     * // Delete one Newsletter
     * const Newsletter = await prisma.newsletter.delete({
     *   where: {
     *     // ... filter to delete one Newsletter
     *   }
     * })
     * 
     */
    delete<T extends NewsletterDeleteArgs>(args: SelectSubset<T, NewsletterDeleteArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Newsletter.
     * @param {NewsletterUpdateArgs} args - Arguments to update one Newsletter.
     * @example
     * // Update one Newsletter
     * const newsletter = await prisma.newsletter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsletterUpdateArgs>(args: SelectSubset<T, NewsletterUpdateArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Newsletters.
     * @param {NewsletterDeleteManyArgs} args - Arguments to filter Newsletters to delete.
     * @example
     * // Delete a few Newsletters
     * const { count } = await prisma.newsletter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsletterDeleteManyArgs>(args?: SelectSubset<T, NewsletterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newsletters
     * const newsletter = await prisma.newsletter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsletterUpdateManyArgs>(args: SelectSubset<T, NewsletterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Newsletter.
     * @param {NewsletterUpsertArgs} args - Arguments to update or create a Newsletter.
     * @example
     * // Update or create a Newsletter
     * const newsletter = await prisma.newsletter.upsert({
     *   create: {
     *     // ... data to create a Newsletter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newsletter we want to update
     *   }
     * })
     */
    upsert<T extends NewsletterUpsertArgs>(args: SelectSubset<T, NewsletterUpsertArgs<ExtArgs>>): Prisma__NewsletterClient<$Result.GetResult<Prisma.$NewsletterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Newsletters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterCountArgs} args - Arguments to filter Newsletters to count.
     * @example
     * // Count the number of Newsletters
     * const count = await prisma.newsletter.count({
     *   where: {
     *     // ... the filter for the Newsletters we want to count
     *   }
     * })
    **/
    count<T extends NewsletterCountArgs>(
      args?: Subset<T, NewsletterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsletterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsletterAggregateArgs>(args: Subset<T, NewsletterAggregateArgs>): Prisma.PrismaPromise<GetNewsletterAggregateType<T>>

    /**
     * Group by Newsletter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsletterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsletterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsletterGroupByArgs['orderBy'] }
        : { orderBy?: NewsletterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsletterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsletterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Newsletter model
   */
  readonly fields: NewsletterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Newsletter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsletterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Newsletter model
   */ 
  interface NewsletterFieldRefs {
    readonly id: FieldRef<"Newsletter", 'String'>
    readonly email: FieldRef<"Newsletter", 'String'>
    readonly createdAt: FieldRef<"Newsletter", 'DateTime'>
    readonly updatedAt: FieldRef<"Newsletter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Newsletter findUnique
   */
  export type NewsletterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletter to fetch.
     */
    where: NewsletterWhereUniqueInput
  }

  /**
   * Newsletter findUniqueOrThrow
   */
  export type NewsletterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletter to fetch.
     */
    where: NewsletterWhereUniqueInput
  }

  /**
   * Newsletter findFirst
   */
  export type NewsletterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletter to fetch.
     */
    where?: NewsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newsletters to fetch.
     */
    orderBy?: NewsletterOrderByWithRelationInput | NewsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Newsletters.
     */
    cursor?: NewsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Newsletters.
     */
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * Newsletter findFirstOrThrow
   */
  export type NewsletterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletter to fetch.
     */
    where?: NewsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newsletters to fetch.
     */
    orderBy?: NewsletterOrderByWithRelationInput | NewsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Newsletters.
     */
    cursor?: NewsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newsletters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Newsletters.
     */
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * Newsletter findMany
   */
  export type NewsletterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter, which Newsletters to fetch.
     */
    where?: NewsletterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Newsletters to fetch.
     */
    orderBy?: NewsletterOrderByWithRelationInput | NewsletterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Newsletters.
     */
    cursor?: NewsletterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Newsletters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Newsletters.
     */
    skip?: number
    distinct?: NewsletterScalarFieldEnum | NewsletterScalarFieldEnum[]
  }

  /**
   * Newsletter create
   */
  export type NewsletterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * The data needed to create a Newsletter.
     */
    data: XOR<NewsletterCreateInput, NewsletterUncheckedCreateInput>
  }

  /**
   * Newsletter createMany
   */
  export type NewsletterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Newsletters.
     */
    data: NewsletterCreateManyInput | NewsletterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Newsletter update
   */
  export type NewsletterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * The data needed to update a Newsletter.
     */
    data: XOR<NewsletterUpdateInput, NewsletterUncheckedUpdateInput>
    /**
     * Choose, which Newsletter to update.
     */
    where: NewsletterWhereUniqueInput
  }

  /**
   * Newsletter updateMany
   */
  export type NewsletterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Newsletters.
     */
    data: XOR<NewsletterUpdateManyMutationInput, NewsletterUncheckedUpdateManyInput>
    /**
     * Filter which Newsletters to update
     */
    where?: NewsletterWhereInput
    /**
     * Limit how many Newsletters to update.
     */
    limit?: number
  }

  /**
   * Newsletter upsert
   */
  export type NewsletterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * The filter to search for the Newsletter to update in case it exists.
     */
    where: NewsletterWhereUniqueInput
    /**
     * In case the Newsletter found by the `where` argument doesn't exist, create a new Newsletter with this data.
     */
    create: XOR<NewsletterCreateInput, NewsletterUncheckedCreateInput>
    /**
     * In case the Newsletter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsletterUpdateInput, NewsletterUncheckedUpdateInput>
  }

  /**
   * Newsletter delete
   */
  export type NewsletterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
    /**
     * Filter which Newsletter to delete.
     */
    where: NewsletterWhereUniqueInput
  }

  /**
   * Newsletter deleteMany
   */
  export type NewsletterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Newsletters to delete
     */
    where?: NewsletterWhereInput
    /**
     * Limit how many Newsletters to delete.
     */
    limit?: number
  }

  /**
   * Newsletter without action
   */
  export type NewsletterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Newsletter
     */
    select?: NewsletterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Newsletter
     */
    omit?: NewsletterOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    hyperLink: string | null
    title: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    hyperLink: string | null
    title: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    isRead: number
    createdAt: number
    hyperLink: number
    title: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    isRead?: true
    createdAt?: true
    hyperLink?: true
    title?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    isRead?: true
    createdAt?: true
    hyperLink?: true
    title?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    isRead?: true
    createdAt?: true
    hyperLink?: true
    title?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    message: string | null
    isRead: boolean
    createdAt: Date
    hyperLink: string | null
    title: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    hyperLink?: boolean
    title?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    hyperLink?: boolean
    title?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "message" | "isRead" | "createdAt" | "hyperLink" | "title", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      message: string | null
      isRead: boolean
      createdAt: Date
      hyperLink: string | null
      title: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly hyperLink: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model OrderDetails
   */

  export type AggregateOrderDetails = {
    _count: OrderDetailsCountAggregateOutputType | null
    _avg: OrderDetailsAvgAggregateOutputType | null
    _sum: OrderDetailsSumAggregateOutputType | null
    _min: OrderDetailsMinAggregateOutputType | null
    _max: OrderDetailsMaxAggregateOutputType | null
  }

  export type OrderDetailsAvgAggregateOutputType = {
    totalPrice: number | null
    finalPrice: number | null
  }

  export type OrderDetailsSumAggregateOutputType = {
    totalPrice: number | null
    finalPrice: number | null
  }

  export type OrderDetailsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalPrice: number | null
    status: $Enums.OrderDetails_status | null
    createdAt: Date | null
    updatedAt: Date | null
    discountId: string | null
    orderId: string | null
    paymentMethod: $Enums.OrderDetails_paymentMethod | null
    notes: string | null
    trackingId: string | null
    addressId: string | null
    finalPrice: number | null
  }

  export type OrderDetailsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalPrice: number | null
    status: $Enums.OrderDetails_status | null
    createdAt: Date | null
    updatedAt: Date | null
    discountId: string | null
    orderId: string | null
    paymentMethod: $Enums.OrderDetails_paymentMethod | null
    notes: string | null
    trackingId: string | null
    addressId: string | null
    finalPrice: number | null
  }

  export type OrderDetailsCountAggregateOutputType = {
    id: number
    userId: number
    totalPrice: number
    status: number
    createdAt: number
    updatedAt: number
    discountId: number
    orderId: number
    paymentMethod: number
    notes: number
    trackingId: number
    addressId: number
    finalPrice: number
    _all: number
  }


  export type OrderDetailsAvgAggregateInputType = {
    totalPrice?: true
    finalPrice?: true
  }

  export type OrderDetailsSumAggregateInputType = {
    totalPrice?: true
    finalPrice?: true
  }

  export type OrderDetailsMinAggregateInputType = {
    id?: true
    userId?: true
    totalPrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    discountId?: true
    orderId?: true
    paymentMethod?: true
    notes?: true
    trackingId?: true
    addressId?: true
    finalPrice?: true
  }

  export type OrderDetailsMaxAggregateInputType = {
    id?: true
    userId?: true
    totalPrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    discountId?: true
    orderId?: true
    paymentMethod?: true
    notes?: true
    trackingId?: true
    addressId?: true
    finalPrice?: true
  }

  export type OrderDetailsCountAggregateInputType = {
    id?: true
    userId?: true
    totalPrice?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    discountId?: true
    orderId?: true
    paymentMethod?: true
    notes?: true
    trackingId?: true
    addressId?: true
    finalPrice?: true
    _all?: true
  }

  export type OrderDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDetails to aggregate.
     */
    where?: OrderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderDetails
    **/
    _count?: true | OrderDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderDetailsMaxAggregateInputType
  }

  export type GetOrderDetailsAggregateType<T extends OrderDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderDetails[P]>
      : GetScalarType<T[P], AggregateOrderDetails[P]>
  }




  export type OrderDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetailsWhereInput
    orderBy?: OrderDetailsOrderByWithAggregationInput | OrderDetailsOrderByWithAggregationInput[]
    by: OrderDetailsScalarFieldEnum[] | OrderDetailsScalarFieldEnum
    having?: OrderDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderDetailsCountAggregateInputType | true
    _avg?: OrderDetailsAvgAggregateInputType
    _sum?: OrderDetailsSumAggregateInputType
    _min?: OrderDetailsMinAggregateInputType
    _max?: OrderDetailsMaxAggregateInputType
  }

  export type OrderDetailsGroupByOutputType = {
    id: string
    userId: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt: Date
    updatedAt: Date
    discountId: string | null
    orderId: string
    paymentMethod: $Enums.OrderDetails_paymentMethod | null
    notes: string | null
    trackingId: string | null
    addressId: string | null
    finalPrice: number | null
    _count: OrderDetailsCountAggregateOutputType | null
    _avg: OrderDetailsAvgAggregateOutputType | null
    _sum: OrderDetailsSumAggregateOutputType | null
    _min: OrderDetailsMinAggregateOutputType | null
    _max: OrderDetailsMaxAggregateOutputType | null
  }

  type GetOrderDetailsGroupByPayload<T extends OrderDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], OrderDetailsGroupByOutputType[P]>
        }
      >
    >


  export type OrderDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discountId?: boolean
    orderId?: boolean
    paymentMethod?: boolean
    notes?: boolean
    trackingId?: boolean
    addressId?: boolean
    finalPrice?: boolean
    UserAddress?: boolean | OrderDetails$UserAddressArgs<ExtArgs>
    Discount?: boolean | OrderDetails$DiscountArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    OrderItem?: boolean | OrderDetails$OrderItemArgs<ExtArgs>
    PaymentDetails?: boolean | OrderDetails$PaymentDetailsArgs<ExtArgs>
    _count?: boolean | OrderDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderDetails"]>



  export type OrderDetailsSelectScalar = {
    id?: boolean
    userId?: boolean
    totalPrice?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discountId?: boolean
    orderId?: boolean
    paymentMethod?: boolean
    notes?: boolean
    trackingId?: boolean
    addressId?: boolean
    finalPrice?: boolean
  }

  export type OrderDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalPrice" | "status" | "createdAt" | "updatedAt" | "discountId" | "orderId" | "paymentMethod" | "notes" | "trackingId" | "addressId" | "finalPrice", ExtArgs["result"]["orderDetails"]>
  export type OrderDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserAddress?: boolean | OrderDetails$UserAddressArgs<ExtArgs>
    Discount?: boolean | OrderDetails$DiscountArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    OrderItem?: boolean | OrderDetails$OrderItemArgs<ExtArgs>
    PaymentDetails?: boolean | OrderDetails$PaymentDetailsArgs<ExtArgs>
    _count?: boolean | OrderDetailsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderDetails"
    objects: {
      UserAddress: Prisma.$UserAddressPayload<ExtArgs> | null
      Discount: Prisma.$DiscountPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
      PaymentDetails: Prisma.$PaymentDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalPrice: number
      status: $Enums.OrderDetails_status
      createdAt: Date
      updatedAt: Date
      discountId: string | null
      orderId: string
      paymentMethod: $Enums.OrderDetails_paymentMethod | null
      notes: string | null
      trackingId: string | null
      addressId: string | null
      finalPrice: number | null
    }, ExtArgs["result"]["orderDetails"]>
    composites: {}
  }

  type OrderDetailsGetPayload<S extends boolean | null | undefined | OrderDetailsDefaultArgs> = $Result.GetResult<Prisma.$OrderDetailsPayload, S>

  type OrderDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderDetailsCountAggregateInputType | true
    }

  export interface OrderDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderDetails'], meta: { name: 'OrderDetails' } }
    /**
     * Find zero or one OrderDetails that matches the filter.
     * @param {OrderDetailsFindUniqueArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderDetailsFindUniqueArgs>(args: SelectSubset<T, OrderDetailsFindUniqueArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderDetailsFindUniqueOrThrowArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsFindFirstArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderDetailsFindFirstArgs>(args?: SelectSubset<T, OrderDetailsFindFirstArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsFindFirstOrThrowArgs} args - Arguments to find a OrderDetails
     * @example
     * // Get one OrderDetails
     * const orderDetails = await prisma.orderDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderDetails
     * const orderDetails = await prisma.orderDetails.findMany()
     * 
     * // Get first 10 OrderDetails
     * const orderDetails = await prisma.orderDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderDetailsWithIdOnly = await prisma.orderDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderDetailsFindManyArgs>(args?: SelectSubset<T, OrderDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderDetails.
     * @param {OrderDetailsCreateArgs} args - Arguments to create a OrderDetails.
     * @example
     * // Create one OrderDetails
     * const OrderDetails = await prisma.orderDetails.create({
     *   data: {
     *     // ... data to create a OrderDetails
     *   }
     * })
     * 
     */
    create<T extends OrderDetailsCreateArgs>(args: SelectSubset<T, OrderDetailsCreateArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderDetails.
     * @param {OrderDetailsCreateManyArgs} args - Arguments to create many OrderDetails.
     * @example
     * // Create many OrderDetails
     * const orderDetails = await prisma.orderDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderDetailsCreateManyArgs>(args?: SelectSubset<T, OrderDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderDetails.
     * @param {OrderDetailsDeleteArgs} args - Arguments to delete one OrderDetails.
     * @example
     * // Delete one OrderDetails
     * const OrderDetails = await prisma.orderDetails.delete({
     *   where: {
     *     // ... filter to delete one OrderDetails
     *   }
     * })
     * 
     */
    delete<T extends OrderDetailsDeleteArgs>(args: SelectSubset<T, OrderDetailsDeleteArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderDetails.
     * @param {OrderDetailsUpdateArgs} args - Arguments to update one OrderDetails.
     * @example
     * // Update one OrderDetails
     * const orderDetails = await prisma.orderDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderDetailsUpdateArgs>(args: SelectSubset<T, OrderDetailsUpdateArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderDetails.
     * @param {OrderDetailsDeleteManyArgs} args - Arguments to filter OrderDetails to delete.
     * @example
     * // Delete a few OrderDetails
     * const { count } = await prisma.orderDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDetailsDeleteManyArgs>(args?: SelectSubset<T, OrderDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderDetails
     * const orderDetails = await prisma.orderDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderDetailsUpdateManyArgs>(args: SelectSubset<T, OrderDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderDetails.
     * @param {OrderDetailsUpsertArgs} args - Arguments to update or create a OrderDetails.
     * @example
     * // Update or create a OrderDetails
     * const orderDetails = await prisma.orderDetails.upsert({
     *   create: {
     *     // ... data to create a OrderDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderDetails we want to update
     *   }
     * })
     */
    upsert<T extends OrderDetailsUpsertArgs>(args: SelectSubset<T, OrderDetailsUpsertArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsCountArgs} args - Arguments to filter OrderDetails to count.
     * @example
     * // Count the number of OrderDetails
     * const count = await prisma.orderDetails.count({
     *   where: {
     *     // ... the filter for the OrderDetails we want to count
     *   }
     * })
    **/
    count<T extends OrderDetailsCountArgs>(
      args?: Subset<T, OrderDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderDetailsAggregateArgs>(args: Subset<T, OrderDetailsAggregateArgs>): Prisma.PrismaPromise<GetOrderDetailsAggregateType<T>>

    /**
     * Group by OrderDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderDetailsGroupByArgs['orderBy'] }
        : { orderBy?: OrderDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderDetails model
   */
  readonly fields: OrderDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserAddress<T extends OrderDetails$UserAddressArgs<ExtArgs> = {}>(args?: Subset<T, OrderDetails$UserAddressArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Discount<T extends OrderDetails$DiscountArgs<ExtArgs> = {}>(args?: Subset<T, OrderDetails$DiscountArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    OrderItem<T extends OrderDetails$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, OrderDetails$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PaymentDetails<T extends OrderDetails$PaymentDetailsArgs<ExtArgs> = {}>(args?: Subset<T, OrderDetails$PaymentDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderDetails model
   */ 
  interface OrderDetailsFieldRefs {
    readonly id: FieldRef<"OrderDetails", 'String'>
    readonly userId: FieldRef<"OrderDetails", 'String'>
    readonly totalPrice: FieldRef<"OrderDetails", 'Float'>
    readonly status: FieldRef<"OrderDetails", 'OrderDetails_status'>
    readonly createdAt: FieldRef<"OrderDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderDetails", 'DateTime'>
    readonly discountId: FieldRef<"OrderDetails", 'String'>
    readonly orderId: FieldRef<"OrderDetails", 'String'>
    readonly paymentMethod: FieldRef<"OrderDetails", 'OrderDetails_paymentMethod'>
    readonly notes: FieldRef<"OrderDetails", 'String'>
    readonly trackingId: FieldRef<"OrderDetails", 'String'>
    readonly addressId: FieldRef<"OrderDetails", 'String'>
    readonly finalPrice: FieldRef<"OrderDetails", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OrderDetails findUnique
   */
  export type OrderDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where: OrderDetailsWhereUniqueInput
  }

  /**
   * OrderDetails findUniqueOrThrow
   */
  export type OrderDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where: OrderDetailsWhereUniqueInput
  }

  /**
   * OrderDetails findFirst
   */
  export type OrderDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where?: OrderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDetails.
     */
    cursor?: OrderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDetails.
     */
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * OrderDetails findFirstOrThrow
   */
  export type OrderDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where?: OrderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDetails.
     */
    cursor?: OrderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDetails.
     */
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * OrderDetails findMany
   */
  export type OrderDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetails to fetch.
     */
    where?: OrderDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetails to fetch.
     */
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderDetails.
     */
    cursor?: OrderDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetails.
     */
    skip?: number
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * OrderDetails create
   */
  export type OrderDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderDetails.
     */
    data: XOR<OrderDetailsCreateInput, OrderDetailsUncheckedCreateInput>
  }

  /**
   * OrderDetails createMany
   */
  export type OrderDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderDetails.
     */
    data: OrderDetailsCreateManyInput | OrderDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderDetails update
   */
  export type OrderDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderDetails.
     */
    data: XOR<OrderDetailsUpdateInput, OrderDetailsUncheckedUpdateInput>
    /**
     * Choose, which OrderDetails to update.
     */
    where: OrderDetailsWhereUniqueInput
  }

  /**
   * OrderDetails updateMany
   */
  export type OrderDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderDetails.
     */
    data: XOR<OrderDetailsUpdateManyMutationInput, OrderDetailsUncheckedUpdateManyInput>
    /**
     * Filter which OrderDetails to update
     */
    where?: OrderDetailsWhereInput
    /**
     * Limit how many OrderDetails to update.
     */
    limit?: number
  }

  /**
   * OrderDetails upsert
   */
  export type OrderDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderDetails to update in case it exists.
     */
    where: OrderDetailsWhereUniqueInput
    /**
     * In case the OrderDetails found by the `where` argument doesn't exist, create a new OrderDetails with this data.
     */
    create: XOR<OrderDetailsCreateInput, OrderDetailsUncheckedCreateInput>
    /**
     * In case the OrderDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderDetailsUpdateInput, OrderDetailsUncheckedUpdateInput>
  }

  /**
   * OrderDetails delete
   */
  export type OrderDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    /**
     * Filter which OrderDetails to delete.
     */
    where: OrderDetailsWhereUniqueInput
  }

  /**
   * OrderDetails deleteMany
   */
  export type OrderDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDetails to delete
     */
    where?: OrderDetailsWhereInput
    /**
     * Limit how many OrderDetails to delete.
     */
    limit?: number
  }

  /**
   * OrderDetails.UserAddress
   */
  export type OrderDetails$UserAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    where?: UserAddressWhereInput
  }

  /**
   * OrderDetails.Discount
   */
  export type OrderDetails$DiscountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    where?: DiscountWhereInput
  }

  /**
   * OrderDetails.OrderItem
   */
  export type OrderDetails$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderDetails.PaymentDetails
   */
  export type OrderDetails$PaymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    where?: PaymentDetailsWhereInput
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    cursor?: PaymentDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentDetailsScalarFieldEnum | PaymentDetailsScalarFieldEnum[]
  }

  /**
   * OrderDetails without action
   */
  export type OrderDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sizeId: string | null
    colorId: string | null
    imageId: string | null
    isReviewed: boolean | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    sizeId: string | null
    colorId: string | null
    imageId: string | null
    isReviewed: boolean | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    price: number
    createdAt: number
    updatedAt: number
    sizeId: number
    colorId: number
    imageId: number
    isReviewed: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    sizeId?: true
    colorId?: true
    imageId?: true
    isReviewed?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    sizeId?: true
    colorId?: true
    imageId?: true
    isReviewed?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    sizeId?: true
    colorId?: true
    imageId?: true
    isReviewed?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt: Date
    updatedAt: Date
    sizeId: string | null
    colorId: string | null
    imageId: string | null
    isReviewed: boolean
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sizeId?: boolean
    colorId?: boolean
    imageId?: boolean
    isReviewed?: boolean
    ProductColor?: boolean | OrderItem$ProductColorArgs<ExtArgs>
    ProductImage?: boolean | OrderItem$ProductImageArgs<ExtArgs>
    OrderDetails?: boolean | OrderDetailsDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProductSize?: boolean | OrderItem$ProductSizeArgs<ExtArgs>
    ReturnRequest?: boolean | OrderItem$ReturnRequestArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>



  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sizeId?: boolean
    colorId?: boolean
    imageId?: boolean
    isReviewed?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "price" | "createdAt" | "updatedAt" | "sizeId" | "colorId" | "imageId" | "isReviewed", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductColor?: boolean | OrderItem$ProductColorArgs<ExtArgs>
    ProductImage?: boolean | OrderItem$ProductImageArgs<ExtArgs>
    OrderDetails?: boolean | OrderDetailsDefaultArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProductSize?: boolean | OrderItem$ProductSizeArgs<ExtArgs>
    ReturnRequest?: boolean | OrderItem$ReturnRequestArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      ProductColor: Prisma.$ProductColorPayload<ExtArgs> | null
      ProductImage: Prisma.$ProductImagePayload<ExtArgs> | null
      OrderDetails: Prisma.$OrderDetailsPayload<ExtArgs>
      Product: Prisma.$ProductPayload<ExtArgs>
      ProductSize: Prisma.$ProductSizePayload<ExtArgs> | null
      ReturnRequest: Prisma.$ReturnRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantity: number
      price: number
      createdAt: Date
      updatedAt: Date
      sizeId: string | null
      colorId: string | null
      imageId: string | null
      isReviewed: boolean
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProductColor<T extends OrderItem$ProductColorArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$ProductColorArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ProductImage<T extends OrderItem$ProductImageArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$ProductImageArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    OrderDetails<T extends OrderDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDetailsDefaultArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProductSize<T extends OrderItem$ProductSizeArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$ProductSizeArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ReturnRequest<T extends OrderItem$ReturnRequestArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$ReturnRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Float'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly sizeId: FieldRef<"OrderItem", 'String'>
    readonly colorId: FieldRef<"OrderItem", 'String'>
    readonly imageId: FieldRef<"OrderItem", 'String'>
    readonly isReviewed: FieldRef<"OrderItem", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.ProductColor
   */
  export type OrderItem$ProductColorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    where?: ProductColorWhereInput
  }

  /**
   * OrderItem.ProductImage
   */
  export type OrderItem$ProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
  }

  /**
   * OrderItem.ProductSize
   */
  export type OrderItem$ProductSizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    where?: ProductSizeWhereInput
  }

  /**
   * OrderItem.ReturnRequest
   */
  export type OrderItem$ReturnRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    where?: ReturnRequestWhereInput
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    cursor?: ReturnRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[]
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    userId: number
    code: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    userId: string
    code: string
    expiresAt: Date
    createdAt: Date
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>



  export type OtpSelectScalar = {
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "code" | "expiresAt" | "createdAt", ExtArgs["result"]["otp"]>
  export type OtpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      code: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */ 
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly userId: FieldRef<"Otp", 'String'>
    readonly code: FieldRef<"Otp", 'String'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
  }


  /**
   * Model PaymentDetails
   */

  export type AggregatePaymentDetails = {
    _count: PaymentDetailsCountAggregateOutputType | null
    _avg: PaymentDetailsAvgAggregateOutputType | null
    _sum: PaymentDetailsSumAggregateOutputType | null
    _min: PaymentDetailsMinAggregateOutputType | null
    _max: PaymentDetailsMaxAggregateOutputType | null
  }

  export type PaymentDetailsAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentDetailsSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentDetailsMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    bank: string | null
    currency: string | null
    method: string | null
    order_id: string | null
    payment_id: string | null
    upi: string | null
    wallet: string | null
  }

  export type PaymentDetailsMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    bank: string | null
    currency: string | null
    method: string | null
    order_id: string | null
    payment_id: string | null
    upi: string | null
    wallet: string | null
  }

  export type PaymentDetailsCountAggregateOutputType = {
    id: number
    orderId: number
    amount: number
    createdAt: number
    updatedAt: number
    bank: number
    currency: number
    method: number
    order_id: number
    payment_id: number
    upi: number
    wallet: number
    _all: number
  }


  export type PaymentDetailsAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentDetailsSumAggregateInputType = {
    amount?: true
  }

  export type PaymentDetailsMinAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    bank?: true
    currency?: true
    method?: true
    order_id?: true
    payment_id?: true
    upi?: true
    wallet?: true
  }

  export type PaymentDetailsMaxAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    bank?: true
    currency?: true
    method?: true
    order_id?: true
    payment_id?: true
    upi?: true
    wallet?: true
  }

  export type PaymentDetailsCountAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    bank?: true
    currency?: true
    method?: true
    order_id?: true
    payment_id?: true
    upi?: true
    wallet?: true
    _all?: true
  }

  export type PaymentDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentDetails to aggregate.
     */
    where?: PaymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentDetails
    **/
    _count?: true | PaymentDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentDetailsMaxAggregateInputType
  }

  export type GetPaymentDetailsAggregateType<T extends PaymentDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentDetails[P]>
      : GetScalarType<T[P], AggregatePaymentDetails[P]>
  }




  export type PaymentDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentDetailsWhereInput
    orderBy?: PaymentDetailsOrderByWithAggregationInput | PaymentDetailsOrderByWithAggregationInput[]
    by: PaymentDetailsScalarFieldEnum[] | PaymentDetailsScalarFieldEnum
    having?: PaymentDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentDetailsCountAggregateInputType | true
    _avg?: PaymentDetailsAvgAggregateInputType
    _sum?: PaymentDetailsSumAggregateInputType
    _min?: PaymentDetailsMinAggregateInputType
    _max?: PaymentDetailsMaxAggregateInputType
  }

  export type PaymentDetailsGroupByOutputType = {
    id: string
    orderId: string
    amount: number
    createdAt: Date
    updatedAt: Date
    bank: string | null
    currency: string
    method: string
    order_id: string
    payment_id: string
    upi: string | null
    wallet: string | null
    _count: PaymentDetailsCountAggregateOutputType | null
    _avg: PaymentDetailsAvgAggregateOutputType | null
    _sum: PaymentDetailsSumAggregateOutputType | null
    _min: PaymentDetailsMinAggregateOutputType | null
    _max: PaymentDetailsMaxAggregateOutputType | null
  }

  type GetPaymentDetailsGroupByPayload<T extends PaymentDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentDetailsGroupByOutputType[P]>
        }
      >
    >


  export type PaymentDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bank?: boolean
    currency?: boolean
    method?: boolean
    order_id?: boolean
    payment_id?: boolean
    upi?: boolean
    wallet?: boolean
    OrderDetails?: boolean | OrderDetailsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentDetails"]>



  export type PaymentDetailsSelectScalar = {
    id?: boolean
    orderId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bank?: boolean
    currency?: boolean
    method?: boolean
    order_id?: boolean
    payment_id?: boolean
    upi?: boolean
    wallet?: boolean
  }

  export type PaymentDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "amount" | "createdAt" | "updatedAt" | "bank" | "currency" | "method" | "order_id" | "payment_id" | "upi" | "wallet", ExtArgs["result"]["paymentDetails"]>
  export type PaymentDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderDetails?: boolean | OrderDetailsDefaultArgs<ExtArgs>
  }

  export type $PaymentDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentDetails"
    objects: {
      OrderDetails: Prisma.$OrderDetailsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      amount: number
      createdAt: Date
      updatedAt: Date
      bank: string | null
      currency: string
      method: string
      order_id: string
      payment_id: string
      upi: string | null
      wallet: string | null
    }, ExtArgs["result"]["paymentDetails"]>
    composites: {}
  }

  type PaymentDetailsGetPayload<S extends boolean | null | undefined | PaymentDetailsDefaultArgs> = $Result.GetResult<Prisma.$PaymentDetailsPayload, S>

  type PaymentDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentDetailsCountAggregateInputType | true
    }

  export interface PaymentDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentDetails'], meta: { name: 'PaymentDetails' } }
    /**
     * Find zero or one PaymentDetails that matches the filter.
     * @param {PaymentDetailsFindUniqueArgs} args - Arguments to find a PaymentDetails
     * @example
     * // Get one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentDetailsFindUniqueArgs>(args: SelectSubset<T, PaymentDetailsFindUniqueArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentDetailsFindUniqueOrThrowArgs} args - Arguments to find a PaymentDetails
     * @example
     * // Get one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsFindFirstArgs} args - Arguments to find a PaymentDetails
     * @example
     * // Get one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentDetailsFindFirstArgs>(args?: SelectSubset<T, PaymentDetailsFindFirstArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsFindFirstOrThrowArgs} args - Arguments to find a PaymentDetails
     * @example
     * // Get one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findMany()
     * 
     * // Get first 10 PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentDetailsWithIdOnly = await prisma.paymentDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentDetailsFindManyArgs>(args?: SelectSubset<T, PaymentDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentDetails.
     * @param {PaymentDetailsCreateArgs} args - Arguments to create a PaymentDetails.
     * @example
     * // Create one PaymentDetails
     * const PaymentDetails = await prisma.paymentDetails.create({
     *   data: {
     *     // ... data to create a PaymentDetails
     *   }
     * })
     * 
     */
    create<T extends PaymentDetailsCreateArgs>(args: SelectSubset<T, PaymentDetailsCreateArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentDetails.
     * @param {PaymentDetailsCreateManyArgs} args - Arguments to create many PaymentDetails.
     * @example
     * // Create many PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentDetailsCreateManyArgs>(args?: SelectSubset<T, PaymentDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentDetails.
     * @param {PaymentDetailsDeleteArgs} args - Arguments to delete one PaymentDetails.
     * @example
     * // Delete one PaymentDetails
     * const PaymentDetails = await prisma.paymentDetails.delete({
     *   where: {
     *     // ... filter to delete one PaymentDetails
     *   }
     * })
     * 
     */
    delete<T extends PaymentDetailsDeleteArgs>(args: SelectSubset<T, PaymentDetailsDeleteArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentDetails.
     * @param {PaymentDetailsUpdateArgs} args - Arguments to update one PaymentDetails.
     * @example
     * // Update one PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentDetailsUpdateArgs>(args: SelectSubset<T, PaymentDetailsUpdateArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentDetails.
     * @param {PaymentDetailsDeleteManyArgs} args - Arguments to filter PaymentDetails to delete.
     * @example
     * // Delete a few PaymentDetails
     * const { count } = await prisma.paymentDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDetailsDeleteManyArgs>(args?: SelectSubset<T, PaymentDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentDetailsUpdateManyArgs>(args: SelectSubset<T, PaymentDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentDetails.
     * @param {PaymentDetailsUpsertArgs} args - Arguments to update or create a PaymentDetails.
     * @example
     * // Update or create a PaymentDetails
     * const paymentDetails = await prisma.paymentDetails.upsert({
     *   create: {
     *     // ... data to create a PaymentDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentDetails we want to update
     *   }
     * })
     */
    upsert<T extends PaymentDetailsUpsertArgs>(args: SelectSubset<T, PaymentDetailsUpsertArgs<ExtArgs>>): Prisma__PaymentDetailsClient<$Result.GetResult<Prisma.$PaymentDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsCountArgs} args - Arguments to filter PaymentDetails to count.
     * @example
     * // Count the number of PaymentDetails
     * const count = await prisma.paymentDetails.count({
     *   where: {
     *     // ... the filter for the PaymentDetails we want to count
     *   }
     * })
    **/
    count<T extends PaymentDetailsCountArgs>(
      args?: Subset<T, PaymentDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentDetailsAggregateArgs>(args: Subset<T, PaymentDetailsAggregateArgs>): Prisma.PrismaPromise<GetPaymentDetailsAggregateType<T>>

    /**
     * Group by PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentDetailsGroupByArgs['orderBy'] }
        : { orderBy?: PaymentDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentDetails model
   */
  readonly fields: PaymentDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrderDetails<T extends OrderDetailsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDetailsDefaultArgs<ExtArgs>>): Prisma__OrderDetailsClient<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentDetails model
   */ 
  interface PaymentDetailsFieldRefs {
    readonly id: FieldRef<"PaymentDetails", 'String'>
    readonly orderId: FieldRef<"PaymentDetails", 'String'>
    readonly amount: FieldRef<"PaymentDetails", 'Float'>
    readonly createdAt: FieldRef<"PaymentDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentDetails", 'DateTime'>
    readonly bank: FieldRef<"PaymentDetails", 'String'>
    readonly currency: FieldRef<"PaymentDetails", 'String'>
    readonly method: FieldRef<"PaymentDetails", 'String'>
    readonly order_id: FieldRef<"PaymentDetails", 'String'>
    readonly payment_id: FieldRef<"PaymentDetails", 'String'>
    readonly upi: FieldRef<"PaymentDetails", 'String'>
    readonly wallet: FieldRef<"PaymentDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentDetails findUnique
   */
  export type PaymentDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where: PaymentDetailsWhereUniqueInput
  }

  /**
   * PaymentDetails findUniqueOrThrow
   */
  export type PaymentDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where: PaymentDetailsWhereUniqueInput
  }

  /**
   * PaymentDetails findFirst
   */
  export type PaymentDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where?: PaymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentDetails.
     */
    cursor?: PaymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentDetails.
     */
    distinct?: PaymentDetailsScalarFieldEnum | PaymentDetailsScalarFieldEnum[]
  }

  /**
   * PaymentDetails findFirstOrThrow
   */
  export type PaymentDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where?: PaymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentDetails.
     */
    cursor?: PaymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentDetails.
     */
    distinct?: PaymentDetailsScalarFieldEnum | PaymentDetailsScalarFieldEnum[]
  }

  /**
   * PaymentDetails findMany
   */
  export type PaymentDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where?: PaymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailsOrderByWithRelationInput | PaymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentDetails.
     */
    cursor?: PaymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    distinct?: PaymentDetailsScalarFieldEnum | PaymentDetailsScalarFieldEnum[]
  }

  /**
   * PaymentDetails create
   */
  export type PaymentDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentDetails.
     */
    data: XOR<PaymentDetailsCreateInput, PaymentDetailsUncheckedCreateInput>
  }

  /**
   * PaymentDetails createMany
   */
  export type PaymentDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentDetails.
     */
    data: PaymentDetailsCreateManyInput | PaymentDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentDetails update
   */
  export type PaymentDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentDetails.
     */
    data: XOR<PaymentDetailsUpdateInput, PaymentDetailsUncheckedUpdateInput>
    /**
     * Choose, which PaymentDetails to update.
     */
    where: PaymentDetailsWhereUniqueInput
  }

  /**
   * PaymentDetails updateMany
   */
  export type PaymentDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentDetails.
     */
    data: XOR<PaymentDetailsUpdateManyMutationInput, PaymentDetailsUncheckedUpdateManyInput>
    /**
     * Filter which PaymentDetails to update
     */
    where?: PaymentDetailsWhereInput
    /**
     * Limit how many PaymentDetails to update.
     */
    limit?: number
  }

  /**
   * PaymentDetails upsert
   */
  export type PaymentDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentDetails to update in case it exists.
     */
    where: PaymentDetailsWhereUniqueInput
    /**
     * In case the PaymentDetails found by the `where` argument doesn't exist, create a new PaymentDetails with this data.
     */
    create: XOR<PaymentDetailsCreateInput, PaymentDetailsUncheckedCreateInput>
    /**
     * In case the PaymentDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentDetailsUpdateInput, PaymentDetailsUncheckedUpdateInput>
  }

  /**
   * PaymentDetails delete
   */
  export type PaymentDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
    /**
     * Filter which PaymentDetails to delete.
     */
    where: PaymentDetailsWhereUniqueInput
  }

  /**
   * PaymentDetails deleteMany
   */
  export type PaymentDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentDetails to delete
     */
    where?: PaymentDetailsWhereInput
    /**
     * Limit how many PaymentDetails to delete.
     */
    limit?: number
  }

  /**
   * PaymentDetails without action
   */
  export type PaymentDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetails
     */
    select?: PaymentDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetails
     */
    omit?: PaymentDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Privilege
   */

  export type AggregatePrivilege = {
    _count: PrivilegeCountAggregateOutputType | null
    _min: PrivilegeMinAggregateOutputType | null
    _max: PrivilegeMaxAggregateOutputType | null
  }

  export type PrivilegeMinAggregateOutputType = {
    id: string | null
    name: string | null
    label: string | null
  }

  export type PrivilegeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    label: string | null
  }

  export type PrivilegeCountAggregateOutputType = {
    id: number
    name: number
    label: number
    _all: number
  }


  export type PrivilegeMinAggregateInputType = {
    id?: true
    name?: true
    label?: true
  }

  export type PrivilegeMaxAggregateInputType = {
    id?: true
    name?: true
    label?: true
  }

  export type PrivilegeCountAggregateInputType = {
    id?: true
    name?: true
    label?: true
    _all?: true
  }

  export type PrivilegeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Privilege to aggregate.
     */
    where?: PrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privileges to fetch.
     */
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Privileges
    **/
    _count?: true | PrivilegeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivilegeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivilegeMaxAggregateInputType
  }

  export type GetPrivilegeAggregateType<T extends PrivilegeAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivilege]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivilege[P]>
      : GetScalarType<T[P], AggregatePrivilege[P]>
  }




  export type PrivilegeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivilegeWhereInput
    orderBy?: PrivilegeOrderByWithAggregationInput | PrivilegeOrderByWithAggregationInput[]
    by: PrivilegeScalarFieldEnum[] | PrivilegeScalarFieldEnum
    having?: PrivilegeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivilegeCountAggregateInputType | true
    _min?: PrivilegeMinAggregateInputType
    _max?: PrivilegeMaxAggregateInputType
  }

  export type PrivilegeGroupByOutputType = {
    id: string
    name: string
    label: string | null
    _count: PrivilegeCountAggregateOutputType | null
    _min: PrivilegeMinAggregateOutputType | null
    _max: PrivilegeMaxAggregateOutputType | null
  }

  type GetPrivilegeGroupByPayload<T extends PrivilegeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivilegeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivilegeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivilegeGroupByOutputType[P]>
            : GetScalarType<T[P], PrivilegeGroupByOutputType[P]>
        }
      >
    >


  export type PrivilegeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    label?: boolean
    UserPrivilege?: boolean | Privilege$UserPrivilegeArgs<ExtArgs>
    _count?: boolean | PrivilegeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privilege"]>



  export type PrivilegeSelectScalar = {
    id?: boolean
    name?: boolean
    label?: boolean
  }

  export type PrivilegeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "label", ExtArgs["result"]["privilege"]>
  export type PrivilegeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserPrivilege?: boolean | Privilege$UserPrivilegeArgs<ExtArgs>
    _count?: boolean | PrivilegeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PrivilegePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Privilege"
    objects: {
      UserPrivilege: Prisma.$UserPrivilegePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      label: string | null
    }, ExtArgs["result"]["privilege"]>
    composites: {}
  }

  type PrivilegeGetPayload<S extends boolean | null | undefined | PrivilegeDefaultArgs> = $Result.GetResult<Prisma.$PrivilegePayload, S>

  type PrivilegeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivilegeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivilegeCountAggregateInputType | true
    }

  export interface PrivilegeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Privilege'], meta: { name: 'Privilege' } }
    /**
     * Find zero or one Privilege that matches the filter.
     * @param {PrivilegeFindUniqueArgs} args - Arguments to find a Privilege
     * @example
     * // Get one Privilege
     * const privilege = await prisma.privilege.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivilegeFindUniqueArgs>(args: SelectSubset<T, PrivilegeFindUniqueArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Privilege that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivilegeFindUniqueOrThrowArgs} args - Arguments to find a Privilege
     * @example
     * // Get one Privilege
     * const privilege = await prisma.privilege.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivilegeFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivilegeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privilege that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeFindFirstArgs} args - Arguments to find a Privilege
     * @example
     * // Get one Privilege
     * const privilege = await prisma.privilege.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivilegeFindFirstArgs>(args?: SelectSubset<T, PrivilegeFindFirstArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Privilege that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeFindFirstOrThrowArgs} args - Arguments to find a Privilege
     * @example
     * // Get one Privilege
     * const privilege = await prisma.privilege.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivilegeFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivilegeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Privileges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Privileges
     * const privileges = await prisma.privilege.findMany()
     * 
     * // Get first 10 Privileges
     * const privileges = await prisma.privilege.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privilegeWithIdOnly = await prisma.privilege.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivilegeFindManyArgs>(args?: SelectSubset<T, PrivilegeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Privilege.
     * @param {PrivilegeCreateArgs} args - Arguments to create a Privilege.
     * @example
     * // Create one Privilege
     * const Privilege = await prisma.privilege.create({
     *   data: {
     *     // ... data to create a Privilege
     *   }
     * })
     * 
     */
    create<T extends PrivilegeCreateArgs>(args: SelectSubset<T, PrivilegeCreateArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Privileges.
     * @param {PrivilegeCreateManyArgs} args - Arguments to create many Privileges.
     * @example
     * // Create many Privileges
     * const privilege = await prisma.privilege.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivilegeCreateManyArgs>(args?: SelectSubset<T, PrivilegeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Privilege.
     * @param {PrivilegeDeleteArgs} args - Arguments to delete one Privilege.
     * @example
     * // Delete one Privilege
     * const Privilege = await prisma.privilege.delete({
     *   where: {
     *     // ... filter to delete one Privilege
     *   }
     * })
     * 
     */
    delete<T extends PrivilegeDeleteArgs>(args: SelectSubset<T, PrivilegeDeleteArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Privilege.
     * @param {PrivilegeUpdateArgs} args - Arguments to update one Privilege.
     * @example
     * // Update one Privilege
     * const privilege = await prisma.privilege.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivilegeUpdateArgs>(args: SelectSubset<T, PrivilegeUpdateArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Privileges.
     * @param {PrivilegeDeleteManyArgs} args - Arguments to filter Privileges to delete.
     * @example
     * // Delete a few Privileges
     * const { count } = await prisma.privilege.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivilegeDeleteManyArgs>(args?: SelectSubset<T, PrivilegeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Privileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Privileges
     * const privilege = await prisma.privilege.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivilegeUpdateManyArgs>(args: SelectSubset<T, PrivilegeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Privilege.
     * @param {PrivilegeUpsertArgs} args - Arguments to update or create a Privilege.
     * @example
     * // Update or create a Privilege
     * const privilege = await prisma.privilege.upsert({
     *   create: {
     *     // ... data to create a Privilege
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Privilege we want to update
     *   }
     * })
     */
    upsert<T extends PrivilegeUpsertArgs>(args: SelectSubset<T, PrivilegeUpsertArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Privileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeCountArgs} args - Arguments to filter Privileges to count.
     * @example
     * // Count the number of Privileges
     * const count = await prisma.privilege.count({
     *   where: {
     *     // ... the filter for the Privileges we want to count
     *   }
     * })
    **/
    count<T extends PrivilegeCountArgs>(
      args?: Subset<T, PrivilegeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivilegeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Privilege.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivilegeAggregateArgs>(args: Subset<T, PrivilegeAggregateArgs>): Prisma.PrismaPromise<GetPrivilegeAggregateType<T>>

    /**
     * Group by Privilege.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivilegeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivilegeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivilegeGroupByArgs['orderBy'] }
        : { orderBy?: PrivilegeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivilegeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivilegeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Privilege model
   */
  readonly fields: PrivilegeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Privilege.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivilegeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserPrivilege<T extends Privilege$UserPrivilegeArgs<ExtArgs> = {}>(args?: Subset<T, Privilege$UserPrivilegeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Privilege model
   */ 
  interface PrivilegeFieldRefs {
    readonly id: FieldRef<"Privilege", 'String'>
    readonly name: FieldRef<"Privilege", 'String'>
    readonly label: FieldRef<"Privilege", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Privilege findUnique
   */
  export type PrivilegeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privilege to fetch.
     */
    where: PrivilegeWhereUniqueInput
  }

  /**
   * Privilege findUniqueOrThrow
   */
  export type PrivilegeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privilege to fetch.
     */
    where: PrivilegeWhereUniqueInput
  }

  /**
   * Privilege findFirst
   */
  export type PrivilegeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privilege to fetch.
     */
    where?: PrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privileges to fetch.
     */
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Privileges.
     */
    cursor?: PrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Privileges.
     */
    distinct?: PrivilegeScalarFieldEnum | PrivilegeScalarFieldEnum[]
  }

  /**
   * Privilege findFirstOrThrow
   */
  export type PrivilegeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privilege to fetch.
     */
    where?: PrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privileges to fetch.
     */
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Privileges.
     */
    cursor?: PrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Privileges.
     */
    distinct?: PrivilegeScalarFieldEnum | PrivilegeScalarFieldEnum[]
  }

  /**
   * Privilege findMany
   */
  export type PrivilegeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which Privileges to fetch.
     */
    where?: PrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Privileges to fetch.
     */
    orderBy?: PrivilegeOrderByWithRelationInput | PrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Privileges.
     */
    cursor?: PrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Privileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Privileges.
     */
    skip?: number
    distinct?: PrivilegeScalarFieldEnum | PrivilegeScalarFieldEnum[]
  }

  /**
   * Privilege create
   */
  export type PrivilegeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * The data needed to create a Privilege.
     */
    data: XOR<PrivilegeCreateInput, PrivilegeUncheckedCreateInput>
  }

  /**
   * Privilege createMany
   */
  export type PrivilegeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Privileges.
     */
    data: PrivilegeCreateManyInput | PrivilegeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Privilege update
   */
  export type PrivilegeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * The data needed to update a Privilege.
     */
    data: XOR<PrivilegeUpdateInput, PrivilegeUncheckedUpdateInput>
    /**
     * Choose, which Privilege to update.
     */
    where: PrivilegeWhereUniqueInput
  }

  /**
   * Privilege updateMany
   */
  export type PrivilegeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Privileges.
     */
    data: XOR<PrivilegeUpdateManyMutationInput, PrivilegeUncheckedUpdateManyInput>
    /**
     * Filter which Privileges to update
     */
    where?: PrivilegeWhereInput
    /**
     * Limit how many Privileges to update.
     */
    limit?: number
  }

  /**
   * Privilege upsert
   */
  export type PrivilegeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * The filter to search for the Privilege to update in case it exists.
     */
    where: PrivilegeWhereUniqueInput
    /**
     * In case the Privilege found by the `where` argument doesn't exist, create a new Privilege with this data.
     */
    create: XOR<PrivilegeCreateInput, PrivilegeUncheckedCreateInput>
    /**
     * In case the Privilege was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivilegeUpdateInput, PrivilegeUncheckedUpdateInput>
  }

  /**
   * Privilege delete
   */
  export type PrivilegeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
    /**
     * Filter which Privilege to delete.
     */
    where: PrivilegeWhereUniqueInput
  }

  /**
   * Privilege deleteMany
   */
  export type PrivilegeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Privileges to delete
     */
    where?: PrivilegeWhereInput
    /**
     * Limit how many Privileges to delete.
     */
    limit?: number
  }

  /**
   * Privilege.UserPrivilege
   */
  export type Privilege$UserPrivilegeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    where?: UserPrivilegeWhereInput
    orderBy?: UserPrivilegeOrderByWithRelationInput | UserPrivilegeOrderByWithRelationInput[]
    cursor?: UserPrivilegeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPrivilegeScalarFieldEnum | UserPrivilegeScalarFieldEnum[]
  }

  /**
   * Privilege without action
   */
  export type PrivilegeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Privilege
     */
    select?: PrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Privilege
     */
    omit?: PrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivilegeInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    estimatedDeliveryDay: number | null
    views: number | null
    displayPrice: number | null
  }

  export type ProductSumAggregateOutputType = {
    estimatedDeliveryDay: number | null
    views: number | null
    displayPrice: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    slug: string | null
    isReturnable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    thumbnailUrl: string | null
    isActive: boolean | null
    description: string | null
    summary: string | null
    customerTypeId: string | null
    userId: string | null
    estimatedDeliveryDay: number | null
    styleId: string | null
    title: string | null
    returnPolicy: string | null
    views: number | null
    displayPrice: number | null
    longTailKeyword: string | null
    affiliateId: string | null
    isCODAvailable: boolean | null
    ogImage: string | null
    sellerCode: string | null
    sizeChartId: string | null
    fabricId: string | null
    seoTitle: string | null
    seoDescription: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    isReturnable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    thumbnailUrl: string | null
    isActive: boolean | null
    description: string | null
    summary: string | null
    customerTypeId: string | null
    userId: string | null
    estimatedDeliveryDay: number | null
    styleId: string | null
    title: string | null
    returnPolicy: string | null
    views: number | null
    displayPrice: number | null
    longTailKeyword: string | null
    affiliateId: string | null
    isCODAvailable: boolean | null
    ogImage: string | null
    sellerCode: string | null
    sizeChartId: string | null
    fabricId: string | null
    seoTitle: string | null
    seoDescription: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    slug: number
    isReturnable: number
    createdAt: number
    updatedAt: number
    thumbnailUrl: number
    isActive: number
    description: number
    summary: number
    customerTypeId: number
    userId: number
    estimatedDeliveryDay: number
    styleId: number
    title: number
    returnPolicy: number
    views: number
    displayPrice: number
    tags: number
    longTailKeyword: number
    affiliateId: number
    isCODAvailable: number
    ogImage: number
    sellerCode: number
    sizeChartId: number
    fabricId: number
    seoTitle: number
    seoDescription: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    estimatedDeliveryDay?: true
    views?: true
    displayPrice?: true
  }

  export type ProductSumAggregateInputType = {
    estimatedDeliveryDay?: true
    views?: true
    displayPrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    slug?: true
    isReturnable?: true
    createdAt?: true
    updatedAt?: true
    thumbnailUrl?: true
    isActive?: true
    description?: true
    summary?: true
    customerTypeId?: true
    userId?: true
    estimatedDeliveryDay?: true
    styleId?: true
    title?: true
    returnPolicy?: true
    views?: true
    displayPrice?: true
    longTailKeyword?: true
    affiliateId?: true
    isCODAvailable?: true
    ogImage?: true
    sellerCode?: true
    sizeChartId?: true
    fabricId?: true
    seoTitle?: true
    seoDescription?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    slug?: true
    isReturnable?: true
    createdAt?: true
    updatedAt?: true
    thumbnailUrl?: true
    isActive?: true
    description?: true
    summary?: true
    customerTypeId?: true
    userId?: true
    estimatedDeliveryDay?: true
    styleId?: true
    title?: true
    returnPolicy?: true
    views?: true
    displayPrice?: true
    longTailKeyword?: true
    affiliateId?: true
    isCODAvailable?: true
    ogImage?: true
    sellerCode?: true
    sizeChartId?: true
    fabricId?: true
    seoTitle?: true
    seoDescription?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    slug?: true
    isReturnable?: true
    createdAt?: true
    updatedAt?: true
    thumbnailUrl?: true
    isActive?: true
    description?: true
    summary?: true
    customerTypeId?: true
    userId?: true
    estimatedDeliveryDay?: true
    styleId?: true
    title?: true
    returnPolicy?: true
    views?: true
    displayPrice?: true
    tags?: true
    longTailKeyword?: true
    affiliateId?: true
    isCODAvailable?: true
    ogImage?: true
    sellerCode?: true
    sizeChartId?: true
    fabricId?: true
    seoTitle?: true
    seoDescription?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    slug: string
    isReturnable: boolean
    createdAt: Date
    updatedAt: Date
    thumbnailUrl: string
    isActive: boolean
    description: string | null
    summary: string | null
    customerTypeId: string | null
    userId: string
    estimatedDeliveryDay: number | null
    styleId: string
    title: string
    returnPolicy: string | null
    views: number
    displayPrice: number
    tags: JsonValue
    longTailKeyword: string | null
    affiliateId: string
    isCODAvailable: boolean
    ogImage: string | null
    sellerCode: string | null
    sizeChartId: string | null
    fabricId: string | null
    seoTitle: string | null
    seoDescription: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    isReturnable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thumbnailUrl?: boolean
    isActive?: boolean
    description?: boolean
    summary?: boolean
    customerTypeId?: boolean
    userId?: boolean
    estimatedDeliveryDay?: boolean
    styleId?: boolean
    title?: boolean
    returnPolicy?: boolean
    views?: boolean
    displayPrice?: boolean
    tags?: boolean
    longTailKeyword?: boolean
    affiliateId?: boolean
    isCODAvailable?: boolean
    ogImage?: boolean
    sellerCode?: boolean
    sizeChartId?: boolean
    fabricId?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    CartItem?: boolean | Product$CartItemArgs<ExtArgs>
    Discount?: boolean | Product$DiscountArgs<ExtArgs>
    OrderItem?: boolean | Product$OrderItemArgs<ExtArgs>
    CustomerType?: boolean | Product$CustomerTypeArgs<ExtArgs>
    ProductFabric?: boolean | Product$ProductFabricArgs<ExtArgs>
    SizeChart?: boolean | Product$SizeChartArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ProductImage?: boolean | Product$ProductImageArgs<ExtArgs>
    ProductInventory?: boolean | Product$ProductInventoryArgs<ExtArgs>
    ProductReview?: boolean | Product$ProductReviewArgs<ExtArgs>
    WishlistItem?: boolean | Product$WishlistItemArgs<ExtArgs>
    ProductCategory?: boolean | Product$ProductCategoryArgs<ExtArgs>
    Product_A?: boolean | Product$Product_AArgs<ExtArgs>
    Product_B?: boolean | Product$Product_BArgs<ExtArgs>
    SubCategory?: boolean | Product$SubCategoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    slug?: boolean
    isReturnable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thumbnailUrl?: boolean
    isActive?: boolean
    description?: boolean
    summary?: boolean
    customerTypeId?: boolean
    userId?: boolean
    estimatedDeliveryDay?: boolean
    styleId?: boolean
    title?: boolean
    returnPolicy?: boolean
    views?: boolean
    displayPrice?: boolean
    tags?: boolean
    longTailKeyword?: boolean
    affiliateId?: boolean
    isCODAvailable?: boolean
    ogImage?: boolean
    sellerCode?: boolean
    sizeChartId?: boolean
    fabricId?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "isReturnable" | "createdAt" | "updatedAt" | "thumbnailUrl" | "isActive" | "description" | "summary" | "customerTypeId" | "userId" | "estimatedDeliveryDay" | "styleId" | "title" | "returnPolicy" | "views" | "displayPrice" | "tags" | "longTailKeyword" | "affiliateId" | "isCODAvailable" | "ogImage" | "sellerCode" | "sizeChartId" | "fabricId" | "seoTitle" | "seoDescription", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CartItem?: boolean | Product$CartItemArgs<ExtArgs>
    Discount?: boolean | Product$DiscountArgs<ExtArgs>
    OrderItem?: boolean | Product$OrderItemArgs<ExtArgs>
    CustomerType?: boolean | Product$CustomerTypeArgs<ExtArgs>
    ProductFabric?: boolean | Product$ProductFabricArgs<ExtArgs>
    SizeChart?: boolean | Product$SizeChartArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ProductImage?: boolean | Product$ProductImageArgs<ExtArgs>
    ProductInventory?: boolean | Product$ProductInventoryArgs<ExtArgs>
    ProductReview?: boolean | Product$ProductReviewArgs<ExtArgs>
    WishlistItem?: boolean | Product$WishlistItemArgs<ExtArgs>
    ProductCategory?: boolean | Product$ProductCategoryArgs<ExtArgs>
    Product_A?: boolean | Product$Product_AArgs<ExtArgs>
    Product_B?: boolean | Product$Product_BArgs<ExtArgs>
    SubCategory?: boolean | Product$SubCategoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      CartItem: Prisma.$CartItemPayload<ExtArgs>[]
      Discount: Prisma.$DiscountPayload<ExtArgs>[]
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
      CustomerType: Prisma.$CustomerTypePayload<ExtArgs> | null
      ProductFabric: Prisma.$ProductFabricPayload<ExtArgs> | null
      SizeChart: Prisma.$SizeChartPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
      ProductImage: Prisma.$ProductImagePayload<ExtArgs>[]
      ProductInventory: Prisma.$ProductInventoryPayload<ExtArgs>[]
      ProductReview: Prisma.$ProductReviewPayload<ExtArgs>[]
      WishlistItem: Prisma.$WishlistItemPayload<ExtArgs>[]
      ProductCategory: Prisma.$ProductCategoryPayload<ExtArgs>[]
      Product_A: Prisma.$ProductPayload<ExtArgs>[]
      Product_B: Prisma.$ProductPayload<ExtArgs>[]
      SubCategory: Prisma.$SubCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      isReturnable: boolean
      createdAt: Date
      updatedAt: Date
      thumbnailUrl: string
      isActive: boolean
      description: string | null
      summary: string | null
      customerTypeId: string | null
      userId: string
      estimatedDeliveryDay: number | null
      styleId: string
      title: string
      returnPolicy: string | null
      views: number
      displayPrice: number
      tags: Prisma.JsonValue
      longTailKeyword: string | null
      affiliateId: string
      isCODAvailable: boolean
      ogImage: string | null
      sellerCode: string | null
      sizeChartId: string | null
      fabricId: string | null
      seoTitle: string | null
      seoDescription: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CartItem<T extends Product$CartItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$CartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Discount<T extends Product$DiscountArgs<ExtArgs> = {}>(args?: Subset<T, Product$DiscountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OrderItem<T extends Product$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CustomerType<T extends Product$CustomerTypeArgs<ExtArgs> = {}>(args?: Subset<T, Product$CustomerTypeArgs<ExtArgs>>): Prisma__CustomerTypeClient<$Result.GetResult<Prisma.$CustomerTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ProductFabric<T extends Product$ProductFabricArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductFabricArgs<ExtArgs>>): Prisma__ProductFabricClient<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SizeChart<T extends Product$SizeChartArgs<ExtArgs> = {}>(args?: Subset<T, Product$SizeChartArgs<ExtArgs>>): Prisma__SizeChartClient<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProductImage<T extends Product$ProductImageArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductImageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductInventory<T extends Product$ProductInventoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductInventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductReview<T extends Product$ProductReviewArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WishlistItem<T extends Product$WishlistItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$WishlistItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductCategory<T extends Product$ProductCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Product_A<T extends Product$Product_AArgs<ExtArgs> = {}>(args?: Subset<T, Product$Product_AArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Product_B<T extends Product$Product_BArgs<ExtArgs> = {}>(args?: Subset<T, Product$Product_BArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SubCategory<T extends Product$SubCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$SubCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly isReturnable: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly thumbnailUrl: FieldRef<"Product", 'String'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly description: FieldRef<"Product", 'String'>
    readonly summary: FieldRef<"Product", 'String'>
    readonly customerTypeId: FieldRef<"Product", 'String'>
    readonly userId: FieldRef<"Product", 'String'>
    readonly estimatedDeliveryDay: FieldRef<"Product", 'Int'>
    readonly styleId: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly returnPolicy: FieldRef<"Product", 'String'>
    readonly views: FieldRef<"Product", 'Int'>
    readonly displayPrice: FieldRef<"Product", 'Float'>
    readonly tags: FieldRef<"Product", 'Json'>
    readonly longTailKeyword: FieldRef<"Product", 'String'>
    readonly affiliateId: FieldRef<"Product", 'String'>
    readonly isCODAvailable: FieldRef<"Product", 'Boolean'>
    readonly ogImage: FieldRef<"Product", 'String'>
    readonly sellerCode: FieldRef<"Product", 'String'>
    readonly sizeChartId: FieldRef<"Product", 'String'>
    readonly fabricId: FieldRef<"Product", 'String'>
    readonly seoTitle: FieldRef<"Product", 'String'>
    readonly seoDescription: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.CartItem
   */
  export type Product$CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.Discount
   */
  export type Product$DiscountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    cursor?: DiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Product.OrderItem
   */
  export type Product$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.CustomerType
   */
  export type Product$CustomerTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerType
     */
    select?: CustomerTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerType
     */
    omit?: CustomerTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerTypeInclude<ExtArgs> | null
    where?: CustomerTypeWhereInput
  }

  /**
   * Product.ProductFabric
   */
  export type Product$ProductFabricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    where?: ProductFabricWhereInput
  }

  /**
   * Product.SizeChart
   */
  export type Product$SizeChartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    where?: SizeChartWhereInput
  }

  /**
   * Product.ProductImage
   */
  export type Product$ProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * Product.ProductInventory
   */
  export type Product$ProductInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    where?: ProductInventoryWhereInput
    orderBy?: ProductInventoryOrderByWithRelationInput | ProductInventoryOrderByWithRelationInput[]
    cursor?: ProductInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductInventoryScalarFieldEnum | ProductInventoryScalarFieldEnum[]
  }

  /**
   * Product.ProductReview
   */
  export type Product$ProductReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    where?: ProductReviewWhereInput
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    cursor?: ProductReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * Product.WishlistItem
   */
  export type Product$WishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * Product.ProductCategory
   */
  export type Product$ProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Product.Product_A
   */
  export type Product$Product_AArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product.Product_B
   */
  export type Product$Product_BArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product.SubCategory
   */
  export type Product$SubCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    cursor?: SubCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    isVisible: boolean | null
    seoTitle: string | null
    seoDescription: string | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    isVisible: boolean | null
    seoTitle: string | null
    seoDescription: string | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    isVisible: number
    seoTitle: number
    seoDescription: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    isVisible?: true
    seoTitle?: true
    seoDescription?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    isVisible?: true
    seoTitle?: true
    seoDescription?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    isVisible?: true
    seoTitle?: true
    seoDescription?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    isVisible: boolean
    seoTitle: string | null
    seoDescription: string | null
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    isVisible?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    AnchorText?: boolean | ProductCategory$AnchorTextArgs<ExtArgs>
    Quotes?: boolean | ProductCategory$QuotesArgs<ExtArgs>
    SubCategory?: boolean | ProductCategory$SubCategoryArgs<ExtArgs>
    Product?: boolean | ProductCategory$ProductArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>



  export type ProductCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    isVisible?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "isVisible" | "seoTitle" | "seoDescription", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AnchorText?: boolean | ProductCategory$AnchorTextArgs<ExtArgs>
    Quotes?: boolean | ProductCategory$QuotesArgs<ExtArgs>
    SubCategory?: boolean | ProductCategory$SubCategoryArgs<ExtArgs>
    Product?: boolean | ProductCategory$ProductArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      AnchorText: Prisma.$AnchorTextPayload<ExtArgs> | null
      Quotes: Prisma.$QuotesPayload<ExtArgs>[]
      SubCategory: Prisma.$SubCategoryPayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      isVisible: boolean
      seoTitle: string | null
      seoDescription: string | null
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AnchorText<T extends ProductCategory$AnchorTextArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$AnchorTextArgs<ExtArgs>>): Prisma__AnchorTextClient<$Result.GetResult<Prisma.$AnchorTextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Quotes<T extends ProductCategory$QuotesArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$QuotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SubCategory<T extends ProductCategory$SubCategoryArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$SubCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Product<T extends ProductCategory$ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */ 
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly slug: FieldRef<"ProductCategory", 'String'>
    readonly isVisible: FieldRef<"ProductCategory", 'Boolean'>
    readonly seoTitle: FieldRef<"ProductCategory", 'String'>
    readonly seoDescription: FieldRef<"ProductCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.AnchorText
   */
  export type ProductCategory$AnchorTextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnchorText
     */
    select?: AnchorTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnchorText
     */
    omit?: AnchorTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnchorTextInclude<ExtArgs> | null
    where?: AnchorTextWhereInput
  }

  /**
   * ProductCategory.Quotes
   */
  export type ProductCategory$QuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    where?: QuotesWhereInput
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    cursor?: QuotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * ProductCategory.SubCategory
   */
  export type ProductCategory$SubCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    cursor?: SubCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory.Product
   */
  export type ProductCategory$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductColor
   */

  export type AggregateProductColor = {
    _count: ProductColorCountAggregateOutputType | null
    _min: ProductColorMinAggregateOutputType | null
    _max: ProductColorMaxAggregateOutputType | null
  }

  export type ProductColorMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    slug: string | null
  }

  export type ProductColorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    slug: string | null
  }

  export type ProductColorCountAggregateOutputType = {
    id: number
    name: number
    code: number
    slug: number
    _all: number
  }


  export type ProductColorMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    slug?: true
  }

  export type ProductColorMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    slug?: true
  }

  export type ProductColorCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    slug?: true
    _all?: true
  }

  export type ProductColorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductColor to aggregate.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: ProductColorOrderByWithRelationInput | ProductColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductColors
    **/
    _count?: true | ProductColorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductColorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductColorMaxAggregateInputType
  }

  export type GetProductColorAggregateType<T extends ProductColorAggregateArgs> = {
        [P in keyof T & keyof AggregateProductColor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductColor[P]>
      : GetScalarType<T[P], AggregateProductColor[P]>
  }




  export type ProductColorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductColorWhereInput
    orderBy?: ProductColorOrderByWithAggregationInput | ProductColorOrderByWithAggregationInput[]
    by: ProductColorScalarFieldEnum[] | ProductColorScalarFieldEnum
    having?: ProductColorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductColorCountAggregateInputType | true
    _min?: ProductColorMinAggregateInputType
    _max?: ProductColorMaxAggregateInputType
  }

  export type ProductColorGroupByOutputType = {
    id: string
    name: string
    code: string
    slug: string
    _count: ProductColorCountAggregateOutputType | null
    _min: ProductColorMinAggregateOutputType | null
    _max: ProductColorMaxAggregateOutputType | null
  }

  type GetProductColorGroupByPayload<T extends ProductColorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductColorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductColorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductColorGroupByOutputType[P]>
            : GetScalarType<T[P], ProductColorGroupByOutputType[P]>
        }
      >
    >


  export type ProductColorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    slug?: boolean
    CartItem?: boolean | ProductColor$CartItemArgs<ExtArgs>
    OrderItem?: boolean | ProductColor$OrderItemArgs<ExtArgs>
    ProductImage?: boolean | ProductColor$ProductImageArgs<ExtArgs>
    _count?: boolean | ProductColorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productColor"]>



  export type ProductColorSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    slug?: boolean
  }

  export type ProductColorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "slug", ExtArgs["result"]["productColor"]>
  export type ProductColorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CartItem?: boolean | ProductColor$CartItemArgs<ExtArgs>
    OrderItem?: boolean | ProductColor$OrderItemArgs<ExtArgs>
    ProductImage?: boolean | ProductColor$ProductImageArgs<ExtArgs>
    _count?: boolean | ProductColorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductColorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductColor"
    objects: {
      CartItem: Prisma.$CartItemPayload<ExtArgs>[]
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
      ProductImage: Prisma.$ProductImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      slug: string
    }, ExtArgs["result"]["productColor"]>
    composites: {}
  }

  type ProductColorGetPayload<S extends boolean | null | undefined | ProductColorDefaultArgs> = $Result.GetResult<Prisma.$ProductColorPayload, S>

  type ProductColorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductColorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductColorCountAggregateInputType | true
    }

  export interface ProductColorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductColor'], meta: { name: 'ProductColor' } }
    /**
     * Find zero or one ProductColor that matches the filter.
     * @param {ProductColorFindUniqueArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductColorFindUniqueArgs>(args: SelectSubset<T, ProductColorFindUniqueArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductColor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductColorFindUniqueOrThrowArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductColorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductColorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductColor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorFindFirstArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductColorFindFirstArgs>(args?: SelectSubset<T, ProductColorFindFirstArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductColor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorFindFirstOrThrowArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductColorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductColorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductColors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductColors
     * const productColors = await prisma.productColor.findMany()
     * 
     * // Get first 10 ProductColors
     * const productColors = await prisma.productColor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productColorWithIdOnly = await prisma.productColor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductColorFindManyArgs>(args?: SelectSubset<T, ProductColorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductColor.
     * @param {ProductColorCreateArgs} args - Arguments to create a ProductColor.
     * @example
     * // Create one ProductColor
     * const ProductColor = await prisma.productColor.create({
     *   data: {
     *     // ... data to create a ProductColor
     *   }
     * })
     * 
     */
    create<T extends ProductColorCreateArgs>(args: SelectSubset<T, ProductColorCreateArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductColors.
     * @param {ProductColorCreateManyArgs} args - Arguments to create many ProductColors.
     * @example
     * // Create many ProductColors
     * const productColor = await prisma.productColor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductColorCreateManyArgs>(args?: SelectSubset<T, ProductColorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductColor.
     * @param {ProductColorDeleteArgs} args - Arguments to delete one ProductColor.
     * @example
     * // Delete one ProductColor
     * const ProductColor = await prisma.productColor.delete({
     *   where: {
     *     // ... filter to delete one ProductColor
     *   }
     * })
     * 
     */
    delete<T extends ProductColorDeleteArgs>(args: SelectSubset<T, ProductColorDeleteArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductColor.
     * @param {ProductColorUpdateArgs} args - Arguments to update one ProductColor.
     * @example
     * // Update one ProductColor
     * const productColor = await prisma.productColor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductColorUpdateArgs>(args: SelectSubset<T, ProductColorUpdateArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductColors.
     * @param {ProductColorDeleteManyArgs} args - Arguments to filter ProductColors to delete.
     * @example
     * // Delete a few ProductColors
     * const { count } = await prisma.productColor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductColorDeleteManyArgs>(args?: SelectSubset<T, ProductColorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductColors
     * const productColor = await prisma.productColor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductColorUpdateManyArgs>(args: SelectSubset<T, ProductColorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductColor.
     * @param {ProductColorUpsertArgs} args - Arguments to update or create a ProductColor.
     * @example
     * // Update or create a ProductColor
     * const productColor = await prisma.productColor.upsert({
     *   create: {
     *     // ... data to create a ProductColor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductColor we want to update
     *   }
     * })
     */
    upsert<T extends ProductColorUpsertArgs>(args: SelectSubset<T, ProductColorUpsertArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorCountArgs} args - Arguments to filter ProductColors to count.
     * @example
     * // Count the number of ProductColors
     * const count = await prisma.productColor.count({
     *   where: {
     *     // ... the filter for the ProductColors we want to count
     *   }
     * })
    **/
    count<T extends ProductColorCountArgs>(
      args?: Subset<T, ProductColorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductColorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductColor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductColorAggregateArgs>(args: Subset<T, ProductColorAggregateArgs>): Prisma.PrismaPromise<GetProductColorAggregateType<T>>

    /**
     * Group by ProductColor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductColorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductColorGroupByArgs['orderBy'] }
        : { orderBy?: ProductColorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductColorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductColorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductColor model
   */
  readonly fields: ProductColorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductColor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductColorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CartItem<T extends ProductColor$CartItemArgs<ExtArgs> = {}>(args?: Subset<T, ProductColor$CartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OrderItem<T extends ProductColor$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, ProductColor$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductImage<T extends ProductColor$ProductImageArgs<ExtArgs> = {}>(args?: Subset<T, ProductColor$ProductImageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductColor model
   */ 
  interface ProductColorFieldRefs {
    readonly id: FieldRef<"ProductColor", 'String'>
    readonly name: FieldRef<"ProductColor", 'String'>
    readonly code: FieldRef<"ProductColor", 'String'>
    readonly slug: FieldRef<"ProductColor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductColor findUnique
   */
  export type ProductColorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where: ProductColorWhereUniqueInput
  }

  /**
   * ProductColor findUniqueOrThrow
   */
  export type ProductColorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where: ProductColorWhereUniqueInput
  }

  /**
   * ProductColor findFirst
   */
  export type ProductColorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: ProductColorOrderByWithRelationInput | ProductColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductColors.
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductColors.
     */
    distinct?: ProductColorScalarFieldEnum | ProductColorScalarFieldEnum[]
  }

  /**
   * ProductColor findFirstOrThrow
   */
  export type ProductColorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: ProductColorOrderByWithRelationInput | ProductColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductColors.
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductColors.
     */
    distinct?: ProductColorScalarFieldEnum | ProductColorScalarFieldEnum[]
  }

  /**
   * ProductColor findMany
   */
  export type ProductColorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColors to fetch.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: ProductColorOrderByWithRelationInput | ProductColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductColors.
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    distinct?: ProductColorScalarFieldEnum | ProductColorScalarFieldEnum[]
  }

  /**
   * ProductColor create
   */
  export type ProductColorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductColor.
     */
    data: XOR<ProductColorCreateInput, ProductColorUncheckedCreateInput>
  }

  /**
   * ProductColor createMany
   */
  export type ProductColorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductColors.
     */
    data: ProductColorCreateManyInput | ProductColorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductColor update
   */
  export type ProductColorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductColor.
     */
    data: XOR<ProductColorUpdateInput, ProductColorUncheckedUpdateInput>
    /**
     * Choose, which ProductColor to update.
     */
    where: ProductColorWhereUniqueInput
  }

  /**
   * ProductColor updateMany
   */
  export type ProductColorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductColors.
     */
    data: XOR<ProductColorUpdateManyMutationInput, ProductColorUncheckedUpdateManyInput>
    /**
     * Filter which ProductColors to update
     */
    where?: ProductColorWhereInput
    /**
     * Limit how many ProductColors to update.
     */
    limit?: number
  }

  /**
   * ProductColor upsert
   */
  export type ProductColorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductColor to update in case it exists.
     */
    where: ProductColorWhereUniqueInput
    /**
     * In case the ProductColor found by the `where` argument doesn't exist, create a new ProductColor with this data.
     */
    create: XOR<ProductColorCreateInput, ProductColorUncheckedCreateInput>
    /**
     * In case the ProductColor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductColorUpdateInput, ProductColorUncheckedUpdateInput>
  }

  /**
   * ProductColor delete
   */
  export type ProductColorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter which ProductColor to delete.
     */
    where: ProductColorWhereUniqueInput
  }

  /**
   * ProductColor deleteMany
   */
  export type ProductColorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductColors to delete
     */
    where?: ProductColorWhereInput
    /**
     * Limit how many ProductColors to delete.
     */
    limit?: number
  }

  /**
   * ProductColor.CartItem
   */
  export type ProductColor$CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * ProductColor.OrderItem
   */
  export type ProductColor$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * ProductColor.ProductImage
   */
  export type ProductColor$ProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductColor without action
   */
  export type ProductColorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
  }


  /**
   * Model ProductFabric
   */

  export type AggregateProductFabric = {
    _count: ProductFabricCountAggregateOutputType | null
    _min: ProductFabricMinAggregateOutputType | null
    _max: ProductFabricMaxAggregateOutputType | null
  }

  export type ProductFabricMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type ProductFabricMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type ProductFabricCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type ProductFabricMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type ProductFabricMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type ProductFabricCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type ProductFabricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductFabric to aggregate.
     */
    where?: ProductFabricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFabrics to fetch.
     */
    orderBy?: ProductFabricOrderByWithRelationInput | ProductFabricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductFabricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFabrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFabrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductFabrics
    **/
    _count?: true | ProductFabricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductFabricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductFabricMaxAggregateInputType
  }

  export type GetProductFabricAggregateType<T extends ProductFabricAggregateArgs> = {
        [P in keyof T & keyof AggregateProductFabric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductFabric[P]>
      : GetScalarType<T[P], AggregateProductFabric[P]>
  }




  export type ProductFabricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductFabricWhereInput
    orderBy?: ProductFabricOrderByWithAggregationInput | ProductFabricOrderByWithAggregationInput[]
    by: ProductFabricScalarFieldEnum[] | ProductFabricScalarFieldEnum
    having?: ProductFabricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductFabricCountAggregateInputType | true
    _min?: ProductFabricMinAggregateInputType
    _max?: ProductFabricMaxAggregateInputType
  }

  export type ProductFabricGroupByOutputType = {
    id: string
    name: string
    slug: string
    _count: ProductFabricCountAggregateOutputType | null
    _min: ProductFabricMinAggregateOutputType | null
    _max: ProductFabricMaxAggregateOutputType | null
  }

  type GetProductFabricGroupByPayload<T extends ProductFabricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductFabricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductFabricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductFabricGroupByOutputType[P]>
            : GetScalarType<T[P], ProductFabricGroupByOutputType[P]>
        }
      >
    >


  export type ProductFabricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    Product?: boolean | ProductFabric$ProductArgs<ExtArgs>
    _count?: boolean | ProductFabricCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productFabric"]>



  export type ProductFabricSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
  }

  export type ProductFabricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug", ExtArgs["result"]["productFabric"]>
  export type ProductFabricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductFabric$ProductArgs<ExtArgs>
    _count?: boolean | ProductFabricCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductFabricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductFabric"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
    }, ExtArgs["result"]["productFabric"]>
    composites: {}
  }

  type ProductFabricGetPayload<S extends boolean | null | undefined | ProductFabricDefaultArgs> = $Result.GetResult<Prisma.$ProductFabricPayload, S>

  type ProductFabricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFabricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductFabricCountAggregateInputType | true
    }

  export interface ProductFabricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductFabric'], meta: { name: 'ProductFabric' } }
    /**
     * Find zero or one ProductFabric that matches the filter.
     * @param {ProductFabricFindUniqueArgs} args - Arguments to find a ProductFabric
     * @example
     * // Get one ProductFabric
     * const productFabric = await prisma.productFabric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFabricFindUniqueArgs>(args: SelectSubset<T, ProductFabricFindUniqueArgs<ExtArgs>>): Prisma__ProductFabricClient<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductFabric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFabricFindUniqueOrThrowArgs} args - Arguments to find a ProductFabric
     * @example
     * // Get one ProductFabric
     * const productFabric = await prisma.productFabric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFabricFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFabricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductFabricClient<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductFabric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFabricFindFirstArgs} args - Arguments to find a ProductFabric
     * @example
     * // Get one ProductFabric
     * const productFabric = await prisma.productFabric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFabricFindFirstArgs>(args?: SelectSubset<T, ProductFabricFindFirstArgs<ExtArgs>>): Prisma__ProductFabricClient<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductFabric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFabricFindFirstOrThrowArgs} args - Arguments to find a ProductFabric
     * @example
     * // Get one ProductFabric
     * const productFabric = await prisma.productFabric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFabricFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFabricFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductFabricClient<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductFabrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFabricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductFabrics
     * const productFabrics = await prisma.productFabric.findMany()
     * 
     * // Get first 10 ProductFabrics
     * const productFabrics = await prisma.productFabric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productFabricWithIdOnly = await prisma.productFabric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFabricFindManyArgs>(args?: SelectSubset<T, ProductFabricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductFabric.
     * @param {ProductFabricCreateArgs} args - Arguments to create a ProductFabric.
     * @example
     * // Create one ProductFabric
     * const ProductFabric = await prisma.productFabric.create({
     *   data: {
     *     // ... data to create a ProductFabric
     *   }
     * })
     * 
     */
    create<T extends ProductFabricCreateArgs>(args: SelectSubset<T, ProductFabricCreateArgs<ExtArgs>>): Prisma__ProductFabricClient<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductFabrics.
     * @param {ProductFabricCreateManyArgs} args - Arguments to create many ProductFabrics.
     * @example
     * // Create many ProductFabrics
     * const productFabric = await prisma.productFabric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductFabricCreateManyArgs>(args?: SelectSubset<T, ProductFabricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductFabric.
     * @param {ProductFabricDeleteArgs} args - Arguments to delete one ProductFabric.
     * @example
     * // Delete one ProductFabric
     * const ProductFabric = await prisma.productFabric.delete({
     *   where: {
     *     // ... filter to delete one ProductFabric
     *   }
     * })
     * 
     */
    delete<T extends ProductFabricDeleteArgs>(args: SelectSubset<T, ProductFabricDeleteArgs<ExtArgs>>): Prisma__ProductFabricClient<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductFabric.
     * @param {ProductFabricUpdateArgs} args - Arguments to update one ProductFabric.
     * @example
     * // Update one ProductFabric
     * const productFabric = await prisma.productFabric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductFabricUpdateArgs>(args: SelectSubset<T, ProductFabricUpdateArgs<ExtArgs>>): Prisma__ProductFabricClient<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductFabrics.
     * @param {ProductFabricDeleteManyArgs} args - Arguments to filter ProductFabrics to delete.
     * @example
     * // Delete a few ProductFabrics
     * const { count } = await prisma.productFabric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductFabricDeleteManyArgs>(args?: SelectSubset<T, ProductFabricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductFabrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFabricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductFabrics
     * const productFabric = await prisma.productFabric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductFabricUpdateManyArgs>(args: SelectSubset<T, ProductFabricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductFabric.
     * @param {ProductFabricUpsertArgs} args - Arguments to update or create a ProductFabric.
     * @example
     * // Update or create a ProductFabric
     * const productFabric = await prisma.productFabric.upsert({
     *   create: {
     *     // ... data to create a ProductFabric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductFabric we want to update
     *   }
     * })
     */
    upsert<T extends ProductFabricUpsertArgs>(args: SelectSubset<T, ProductFabricUpsertArgs<ExtArgs>>): Prisma__ProductFabricClient<$Result.GetResult<Prisma.$ProductFabricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductFabrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFabricCountArgs} args - Arguments to filter ProductFabrics to count.
     * @example
     * // Count the number of ProductFabrics
     * const count = await prisma.productFabric.count({
     *   where: {
     *     // ... the filter for the ProductFabrics we want to count
     *   }
     * })
    **/
    count<T extends ProductFabricCountArgs>(
      args?: Subset<T, ProductFabricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductFabricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductFabric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFabricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductFabricAggregateArgs>(args: Subset<T, ProductFabricAggregateArgs>): Prisma.PrismaPromise<GetProductFabricAggregateType<T>>

    /**
     * Group by ProductFabric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFabricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductFabricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductFabricGroupByArgs['orderBy'] }
        : { orderBy?: ProductFabricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductFabricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductFabricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductFabric model
   */
  readonly fields: ProductFabricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductFabric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductFabricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductFabric$ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductFabric$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductFabric model
   */ 
  interface ProductFabricFieldRefs {
    readonly id: FieldRef<"ProductFabric", 'String'>
    readonly name: FieldRef<"ProductFabric", 'String'>
    readonly slug: FieldRef<"ProductFabric", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductFabric findUnique
   */
  export type ProductFabricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    /**
     * Filter, which ProductFabric to fetch.
     */
    where: ProductFabricWhereUniqueInput
  }

  /**
   * ProductFabric findUniqueOrThrow
   */
  export type ProductFabricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    /**
     * Filter, which ProductFabric to fetch.
     */
    where: ProductFabricWhereUniqueInput
  }

  /**
   * ProductFabric findFirst
   */
  export type ProductFabricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    /**
     * Filter, which ProductFabric to fetch.
     */
    where?: ProductFabricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFabrics to fetch.
     */
    orderBy?: ProductFabricOrderByWithRelationInput | ProductFabricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFabrics.
     */
    cursor?: ProductFabricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFabrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFabrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFabrics.
     */
    distinct?: ProductFabricScalarFieldEnum | ProductFabricScalarFieldEnum[]
  }

  /**
   * ProductFabric findFirstOrThrow
   */
  export type ProductFabricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    /**
     * Filter, which ProductFabric to fetch.
     */
    where?: ProductFabricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFabrics to fetch.
     */
    orderBy?: ProductFabricOrderByWithRelationInput | ProductFabricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFabrics.
     */
    cursor?: ProductFabricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFabrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFabrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFabrics.
     */
    distinct?: ProductFabricScalarFieldEnum | ProductFabricScalarFieldEnum[]
  }

  /**
   * ProductFabric findMany
   */
  export type ProductFabricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    /**
     * Filter, which ProductFabrics to fetch.
     */
    where?: ProductFabricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFabrics to fetch.
     */
    orderBy?: ProductFabricOrderByWithRelationInput | ProductFabricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductFabrics.
     */
    cursor?: ProductFabricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFabrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFabrics.
     */
    skip?: number
    distinct?: ProductFabricScalarFieldEnum | ProductFabricScalarFieldEnum[]
  }

  /**
   * ProductFabric create
   */
  export type ProductFabricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductFabric.
     */
    data: XOR<ProductFabricCreateInput, ProductFabricUncheckedCreateInput>
  }

  /**
   * ProductFabric createMany
   */
  export type ProductFabricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductFabrics.
     */
    data: ProductFabricCreateManyInput | ProductFabricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductFabric update
   */
  export type ProductFabricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductFabric.
     */
    data: XOR<ProductFabricUpdateInput, ProductFabricUncheckedUpdateInput>
    /**
     * Choose, which ProductFabric to update.
     */
    where: ProductFabricWhereUniqueInput
  }

  /**
   * ProductFabric updateMany
   */
  export type ProductFabricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductFabrics.
     */
    data: XOR<ProductFabricUpdateManyMutationInput, ProductFabricUncheckedUpdateManyInput>
    /**
     * Filter which ProductFabrics to update
     */
    where?: ProductFabricWhereInput
    /**
     * Limit how many ProductFabrics to update.
     */
    limit?: number
  }

  /**
   * ProductFabric upsert
   */
  export type ProductFabricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductFabric to update in case it exists.
     */
    where: ProductFabricWhereUniqueInput
    /**
     * In case the ProductFabric found by the `where` argument doesn't exist, create a new ProductFabric with this data.
     */
    create: XOR<ProductFabricCreateInput, ProductFabricUncheckedCreateInput>
    /**
     * In case the ProductFabric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductFabricUpdateInput, ProductFabricUncheckedUpdateInput>
  }

  /**
   * ProductFabric delete
   */
  export type ProductFabricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
    /**
     * Filter which ProductFabric to delete.
     */
    where: ProductFabricWhereUniqueInput
  }

  /**
   * ProductFabric deleteMany
   */
  export type ProductFabricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductFabrics to delete
     */
    where?: ProductFabricWhereInput
    /**
     * Limit how many ProductFabrics to delete.
     */
    limit?: number
  }

  /**
   * ProductFabric.Product
   */
  export type ProductFabric$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductFabric without action
   */
  export type ProductFabricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFabric
     */
    select?: ProductFabricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductFabric
     */
    omit?: ProductFabricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFabricInclude<ExtArgs> | null
  }


  /**
   * Model ProductImage
   */

  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: string | null
    productId: string | null
    imageUrl: string | null
    colorId: string | null
    altText: string | null
    caption: string | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    imageUrl: string | null
    colorId: string | null
    altText: string | null
    caption: string | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    productId: number
    imageUrl: number
    colorId: number
    altText: number
    caption: number
    _all: number
  }


  export type ProductImageMinAggregateInputType = {
    id?: true
    productId?: true
    imageUrl?: true
    colorId?: true
    altText?: true
    caption?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    productId?: true
    imageUrl?: true
    colorId?: true
    altText?: true
    caption?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    productId?: true
    imageUrl?: true
    colorId?: true
    altText?: true
    caption?: true
    _all?: true
  }

  export type ProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithAggregationInput | ProductImageOrderByWithAggregationInput[]
    by: ProductImageScalarFieldEnum[] | ProductImageScalarFieldEnum
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }

  export type ProductImageGroupByOutputType = {
    id: string
    productId: string
    imageUrl: string
    colorId: string | null
    altText: string | null
    caption: string | null
    _count: ProductImageCountAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    colorId?: boolean
    altText?: boolean
    caption?: boolean
    CartItem?: boolean | ProductImage$CartItemArgs<ExtArgs>
    OrderItem?: boolean | ProductImage$OrderItemArgs<ExtArgs>
    ProductColor?: boolean | ProductImage$ProductColorArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    _count?: boolean | ProductImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>



  export type ProductImageSelectScalar = {
    id?: boolean
    productId?: boolean
    imageUrl?: boolean
    colorId?: boolean
    altText?: boolean
    caption?: boolean
  }

  export type ProductImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "imageUrl" | "colorId" | "altText" | "caption", ExtArgs["result"]["productImage"]>
  export type ProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CartItem?: boolean | ProductImage$CartItemArgs<ExtArgs>
    OrderItem?: boolean | ProductImage$OrderItemArgs<ExtArgs>
    ProductColor?: boolean | ProductImage$ProductColorArgs<ExtArgs>
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    _count?: boolean | ProductImageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImage"
    objects: {
      CartItem: Prisma.$CartItemPayload<ExtArgs>[]
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
      ProductColor: Prisma.$ProductColorPayload<ExtArgs> | null
      Product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      imageUrl: string
      colorId: string | null
      altText: string | null
      caption: string | null
    }, ExtArgs["result"]["productImage"]>
    composites: {}
  }

  type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageDefaultArgs> = $Result.GetResult<Prisma.$ProductImagePayload, S>

  type ProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductImageCountAggregateInputType | true
    }

  export interface ProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImage'], meta: { name: 'ProductImage' } }
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImageFindUniqueArgs>(args: SelectSubset<T, ProductImageFindUniqueArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImageFindFirstArgs>(args?: SelectSubset<T, ProductImageFindFirstArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductImageFindManyArgs>(args?: SelectSubset<T, ProductImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
     */
    create<T extends ProductImageCreateArgs>(args: SelectSubset<T, ProductImageCreateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductImages.
     * @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductImageCreateManyArgs>(args?: SelectSubset<T, ProductImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
     */
    delete<T extends ProductImageDeleteArgs>(args: SelectSubset<T, ProductImageDeleteArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductImageUpdateArgs>(args: SelectSubset<T, ProductImageUpdateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductImageDeleteManyArgs>(args?: SelectSubset<T, ProductImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductImageUpdateManyArgs>(args: SelectSubset<T, ProductImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
     */
    upsert<T extends ProductImageUpsertArgs>(args: SelectSubset<T, ProductImageUpsertArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): Prisma.PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImage model
   */
  readonly fields: ProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CartItem<T extends ProductImage$CartItemArgs<ExtArgs> = {}>(args?: Subset<T, ProductImage$CartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OrderItem<T extends ProductImage$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, ProductImage$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductColor<T extends ProductImage$ProductColorArgs<ExtArgs> = {}>(args?: Subset<T, ProductImage$ProductColorArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductImage model
   */ 
  interface ProductImageFieldRefs {
    readonly id: FieldRef<"ProductImage", 'String'>
    readonly productId: FieldRef<"ProductImage", 'String'>
    readonly imageUrl: FieldRef<"ProductImage", 'String'>
    readonly colorId: FieldRef<"ProductImage", 'String'>
    readonly altText: FieldRef<"ProductImage", 'String'>
    readonly caption: FieldRef<"ProductImage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImage.
     */
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }

  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
  }

  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }

  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to delete.
     */
    limit?: number
  }

  /**
   * ProductImage.CartItem
   */
  export type ProductImage$CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * ProductImage.OrderItem
   */
  export type ProductImage$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * ProductImage.ProductColor
   */
  export type ProductImage$ProductColorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductColor
     */
    omit?: ProductColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    where?: ProductColorWhereInput
  }

  /**
   * ProductImage without action
   */
  export type ProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
  }


  /**
   * Model ProductInventory
   */

  export type AggregateProductInventory = {
    _count: ProductInventoryCountAggregateOutputType | null
    _avg: ProductInventoryAvgAggregateOutputType | null
    _sum: ProductInventorySumAggregateOutputType | null
    _min: ProductInventoryMinAggregateOutputType | null
    _max: ProductInventoryMaxAggregateOutputType | null
  }

  export type ProductInventoryAvgAggregateOutputType = {
    mrp: number | null
    price: number | null
    stock: number | null
    minQuantity: number | null
    discount: number | null
  }

  export type ProductInventorySumAggregateOutputType = {
    mrp: number | null
    price: number | null
    stock: number | null
    minQuantity: number | null
    discount: number | null
  }

  export type ProductInventoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    mrp: number | null
    price: number | null
    sizeId: string | null
    stock: number | null
    minQuantity: number | null
    discount: number | null
  }

  export type ProductInventoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    mrp: number | null
    price: number | null
    sizeId: string | null
    stock: number | null
    minQuantity: number | null
    discount: number | null
  }

  export type ProductInventoryCountAggregateOutputType = {
    id: number
    productId: number
    mrp: number
    price: number
    sizeId: number
    stock: number
    minQuantity: number
    discount: number
    _all: number
  }


  export type ProductInventoryAvgAggregateInputType = {
    mrp?: true
    price?: true
    stock?: true
    minQuantity?: true
    discount?: true
  }

  export type ProductInventorySumAggregateInputType = {
    mrp?: true
    price?: true
    stock?: true
    minQuantity?: true
    discount?: true
  }

  export type ProductInventoryMinAggregateInputType = {
    id?: true
    productId?: true
    mrp?: true
    price?: true
    sizeId?: true
    stock?: true
    minQuantity?: true
    discount?: true
  }

  export type ProductInventoryMaxAggregateInputType = {
    id?: true
    productId?: true
    mrp?: true
    price?: true
    sizeId?: true
    stock?: true
    minQuantity?: true
    discount?: true
  }

  export type ProductInventoryCountAggregateInputType = {
    id?: true
    productId?: true
    mrp?: true
    price?: true
    sizeId?: true
    stock?: true
    minQuantity?: true
    discount?: true
    _all?: true
  }

  export type ProductInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductInventory to aggregate.
     */
    where?: ProductInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInventories to fetch.
     */
    orderBy?: ProductInventoryOrderByWithRelationInput | ProductInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductInventories
    **/
    _count?: true | ProductInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductInventoryMaxAggregateInputType
  }

  export type GetProductInventoryAggregateType<T extends ProductInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductInventory[P]>
      : GetScalarType<T[P], AggregateProductInventory[P]>
  }




  export type ProductInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductInventoryWhereInput
    orderBy?: ProductInventoryOrderByWithAggregationInput | ProductInventoryOrderByWithAggregationInput[]
    by: ProductInventoryScalarFieldEnum[] | ProductInventoryScalarFieldEnum
    having?: ProductInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductInventoryCountAggregateInputType | true
    _avg?: ProductInventoryAvgAggregateInputType
    _sum?: ProductInventorySumAggregateInputType
    _min?: ProductInventoryMinAggregateInputType
    _max?: ProductInventoryMaxAggregateInputType
  }

  export type ProductInventoryGroupByOutputType = {
    id: string
    productId: string
    mrp: number
    price: number
    sizeId: string | null
    stock: number
    minQuantity: number
    discount: number | null
    _count: ProductInventoryCountAggregateOutputType | null
    _avg: ProductInventoryAvgAggregateOutputType | null
    _sum: ProductInventorySumAggregateOutputType | null
    _min: ProductInventoryMinAggregateOutputType | null
    _max: ProductInventoryMaxAggregateOutputType | null
  }

  type GetProductInventoryGroupByPayload<T extends ProductInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductInventoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    mrp?: boolean
    price?: boolean
    sizeId?: boolean
    stock?: boolean
    minQuantity?: boolean
    discount?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProductSize?: boolean | ProductInventory$ProductSizeArgs<ExtArgs>
  }, ExtArgs["result"]["productInventory"]>



  export type ProductInventorySelectScalar = {
    id?: boolean
    productId?: boolean
    mrp?: boolean
    price?: boolean
    sizeId?: boolean
    stock?: boolean
    minQuantity?: boolean
    discount?: boolean
  }

  export type ProductInventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "mrp" | "price" | "sizeId" | "stock" | "minQuantity" | "discount", ExtArgs["result"]["productInventory"]>
  export type ProductInventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    ProductSize?: boolean | ProductInventory$ProductSizeArgs<ExtArgs>
  }

  export type $ProductInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductInventory"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>
      ProductSize: Prisma.$ProductSizePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      mrp: number
      price: number
      sizeId: string | null
      stock: number
      minQuantity: number
      discount: number | null
    }, ExtArgs["result"]["productInventory"]>
    composites: {}
  }

  type ProductInventoryGetPayload<S extends boolean | null | undefined | ProductInventoryDefaultArgs> = $Result.GetResult<Prisma.$ProductInventoryPayload, S>

  type ProductInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductInventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductInventoryCountAggregateInputType | true
    }

  export interface ProductInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductInventory'], meta: { name: 'ProductInventory' } }
    /**
     * Find zero or one ProductInventory that matches the filter.
     * @param {ProductInventoryFindUniqueArgs} args - Arguments to find a ProductInventory
     * @example
     * // Get one ProductInventory
     * const productInventory = await prisma.productInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductInventoryFindUniqueArgs>(args: SelectSubset<T, ProductInventoryFindUniqueArgs<ExtArgs>>): Prisma__ProductInventoryClient<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductInventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductInventoryFindUniqueOrThrowArgs} args - Arguments to find a ProductInventory
     * @example
     * // Get one ProductInventory
     * const productInventory = await prisma.productInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductInventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductInventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductInventoryClient<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInventoryFindFirstArgs} args - Arguments to find a ProductInventory
     * @example
     * // Get one ProductInventory
     * const productInventory = await prisma.productInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductInventoryFindFirstArgs>(args?: SelectSubset<T, ProductInventoryFindFirstArgs<ExtArgs>>): Prisma__ProductInventoryClient<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInventoryFindFirstOrThrowArgs} args - Arguments to find a ProductInventory
     * @example
     * // Get one ProductInventory
     * const productInventory = await prisma.productInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductInventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductInventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductInventoryClient<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductInventories
     * const productInventories = await prisma.productInventory.findMany()
     * 
     * // Get first 10 ProductInventories
     * const productInventories = await prisma.productInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productInventoryWithIdOnly = await prisma.productInventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductInventoryFindManyArgs>(args?: SelectSubset<T, ProductInventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductInventory.
     * @param {ProductInventoryCreateArgs} args - Arguments to create a ProductInventory.
     * @example
     * // Create one ProductInventory
     * const ProductInventory = await prisma.productInventory.create({
     *   data: {
     *     // ... data to create a ProductInventory
     *   }
     * })
     * 
     */
    create<T extends ProductInventoryCreateArgs>(args: SelectSubset<T, ProductInventoryCreateArgs<ExtArgs>>): Prisma__ProductInventoryClient<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductInventories.
     * @param {ProductInventoryCreateManyArgs} args - Arguments to create many ProductInventories.
     * @example
     * // Create many ProductInventories
     * const productInventory = await prisma.productInventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductInventoryCreateManyArgs>(args?: SelectSubset<T, ProductInventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductInventory.
     * @param {ProductInventoryDeleteArgs} args - Arguments to delete one ProductInventory.
     * @example
     * // Delete one ProductInventory
     * const ProductInventory = await prisma.productInventory.delete({
     *   where: {
     *     // ... filter to delete one ProductInventory
     *   }
     * })
     * 
     */
    delete<T extends ProductInventoryDeleteArgs>(args: SelectSubset<T, ProductInventoryDeleteArgs<ExtArgs>>): Prisma__ProductInventoryClient<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductInventory.
     * @param {ProductInventoryUpdateArgs} args - Arguments to update one ProductInventory.
     * @example
     * // Update one ProductInventory
     * const productInventory = await prisma.productInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductInventoryUpdateArgs>(args: SelectSubset<T, ProductInventoryUpdateArgs<ExtArgs>>): Prisma__ProductInventoryClient<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductInventories.
     * @param {ProductInventoryDeleteManyArgs} args - Arguments to filter ProductInventories to delete.
     * @example
     * // Delete a few ProductInventories
     * const { count } = await prisma.productInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductInventoryDeleteManyArgs>(args?: SelectSubset<T, ProductInventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductInventories
     * const productInventory = await prisma.productInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductInventoryUpdateManyArgs>(args: SelectSubset<T, ProductInventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductInventory.
     * @param {ProductInventoryUpsertArgs} args - Arguments to update or create a ProductInventory.
     * @example
     * // Update or create a ProductInventory
     * const productInventory = await prisma.productInventory.upsert({
     *   create: {
     *     // ... data to create a ProductInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductInventory we want to update
     *   }
     * })
     */
    upsert<T extends ProductInventoryUpsertArgs>(args: SelectSubset<T, ProductInventoryUpsertArgs<ExtArgs>>): Prisma__ProductInventoryClient<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInventoryCountArgs} args - Arguments to filter ProductInventories to count.
     * @example
     * // Count the number of ProductInventories
     * const count = await prisma.productInventory.count({
     *   where: {
     *     // ... the filter for the ProductInventories we want to count
     *   }
     * })
    **/
    count<T extends ProductInventoryCountArgs>(
      args?: Subset<T, ProductInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductInventoryAggregateArgs>(args: Subset<T, ProductInventoryAggregateArgs>): Prisma.PrismaPromise<GetProductInventoryAggregateType<T>>

    /**
     * Group by ProductInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductInventoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductInventory model
   */
  readonly fields: ProductInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProductSize<T extends ProductInventory$ProductSizeArgs<ExtArgs> = {}>(args?: Subset<T, ProductInventory$ProductSizeArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductInventory model
   */ 
  interface ProductInventoryFieldRefs {
    readonly id: FieldRef<"ProductInventory", 'String'>
    readonly productId: FieldRef<"ProductInventory", 'String'>
    readonly mrp: FieldRef<"ProductInventory", 'Int'>
    readonly price: FieldRef<"ProductInventory", 'Int'>
    readonly sizeId: FieldRef<"ProductInventory", 'String'>
    readonly stock: FieldRef<"ProductInventory", 'Int'>
    readonly minQuantity: FieldRef<"ProductInventory", 'Int'>
    readonly discount: FieldRef<"ProductInventory", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ProductInventory findUnique
   */
  export type ProductInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductInventory to fetch.
     */
    where: ProductInventoryWhereUniqueInput
  }

  /**
   * ProductInventory findUniqueOrThrow
   */
  export type ProductInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductInventory to fetch.
     */
    where: ProductInventoryWhereUniqueInput
  }

  /**
   * ProductInventory findFirst
   */
  export type ProductInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductInventory to fetch.
     */
    where?: ProductInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInventories to fetch.
     */
    orderBy?: ProductInventoryOrderByWithRelationInput | ProductInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductInventories.
     */
    cursor?: ProductInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductInventories.
     */
    distinct?: ProductInventoryScalarFieldEnum | ProductInventoryScalarFieldEnum[]
  }

  /**
   * ProductInventory findFirstOrThrow
   */
  export type ProductInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductInventory to fetch.
     */
    where?: ProductInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInventories to fetch.
     */
    orderBy?: ProductInventoryOrderByWithRelationInput | ProductInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductInventories.
     */
    cursor?: ProductInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductInventories.
     */
    distinct?: ProductInventoryScalarFieldEnum | ProductInventoryScalarFieldEnum[]
  }

  /**
   * ProductInventory findMany
   */
  export type ProductInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductInventories to fetch.
     */
    where?: ProductInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductInventories to fetch.
     */
    orderBy?: ProductInventoryOrderByWithRelationInput | ProductInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductInventories.
     */
    cursor?: ProductInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductInventories.
     */
    skip?: number
    distinct?: ProductInventoryScalarFieldEnum | ProductInventoryScalarFieldEnum[]
  }

  /**
   * ProductInventory create
   */
  export type ProductInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductInventory.
     */
    data: XOR<ProductInventoryCreateInput, ProductInventoryUncheckedCreateInput>
  }

  /**
   * ProductInventory createMany
   */
  export type ProductInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductInventories.
     */
    data: ProductInventoryCreateManyInput | ProductInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductInventory update
   */
  export type ProductInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductInventory.
     */
    data: XOR<ProductInventoryUpdateInput, ProductInventoryUncheckedUpdateInput>
    /**
     * Choose, which ProductInventory to update.
     */
    where: ProductInventoryWhereUniqueInput
  }

  /**
   * ProductInventory updateMany
   */
  export type ProductInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductInventories.
     */
    data: XOR<ProductInventoryUpdateManyMutationInput, ProductInventoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductInventories to update
     */
    where?: ProductInventoryWhereInput
    /**
     * Limit how many ProductInventories to update.
     */
    limit?: number
  }

  /**
   * ProductInventory upsert
   */
  export type ProductInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductInventory to update in case it exists.
     */
    where: ProductInventoryWhereUniqueInput
    /**
     * In case the ProductInventory found by the `where` argument doesn't exist, create a new ProductInventory with this data.
     */
    create: XOR<ProductInventoryCreateInput, ProductInventoryUncheckedCreateInput>
    /**
     * In case the ProductInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductInventoryUpdateInput, ProductInventoryUncheckedUpdateInput>
  }

  /**
   * ProductInventory delete
   */
  export type ProductInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    /**
     * Filter which ProductInventory to delete.
     */
    where: ProductInventoryWhereUniqueInput
  }

  /**
   * ProductInventory deleteMany
   */
  export type ProductInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductInventories to delete
     */
    where?: ProductInventoryWhereInput
    /**
     * Limit how many ProductInventories to delete.
     */
    limit?: number
  }

  /**
   * ProductInventory.ProductSize
   */
  export type ProductInventory$ProductSizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    where?: ProductSizeWhereInput
  }

  /**
   * ProductInventory without action
   */
  export type ProductInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductReview
   */

  export type AggregateProductReview = {
    _count: ProductReviewCountAggregateOutputType | null
    _avg: ProductReviewAvgAggregateOutputType | null
    _sum: ProductReviewSumAggregateOutputType | null
    _min: ProductReviewMinAggregateOutputType | null
    _max: ProductReviewMaxAggregateOutputType | null
  }

  export type ProductReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ProductReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ProductReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    rating: number | null
    review: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    rating: number | null
    review: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductReviewCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    rating: number
    review: number
    createdAt: number
    updatedAt: number
    images: number
    _all: number
  }


  export type ProductReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ProductReviewSumAggregateInputType = {
    rating?: true
  }

  export type ProductReviewMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    rating?: true
    review?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    rating?: true
    review?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductReviewCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    rating?: true
    review?: true
    createdAt?: true
    updatedAt?: true
    images?: true
    _all?: true
  }

  export type ProductReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReview to aggregate.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductReviews
    **/
    _count?: true | ProductReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductReviewMaxAggregateInputType
  }

  export type GetProductReviewAggregateType<T extends ProductReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateProductReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductReview[P]>
      : GetScalarType<T[P], AggregateProductReview[P]>
  }




  export type ProductReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
    orderBy?: ProductReviewOrderByWithAggregationInput | ProductReviewOrderByWithAggregationInput[]
    by: ProductReviewScalarFieldEnum[] | ProductReviewScalarFieldEnum
    having?: ProductReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductReviewCountAggregateInputType | true
    _avg?: ProductReviewAvgAggregateInputType
    _sum?: ProductReviewSumAggregateInputType
    _min?: ProductReviewMinAggregateInputType
    _max?: ProductReviewMaxAggregateInputType
  }

  export type ProductReviewGroupByOutputType = {
    id: string
    userId: string
    productId: string
    rating: number
    review: string | null
    createdAt: Date
    updatedAt: Date
    images: JsonValue
    _count: ProductReviewCountAggregateOutputType | null
    _avg: ProductReviewAvgAggregateOutputType | null
    _sum: ProductReviewSumAggregateOutputType | null
    _min: ProductReviewMinAggregateOutputType | null
    _max: ProductReviewMaxAggregateOutputType | null
  }

  type GetProductReviewGroupByPayload<T extends ProductReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>
        }
      >
    >


  export type ProductReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    rating?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReview"]>



  export type ProductReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    rating?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean
  }

  export type ProductReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "rating" | "review" | "createdAt" | "updatedAt" | "images", ExtArgs["result"]["productReview"]>
  export type ProductReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductReview"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      rating: number
      review: string | null
      createdAt: Date
      updatedAt: Date
      images: Prisma.JsonValue
    }, ExtArgs["result"]["productReview"]>
    composites: {}
  }

  type ProductReviewGetPayload<S extends boolean | null | undefined | ProductReviewDefaultArgs> = $Result.GetResult<Prisma.$ProductReviewPayload, S>

  type ProductReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductReviewCountAggregateInputType | true
    }

  export interface ProductReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductReview'], meta: { name: 'ProductReview' } }
    /**
     * Find zero or one ProductReview that matches the filter.
     * @param {ProductReviewFindUniqueArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductReviewFindUniqueArgs>(args: SelectSubset<T, ProductReviewFindUniqueArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductReviewFindUniqueOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductReviewFindFirstArgs>(args?: SelectSubset<T, ProductReviewFindFirstArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductReviews
     * const productReviews = await prisma.productReview.findMany()
     * 
     * // Get first 10 ProductReviews
     * const productReviews = await prisma.productReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productReviewWithIdOnly = await prisma.productReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductReviewFindManyArgs>(args?: SelectSubset<T, ProductReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductReview.
     * @param {ProductReviewCreateArgs} args - Arguments to create a ProductReview.
     * @example
     * // Create one ProductReview
     * const ProductReview = await prisma.productReview.create({
     *   data: {
     *     // ... data to create a ProductReview
     *   }
     * })
     * 
     */
    create<T extends ProductReviewCreateArgs>(args: SelectSubset<T, ProductReviewCreateArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductReviews.
     * @param {ProductReviewCreateManyArgs} args - Arguments to create many ProductReviews.
     * @example
     * // Create many ProductReviews
     * const productReview = await prisma.productReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductReviewCreateManyArgs>(args?: SelectSubset<T, ProductReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductReview.
     * @param {ProductReviewDeleteArgs} args - Arguments to delete one ProductReview.
     * @example
     * // Delete one ProductReview
     * const ProductReview = await prisma.productReview.delete({
     *   where: {
     *     // ... filter to delete one ProductReview
     *   }
     * })
     * 
     */
    delete<T extends ProductReviewDeleteArgs>(args: SelectSubset<T, ProductReviewDeleteArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductReview.
     * @param {ProductReviewUpdateArgs} args - Arguments to update one ProductReview.
     * @example
     * // Update one ProductReview
     * const productReview = await prisma.productReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductReviewUpdateArgs>(args: SelectSubset<T, ProductReviewUpdateArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductReviews.
     * @param {ProductReviewDeleteManyArgs} args - Arguments to filter ProductReviews to delete.
     * @example
     * // Delete a few ProductReviews
     * const { count } = await prisma.productReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductReviewDeleteManyArgs>(args?: SelectSubset<T, ProductReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductReviews
     * const productReview = await prisma.productReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductReviewUpdateManyArgs>(args: SelectSubset<T, ProductReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductReview.
     * @param {ProductReviewUpsertArgs} args - Arguments to update or create a ProductReview.
     * @example
     * // Update or create a ProductReview
     * const productReview = await prisma.productReview.upsert({
     *   create: {
     *     // ... data to create a ProductReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductReview we want to update
     *   }
     * })
     */
    upsert<T extends ProductReviewUpsertArgs>(args: SelectSubset<T, ProductReviewUpsertArgs<ExtArgs>>): Prisma__ProductReviewClient<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewCountArgs} args - Arguments to filter ProductReviews to count.
     * @example
     * // Count the number of ProductReviews
     * const count = await prisma.productReview.count({
     *   where: {
     *     // ... the filter for the ProductReviews we want to count
     *   }
     * })
    **/
    count<T extends ProductReviewCountArgs>(
      args?: Subset<T, ProductReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductReviewAggregateArgs>(args: Subset<T, ProductReviewAggregateArgs>): Prisma.PrismaPromise<GetProductReviewAggregateType<T>>

    /**
     * Group by ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductReviewGroupByArgs['orderBy'] }
        : { orderBy?: ProductReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductReview model
   */
  readonly fields: ProductReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductReview model
   */ 
  interface ProductReviewFieldRefs {
    readonly id: FieldRef<"ProductReview", 'String'>
    readonly userId: FieldRef<"ProductReview", 'String'>
    readonly productId: FieldRef<"ProductReview", 'String'>
    readonly rating: FieldRef<"ProductReview", 'Int'>
    readonly review: FieldRef<"ProductReview", 'String'>
    readonly createdAt: FieldRef<"ProductReview", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductReview", 'DateTime'>
    readonly images: FieldRef<"ProductReview", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ProductReview findUnique
   */
  export type ProductReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview findUniqueOrThrow
   */
  export type ProductReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview findFirst
   */
  export type ProductReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * ProductReview findFirstOrThrow
   */
  export type ProductReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * ProductReview findMany
   */
  export type ProductReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviews to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * ProductReview create
   */
  export type ProductReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductReview.
     */
    data: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>
  }

  /**
   * ProductReview createMany
   */
  export type ProductReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductReviews.
     */
    data: ProductReviewCreateManyInput | ProductReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductReview update
   */
  export type ProductReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductReview.
     */
    data: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>
    /**
     * Choose, which ProductReview to update.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview updateMany
   */
  export type ProductReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductReviews.
     */
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyInput>
    /**
     * Filter which ProductReviews to update
     */
    where?: ProductReviewWhereInput
    /**
     * Limit how many ProductReviews to update.
     */
    limit?: number
  }

  /**
   * ProductReview upsert
   */
  export type ProductReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductReview to update in case it exists.
     */
    where: ProductReviewWhereUniqueInput
    /**
     * In case the ProductReview found by the `where` argument doesn't exist, create a new ProductReview with this data.
     */
    create: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>
    /**
     * In case the ProductReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>
  }

  /**
   * ProductReview delete
   */
  export type ProductReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter which ProductReview to delete.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview deleteMany
   */
  export type ProductReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReviews to delete
     */
    where?: ProductReviewWhereInput
    /**
     * Limit how many ProductReviews to delete.
     */
    limit?: number
  }

  /**
   * ProductReview without action
   */
  export type ProductReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
  }


  /**
   * Model ProductSize
   */

  export type AggregateProductSize = {
    _count: ProductSizeCountAggregateOutputType | null
    _min: ProductSizeMinAggregateOutputType | null
    _max: ProductSizeMaxAggregateOutputType | null
  }

  export type ProductSizeMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type ProductSizeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
  }

  export type ProductSizeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    _all: number
  }


  export type ProductSizeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type ProductSizeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
  }

  export type ProductSizeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    _all?: true
  }

  export type ProductSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSize to aggregate.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductSizes
    **/
    _count?: true | ProductSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductSizeMaxAggregateInputType
  }

  export type GetProductSizeAggregateType<T extends ProductSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductSize[P]>
      : GetScalarType<T[P], AggregateProductSize[P]>
  }




  export type ProductSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSizeWhereInput
    orderBy?: ProductSizeOrderByWithAggregationInput | ProductSizeOrderByWithAggregationInput[]
    by: ProductSizeScalarFieldEnum[] | ProductSizeScalarFieldEnum
    having?: ProductSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductSizeCountAggregateInputType | true
    _min?: ProductSizeMinAggregateInputType
    _max?: ProductSizeMaxAggregateInputType
  }

  export type ProductSizeGroupByOutputType = {
    id: string
    name: string
    slug: string
    _count: ProductSizeCountAggregateOutputType | null
    _min: ProductSizeMinAggregateOutputType | null
    _max: ProductSizeMaxAggregateOutputType | null
  }

  type GetProductSizeGroupByPayload<T extends ProductSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
        }
      >
    >


  export type ProductSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    OrderItem?: boolean | ProductSize$OrderItemArgs<ExtArgs>
    ProductInventory?: boolean | ProductSize$ProductInventoryArgs<ExtArgs>
    _count?: boolean | ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSize"]>



  export type ProductSizeSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
  }

  export type ProductSizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug", ExtArgs["result"]["productSize"]>
  export type ProductSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItem?: boolean | ProductSize$OrderItemArgs<ExtArgs>
    ProductInventory?: boolean | ProductSize$ProductInventoryArgs<ExtArgs>
    _count?: boolean | ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductSize"
    objects: {
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
      ProductInventory: Prisma.$ProductInventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
    }, ExtArgs["result"]["productSize"]>
    composites: {}
  }

  type ProductSizeGetPayload<S extends boolean | null | undefined | ProductSizeDefaultArgs> = $Result.GetResult<Prisma.$ProductSizePayload, S>

  type ProductSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductSizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductSizeCountAggregateInputType | true
    }

  export interface ProductSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSize'], meta: { name: 'ProductSize' } }
    /**
     * Find zero or one ProductSize that matches the filter.
     * @param {ProductSizeFindUniqueArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductSizeFindUniqueArgs>(args: SelectSubset<T, ProductSizeFindUniqueArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductSize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductSizeFindUniqueOrThrowArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindFirstArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductSizeFindFirstArgs>(args?: SelectSubset<T, ProductSizeFindFirstArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindFirstOrThrowArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductSizes
     * const productSizes = await prisma.productSize.findMany()
     * 
     * // Get first 10 ProductSizes
     * const productSizes = await prisma.productSize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productSizeWithIdOnly = await prisma.productSize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductSizeFindManyArgs>(args?: SelectSubset<T, ProductSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductSize.
     * @param {ProductSizeCreateArgs} args - Arguments to create a ProductSize.
     * @example
     * // Create one ProductSize
     * const ProductSize = await prisma.productSize.create({
     *   data: {
     *     // ... data to create a ProductSize
     *   }
     * })
     * 
     */
    create<T extends ProductSizeCreateArgs>(args: SelectSubset<T, ProductSizeCreateArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductSizes.
     * @param {ProductSizeCreateManyArgs} args - Arguments to create many ProductSizes.
     * @example
     * // Create many ProductSizes
     * const productSize = await prisma.productSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductSizeCreateManyArgs>(args?: SelectSubset<T, ProductSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductSize.
     * @param {ProductSizeDeleteArgs} args - Arguments to delete one ProductSize.
     * @example
     * // Delete one ProductSize
     * const ProductSize = await prisma.productSize.delete({
     *   where: {
     *     // ... filter to delete one ProductSize
     *   }
     * })
     * 
     */
    delete<T extends ProductSizeDeleteArgs>(args: SelectSubset<T, ProductSizeDeleteArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductSize.
     * @param {ProductSizeUpdateArgs} args - Arguments to update one ProductSize.
     * @example
     * // Update one ProductSize
     * const productSize = await prisma.productSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductSizeUpdateArgs>(args: SelectSubset<T, ProductSizeUpdateArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductSizes.
     * @param {ProductSizeDeleteManyArgs} args - Arguments to filter ProductSizes to delete.
     * @example
     * // Delete a few ProductSizes
     * const { count } = await prisma.productSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductSizeDeleteManyArgs>(args?: SelectSubset<T, ProductSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductSizes
     * const productSize = await prisma.productSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductSizeUpdateManyArgs>(args: SelectSubset<T, ProductSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductSize.
     * @param {ProductSizeUpsertArgs} args - Arguments to update or create a ProductSize.
     * @example
     * // Update or create a ProductSize
     * const productSize = await prisma.productSize.upsert({
     *   create: {
     *     // ... data to create a ProductSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductSize we want to update
     *   }
     * })
     */
    upsert<T extends ProductSizeUpsertArgs>(args: SelectSubset<T, ProductSizeUpsertArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeCountArgs} args - Arguments to filter ProductSizes to count.
     * @example
     * // Count the number of ProductSizes
     * const count = await prisma.productSize.count({
     *   where: {
     *     // ... the filter for the ProductSizes we want to count
     *   }
     * })
    **/
    count<T extends ProductSizeCountArgs>(
      args?: Subset<T, ProductSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductSizeAggregateArgs>(args: Subset<T, ProductSizeAggregateArgs>): Prisma.PrismaPromise<GetProductSizeAggregateType<T>>

    /**
     * Group by ProductSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductSizeGroupByArgs['orderBy'] }
        : { orderBy?: ProductSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductSize model
   */
  readonly fields: ProductSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrderItem<T extends ProductSize$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, ProductSize$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductInventory<T extends ProductSize$ProductInventoryArgs<ExtArgs> = {}>(args?: Subset<T, ProductSize$ProductInventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductSize model
   */ 
  interface ProductSizeFieldRefs {
    readonly id: FieldRef<"ProductSize", 'String'>
    readonly name: FieldRef<"ProductSize", 'String'>
    readonly slug: FieldRef<"ProductSize", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductSize findUnique
   */
  export type ProductSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize findUniqueOrThrow
   */
  export type ProductSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize findFirst
   */
  export type ProductSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSizes.
     */
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * ProductSize findFirstOrThrow
   */
  export type ProductSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSizes.
     */
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * ProductSize findMany
   */
  export type ProductSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSizes to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * ProductSize create
   */
  export type ProductSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductSize.
     */
    data: XOR<ProductSizeCreateInput, ProductSizeUncheckedCreateInput>
  }

  /**
   * ProductSize createMany
   */
  export type ProductSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductSizes.
     */
    data: ProductSizeCreateManyInput | ProductSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductSize update
   */
  export type ProductSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductSize.
     */
    data: XOR<ProductSizeUpdateInput, ProductSizeUncheckedUpdateInput>
    /**
     * Choose, which ProductSize to update.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize updateMany
   */
  export type ProductSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductSizes.
     */
    data: XOR<ProductSizeUpdateManyMutationInput, ProductSizeUncheckedUpdateManyInput>
    /**
     * Filter which ProductSizes to update
     */
    where?: ProductSizeWhereInput
    /**
     * Limit how many ProductSizes to update.
     */
    limit?: number
  }

  /**
   * ProductSize upsert
   */
  export type ProductSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductSize to update in case it exists.
     */
    where: ProductSizeWhereUniqueInput
    /**
     * In case the ProductSize found by the `where` argument doesn't exist, create a new ProductSize with this data.
     */
    create: XOR<ProductSizeCreateInput, ProductSizeUncheckedCreateInput>
    /**
     * In case the ProductSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductSizeUpdateInput, ProductSizeUncheckedUpdateInput>
  }

  /**
   * ProductSize delete
   */
  export type ProductSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter which ProductSize to delete.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize deleteMany
   */
  export type ProductSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSizes to delete
     */
    where?: ProductSizeWhereInput
    /**
     * Limit how many ProductSizes to delete.
     */
    limit?: number
  }

  /**
   * ProductSize.OrderItem
   */
  export type ProductSize$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * ProductSize.ProductInventory
   */
  export type ProductSize$ProductInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductInventory
     */
    select?: ProductInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductInventory
     */
    omit?: ProductInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInventoryInclude<ExtArgs> | null
    where?: ProductInventoryWhereInput
    orderBy?: ProductInventoryOrderByWithRelationInput | ProductInventoryOrderByWithRelationInput[]
    cursor?: ProductInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductInventoryScalarFieldEnum | ProductInventoryScalarFieldEnum[]
  }

  /**
   * ProductSize without action
   */
  export type ProductSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSize
     */
    omit?: ProductSizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
  }


  /**
   * Model ProductWeek
   */

  export type AggregateProductWeek = {
    _count: ProductWeekCountAggregateOutputType | null
    _min: ProductWeekMinAggregateOutputType | null
    _max: ProductWeekMaxAggregateOutputType | null
  }

  export type ProductWeekMinAggregateOutputType = {
    id: string | null
    title: string | null
    hyperLink: string | null
    imageUrl: string | null
  }

  export type ProductWeekMaxAggregateOutputType = {
    id: string | null
    title: string | null
    hyperLink: string | null
    imageUrl: string | null
  }

  export type ProductWeekCountAggregateOutputType = {
    id: number
    title: number
    hyperLink: number
    imageUrl: number
    _all: number
  }


  export type ProductWeekMinAggregateInputType = {
    id?: true
    title?: true
    hyperLink?: true
    imageUrl?: true
  }

  export type ProductWeekMaxAggregateInputType = {
    id?: true
    title?: true
    hyperLink?: true
    imageUrl?: true
  }

  export type ProductWeekCountAggregateInputType = {
    id?: true
    title?: true
    hyperLink?: true
    imageUrl?: true
    _all?: true
  }

  export type ProductWeekAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductWeek to aggregate.
     */
    where?: ProductWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductWeeks to fetch.
     */
    orderBy?: ProductWeekOrderByWithRelationInput | ProductWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductWeeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductWeeks
    **/
    _count?: true | ProductWeekCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductWeekMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductWeekMaxAggregateInputType
  }

  export type GetProductWeekAggregateType<T extends ProductWeekAggregateArgs> = {
        [P in keyof T & keyof AggregateProductWeek]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductWeek[P]>
      : GetScalarType<T[P], AggregateProductWeek[P]>
  }




  export type ProductWeekGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWeekWhereInput
    orderBy?: ProductWeekOrderByWithAggregationInput | ProductWeekOrderByWithAggregationInput[]
    by: ProductWeekScalarFieldEnum[] | ProductWeekScalarFieldEnum
    having?: ProductWeekScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductWeekCountAggregateInputType | true
    _min?: ProductWeekMinAggregateInputType
    _max?: ProductWeekMaxAggregateInputType
  }

  export type ProductWeekGroupByOutputType = {
    id: string
    title: string | null
    hyperLink: string | null
    imageUrl: string | null
    _count: ProductWeekCountAggregateOutputType | null
    _min: ProductWeekMinAggregateOutputType | null
    _max: ProductWeekMaxAggregateOutputType | null
  }

  type GetProductWeekGroupByPayload<T extends ProductWeekGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductWeekGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductWeekGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductWeekGroupByOutputType[P]>
            : GetScalarType<T[P], ProductWeekGroupByOutputType[P]>
        }
      >
    >


  export type ProductWeekSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    hyperLink?: boolean
    imageUrl?: boolean
  }, ExtArgs["result"]["productWeek"]>



  export type ProductWeekSelectScalar = {
    id?: boolean
    title?: boolean
    hyperLink?: boolean
    imageUrl?: boolean
  }

  export type ProductWeekOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "hyperLink" | "imageUrl", ExtArgs["result"]["productWeek"]>

  export type $ProductWeekPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductWeek"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      hyperLink: string | null
      imageUrl: string | null
    }, ExtArgs["result"]["productWeek"]>
    composites: {}
  }

  type ProductWeekGetPayload<S extends boolean | null | undefined | ProductWeekDefaultArgs> = $Result.GetResult<Prisma.$ProductWeekPayload, S>

  type ProductWeekCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductWeekFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductWeekCountAggregateInputType | true
    }

  export interface ProductWeekDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductWeek'], meta: { name: 'ProductWeek' } }
    /**
     * Find zero or one ProductWeek that matches the filter.
     * @param {ProductWeekFindUniqueArgs} args - Arguments to find a ProductWeek
     * @example
     * // Get one ProductWeek
     * const productWeek = await prisma.productWeek.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductWeekFindUniqueArgs>(args: SelectSubset<T, ProductWeekFindUniqueArgs<ExtArgs>>): Prisma__ProductWeekClient<$Result.GetResult<Prisma.$ProductWeekPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductWeek that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductWeekFindUniqueOrThrowArgs} args - Arguments to find a ProductWeek
     * @example
     * // Get one ProductWeek
     * const productWeek = await prisma.productWeek.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductWeekFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductWeekFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductWeekClient<$Result.GetResult<Prisma.$ProductWeekPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductWeek that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWeekFindFirstArgs} args - Arguments to find a ProductWeek
     * @example
     * // Get one ProductWeek
     * const productWeek = await prisma.productWeek.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductWeekFindFirstArgs>(args?: SelectSubset<T, ProductWeekFindFirstArgs<ExtArgs>>): Prisma__ProductWeekClient<$Result.GetResult<Prisma.$ProductWeekPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductWeek that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWeekFindFirstOrThrowArgs} args - Arguments to find a ProductWeek
     * @example
     * // Get one ProductWeek
     * const productWeek = await prisma.productWeek.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductWeekFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductWeekFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductWeekClient<$Result.GetResult<Prisma.$ProductWeekPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductWeeks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWeekFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductWeeks
     * const productWeeks = await prisma.productWeek.findMany()
     * 
     * // Get first 10 ProductWeeks
     * const productWeeks = await prisma.productWeek.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWeekWithIdOnly = await prisma.productWeek.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductWeekFindManyArgs>(args?: SelectSubset<T, ProductWeekFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductWeekPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductWeek.
     * @param {ProductWeekCreateArgs} args - Arguments to create a ProductWeek.
     * @example
     * // Create one ProductWeek
     * const ProductWeek = await prisma.productWeek.create({
     *   data: {
     *     // ... data to create a ProductWeek
     *   }
     * })
     * 
     */
    create<T extends ProductWeekCreateArgs>(args: SelectSubset<T, ProductWeekCreateArgs<ExtArgs>>): Prisma__ProductWeekClient<$Result.GetResult<Prisma.$ProductWeekPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductWeeks.
     * @param {ProductWeekCreateManyArgs} args - Arguments to create many ProductWeeks.
     * @example
     * // Create many ProductWeeks
     * const productWeek = await prisma.productWeek.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductWeekCreateManyArgs>(args?: SelectSubset<T, ProductWeekCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductWeek.
     * @param {ProductWeekDeleteArgs} args - Arguments to delete one ProductWeek.
     * @example
     * // Delete one ProductWeek
     * const ProductWeek = await prisma.productWeek.delete({
     *   where: {
     *     // ... filter to delete one ProductWeek
     *   }
     * })
     * 
     */
    delete<T extends ProductWeekDeleteArgs>(args: SelectSubset<T, ProductWeekDeleteArgs<ExtArgs>>): Prisma__ProductWeekClient<$Result.GetResult<Prisma.$ProductWeekPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductWeek.
     * @param {ProductWeekUpdateArgs} args - Arguments to update one ProductWeek.
     * @example
     * // Update one ProductWeek
     * const productWeek = await prisma.productWeek.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductWeekUpdateArgs>(args: SelectSubset<T, ProductWeekUpdateArgs<ExtArgs>>): Prisma__ProductWeekClient<$Result.GetResult<Prisma.$ProductWeekPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductWeeks.
     * @param {ProductWeekDeleteManyArgs} args - Arguments to filter ProductWeeks to delete.
     * @example
     * // Delete a few ProductWeeks
     * const { count } = await prisma.productWeek.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductWeekDeleteManyArgs>(args?: SelectSubset<T, ProductWeekDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductWeeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWeekUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductWeeks
     * const productWeek = await prisma.productWeek.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductWeekUpdateManyArgs>(args: SelectSubset<T, ProductWeekUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductWeek.
     * @param {ProductWeekUpsertArgs} args - Arguments to update or create a ProductWeek.
     * @example
     * // Update or create a ProductWeek
     * const productWeek = await prisma.productWeek.upsert({
     *   create: {
     *     // ... data to create a ProductWeek
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductWeek we want to update
     *   }
     * })
     */
    upsert<T extends ProductWeekUpsertArgs>(args: SelectSubset<T, ProductWeekUpsertArgs<ExtArgs>>): Prisma__ProductWeekClient<$Result.GetResult<Prisma.$ProductWeekPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductWeeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWeekCountArgs} args - Arguments to filter ProductWeeks to count.
     * @example
     * // Count the number of ProductWeeks
     * const count = await prisma.productWeek.count({
     *   where: {
     *     // ... the filter for the ProductWeeks we want to count
     *   }
     * })
    **/
    count<T extends ProductWeekCountArgs>(
      args?: Subset<T, ProductWeekCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductWeekCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductWeek.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWeekAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductWeekAggregateArgs>(args: Subset<T, ProductWeekAggregateArgs>): Prisma.PrismaPromise<GetProductWeekAggregateType<T>>

    /**
     * Group by ProductWeek.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductWeekGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductWeekGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductWeekGroupByArgs['orderBy'] }
        : { orderBy?: ProductWeekGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductWeekGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductWeekGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductWeek model
   */
  readonly fields: ProductWeekFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductWeek.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductWeekClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductWeek model
   */ 
  interface ProductWeekFieldRefs {
    readonly id: FieldRef<"ProductWeek", 'String'>
    readonly title: FieldRef<"ProductWeek", 'String'>
    readonly hyperLink: FieldRef<"ProductWeek", 'String'>
    readonly imageUrl: FieldRef<"ProductWeek", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductWeek findUnique
   */
  export type ProductWeekFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
    /**
     * Filter, which ProductWeek to fetch.
     */
    where: ProductWeekWhereUniqueInput
  }

  /**
   * ProductWeek findUniqueOrThrow
   */
  export type ProductWeekFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
    /**
     * Filter, which ProductWeek to fetch.
     */
    where: ProductWeekWhereUniqueInput
  }

  /**
   * ProductWeek findFirst
   */
  export type ProductWeekFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
    /**
     * Filter, which ProductWeek to fetch.
     */
    where?: ProductWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductWeeks to fetch.
     */
    orderBy?: ProductWeekOrderByWithRelationInput | ProductWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductWeeks.
     */
    cursor?: ProductWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductWeeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductWeeks.
     */
    distinct?: ProductWeekScalarFieldEnum | ProductWeekScalarFieldEnum[]
  }

  /**
   * ProductWeek findFirstOrThrow
   */
  export type ProductWeekFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
    /**
     * Filter, which ProductWeek to fetch.
     */
    where?: ProductWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductWeeks to fetch.
     */
    orderBy?: ProductWeekOrderByWithRelationInput | ProductWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductWeeks.
     */
    cursor?: ProductWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductWeeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductWeeks.
     */
    distinct?: ProductWeekScalarFieldEnum | ProductWeekScalarFieldEnum[]
  }

  /**
   * ProductWeek findMany
   */
  export type ProductWeekFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
    /**
     * Filter, which ProductWeeks to fetch.
     */
    where?: ProductWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductWeeks to fetch.
     */
    orderBy?: ProductWeekOrderByWithRelationInput | ProductWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductWeeks.
     */
    cursor?: ProductWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductWeeks.
     */
    skip?: number
    distinct?: ProductWeekScalarFieldEnum | ProductWeekScalarFieldEnum[]
  }

  /**
   * ProductWeek create
   */
  export type ProductWeekCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
    /**
     * The data needed to create a ProductWeek.
     */
    data: XOR<ProductWeekCreateInput, ProductWeekUncheckedCreateInput>
  }

  /**
   * ProductWeek createMany
   */
  export type ProductWeekCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductWeeks.
     */
    data: ProductWeekCreateManyInput | ProductWeekCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductWeek update
   */
  export type ProductWeekUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
    /**
     * The data needed to update a ProductWeek.
     */
    data: XOR<ProductWeekUpdateInput, ProductWeekUncheckedUpdateInput>
    /**
     * Choose, which ProductWeek to update.
     */
    where: ProductWeekWhereUniqueInput
  }

  /**
   * ProductWeek updateMany
   */
  export type ProductWeekUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductWeeks.
     */
    data: XOR<ProductWeekUpdateManyMutationInput, ProductWeekUncheckedUpdateManyInput>
    /**
     * Filter which ProductWeeks to update
     */
    where?: ProductWeekWhereInput
    /**
     * Limit how many ProductWeeks to update.
     */
    limit?: number
  }

  /**
   * ProductWeek upsert
   */
  export type ProductWeekUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
    /**
     * The filter to search for the ProductWeek to update in case it exists.
     */
    where: ProductWeekWhereUniqueInput
    /**
     * In case the ProductWeek found by the `where` argument doesn't exist, create a new ProductWeek with this data.
     */
    create: XOR<ProductWeekCreateInput, ProductWeekUncheckedCreateInput>
    /**
     * In case the ProductWeek was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductWeekUpdateInput, ProductWeekUncheckedUpdateInput>
  }

  /**
   * ProductWeek delete
   */
  export type ProductWeekDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
    /**
     * Filter which ProductWeek to delete.
     */
    where: ProductWeekWhereUniqueInput
  }

  /**
   * ProductWeek deleteMany
   */
  export type ProductWeekDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductWeeks to delete
     */
    where?: ProductWeekWhereInput
    /**
     * Limit how many ProductWeeks to delete.
     */
    limit?: number
  }

  /**
   * ProductWeek without action
   */
  export type ProductWeekDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductWeek
     */
    select?: ProductWeekSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductWeek
     */
    omit?: ProductWeekOmit<ExtArgs> | null
  }


  /**
   * Model Quotes
   */

  export type AggregateQuotes = {
    _count: QuotesCountAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  export type QuotesMinAggregateOutputType = {
    id: string | null
    text: string | null
    imageUrl: string | null
    hyperLink: string | null
    categoryId: string | null
  }

  export type QuotesMaxAggregateOutputType = {
    id: string | null
    text: string | null
    imageUrl: string | null
    hyperLink: string | null
    categoryId: string | null
  }

  export type QuotesCountAggregateOutputType = {
    id: number
    text: number
    imageUrl: number
    hyperLink: number
    categoryId: number
    _all: number
  }


  export type QuotesMinAggregateInputType = {
    id?: true
    text?: true
    imageUrl?: true
    hyperLink?: true
    categoryId?: true
  }

  export type QuotesMaxAggregateInputType = {
    id?: true
    text?: true
    imageUrl?: true
    hyperLink?: true
    categoryId?: true
  }

  export type QuotesCountAggregateInputType = {
    id?: true
    text?: true
    imageUrl?: true
    hyperLink?: true
    categoryId?: true
    _all?: true
  }

  export type QuotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to aggregate.
     */
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotesMaxAggregateInputType
  }

  export type GetQuotesAggregateType<T extends QuotesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotes[P]>
      : GetScalarType<T[P], AggregateQuotes[P]>
  }




  export type QuotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotesWhereInput
    orderBy?: QuotesOrderByWithAggregationInput | QuotesOrderByWithAggregationInput[]
    by: QuotesScalarFieldEnum[] | QuotesScalarFieldEnum
    having?: QuotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotesCountAggregateInputType | true
    _min?: QuotesMinAggregateInputType
    _max?: QuotesMaxAggregateInputType
  }

  export type QuotesGroupByOutputType = {
    id: string
    text: string | null
    imageUrl: string | null
    hyperLink: string | null
    categoryId: string
    _count: QuotesCountAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  type GetQuotesGroupByPayload<T extends QuotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotesGroupByOutputType[P]>
            : GetScalarType<T[P], QuotesGroupByOutputType[P]>
        }
      >
    >


  export type QuotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    categoryId?: boolean
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotes"]>



  export type QuotesSelectScalar = {
    id?: boolean
    text?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    categoryId?: boolean
  }

  export type QuotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "imageUrl" | "hyperLink" | "categoryId", ExtArgs["result"]["quotes"]>
  export type QuotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }

  export type $QuotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quotes"
    objects: {
      ProductCategory: Prisma.$ProductCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string | null
      imageUrl: string | null
      hyperLink: string | null
      categoryId: string
    }, ExtArgs["result"]["quotes"]>
    composites: {}
  }

  type QuotesGetPayload<S extends boolean | null | undefined | QuotesDefaultArgs> = $Result.GetResult<Prisma.$QuotesPayload, S>

  type QuotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotesCountAggregateInputType | true
    }

  export interface QuotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quotes'], meta: { name: 'Quotes' } }
    /**
     * Find zero or one Quotes that matches the filter.
     * @param {QuotesFindUniqueArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotesFindUniqueArgs>(args: SelectSubset<T, QuotesFindUniqueArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quotes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotesFindUniqueOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotesFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindFirstArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotesFindFirstArgs>(args?: SelectSubset<T, QuotesFindFirstArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindFirstOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotesFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quotes.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotesWithIdOnly = await prisma.quotes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotesFindManyArgs>(args?: SelectSubset<T, QuotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quotes.
     * @param {QuotesCreateArgs} args - Arguments to create a Quotes.
     * @example
     * // Create one Quotes
     * const Quotes = await prisma.quotes.create({
     *   data: {
     *     // ... data to create a Quotes
     *   }
     * })
     * 
     */
    create<T extends QuotesCreateArgs>(args: SelectSubset<T, QuotesCreateArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {QuotesCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quotes = await prisma.quotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotesCreateManyArgs>(args?: SelectSubset<T, QuotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quotes.
     * @param {QuotesDeleteArgs} args - Arguments to delete one Quotes.
     * @example
     * // Delete one Quotes
     * const Quotes = await prisma.quotes.delete({
     *   where: {
     *     // ... filter to delete one Quotes
     *   }
     * })
     * 
     */
    delete<T extends QuotesDeleteArgs>(args: SelectSubset<T, QuotesDeleteArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quotes.
     * @param {QuotesUpdateArgs} args - Arguments to update one Quotes.
     * @example
     * // Update one Quotes
     * const quotes = await prisma.quotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotesUpdateArgs>(args: SelectSubset<T, QuotesUpdateArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {QuotesDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotesDeleteManyArgs>(args?: SelectSubset<T, QuotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quotes = await prisma.quotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotesUpdateManyArgs>(args: SelectSubset<T, QuotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quotes.
     * @param {QuotesUpsertArgs} args - Arguments to update or create a Quotes.
     * @example
     * // Update or create a Quotes
     * const quotes = await prisma.quotes.upsert({
     *   create: {
     *     // ... data to create a Quotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotes we want to update
     *   }
     * })
     */
    upsert<T extends QuotesUpsertArgs>(args: SelectSubset<T, QuotesUpsertArgs<ExtArgs>>): Prisma__QuotesClient<$Result.GetResult<Prisma.$QuotesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quotes.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuotesCountArgs>(
      args?: Subset<T, QuotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotesAggregateArgs>(args: Subset<T, QuotesAggregateArgs>): Prisma.PrismaPromise<GetQuotesAggregateType<T>>

    /**
     * Group by Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotesGroupByArgs['orderBy'] }
        : { orderBy?: QuotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quotes model
   */
  readonly fields: QuotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProductCategory<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quotes model
   */ 
  interface QuotesFieldRefs {
    readonly id: FieldRef<"Quotes", 'String'>
    readonly text: FieldRef<"Quotes", 'String'>
    readonly imageUrl: FieldRef<"Quotes", 'String'>
    readonly hyperLink: FieldRef<"Quotes", 'String'>
    readonly categoryId: FieldRef<"Quotes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Quotes findUnique
   */
  export type QuotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where: QuotesWhereUniqueInput
  }

  /**
   * Quotes findUniqueOrThrow
   */
  export type QuotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where: QuotesWhereUniqueInput
  }

  /**
   * Quotes findFirst
   */
  export type QuotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * Quotes findFirstOrThrow
   */
  export type QuotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * Quotes findMany
   */
  export type QuotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuotesOrderByWithRelationInput | QuotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * Quotes create
   */
  export type QuotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * The data needed to create a Quotes.
     */
    data: XOR<QuotesCreateInput, QuotesUncheckedCreateInput>
  }

  /**
   * Quotes createMany
   */
  export type QuotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuotesCreateManyInput | QuotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quotes update
   */
  export type QuotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * The data needed to update a Quotes.
     */
    data: XOR<QuotesUpdateInput, QuotesUncheckedUpdateInput>
    /**
     * Choose, which Quotes to update.
     */
    where: QuotesWhereUniqueInput
  }

  /**
   * Quotes updateMany
   */
  export type QuotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuotesWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
  }

  /**
   * Quotes upsert
   */
  export type QuotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * The filter to search for the Quotes to update in case it exists.
     */
    where: QuotesWhereUniqueInput
    /**
     * In case the Quotes found by the `where` argument doesn't exist, create a new Quotes with this data.
     */
    create: XOR<QuotesCreateInput, QuotesUncheckedCreateInput>
    /**
     * In case the Quotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotesUpdateInput, QuotesUncheckedUpdateInput>
  }

  /**
   * Quotes delete
   */
  export type QuotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
    /**
     * Filter which Quotes to delete.
     */
    where: QuotesWhereUniqueInput
  }

  /**
   * Quotes deleteMany
   */
  export type QuotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuotesWhereInput
    /**
     * Limit how many Quotes to delete.
     */
    limit?: number
  }

  /**
   * Quotes without action
   */
  export type QuotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotes
     */
    select?: QuotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotes
     */
    omit?: QuotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotesInclude<ExtArgs> | null
  }


  /**
   * Model ReturnRequest
   */

  export type AggregateReturnRequest = {
    _count: ReturnRequestCountAggregateOutputType | null
    _min: ReturnRequestMinAggregateOutputType | null
    _max: ReturnRequestMaxAggregateOutputType | null
  }

  export type ReturnRequestMinAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    reason: string | null
    status: $Enums.ReturnRequest_status | null
    requestedAt: Date | null
    resolvedAt: Date | null
  }

  export type ReturnRequestMaxAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    reason: string | null
    status: $Enums.ReturnRequest_status | null
    requestedAt: Date | null
    resolvedAt: Date | null
  }

  export type ReturnRequestCountAggregateOutputType = {
    id: number
    orderItemId: number
    reason: number
    status: number
    requestedAt: number
    resolvedAt: number
    _all: number
  }


  export type ReturnRequestMinAggregateInputType = {
    id?: true
    orderItemId?: true
    reason?: true
    status?: true
    requestedAt?: true
    resolvedAt?: true
  }

  export type ReturnRequestMaxAggregateInputType = {
    id?: true
    orderItemId?: true
    reason?: true
    status?: true
    requestedAt?: true
    resolvedAt?: true
  }

  export type ReturnRequestCountAggregateInputType = {
    id?: true
    orderItemId?: true
    reason?: true
    status?: true
    requestedAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type ReturnRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnRequest to aggregate.
     */
    where?: ReturnRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnRequests
    **/
    _count?: true | ReturnRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnRequestMaxAggregateInputType
  }

  export type GetReturnRequestAggregateType<T extends ReturnRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnRequest[P]>
      : GetScalarType<T[P], AggregateReturnRequest[P]>
  }




  export type ReturnRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnRequestWhereInput
    orderBy?: ReturnRequestOrderByWithAggregationInput | ReturnRequestOrderByWithAggregationInput[]
    by: ReturnRequestScalarFieldEnum[] | ReturnRequestScalarFieldEnum
    having?: ReturnRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnRequestCountAggregateInputType | true
    _min?: ReturnRequestMinAggregateInputType
    _max?: ReturnRequestMaxAggregateInputType
  }

  export type ReturnRequestGroupByOutputType = {
    id: string
    orderItemId: string
    reason: string
    status: $Enums.ReturnRequest_status
    requestedAt: Date
    resolvedAt: Date | null
    _count: ReturnRequestCountAggregateOutputType | null
    _min: ReturnRequestMinAggregateOutputType | null
    _max: ReturnRequestMaxAggregateOutputType | null
  }

  type GetReturnRequestGroupByPayload<T extends ReturnRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnRequestGroupByOutputType[P]>
        }
      >
    >


  export type ReturnRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    reason?: boolean
    status?: boolean
    requestedAt?: boolean
    resolvedAt?: boolean
    OrderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnRequest"]>



  export type ReturnRequestSelectScalar = {
    id?: boolean
    orderItemId?: boolean
    reason?: boolean
    status?: boolean
    requestedAt?: boolean
    resolvedAt?: boolean
  }

  export type ReturnRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderItemId" | "reason" | "status" | "requestedAt" | "resolvedAt", ExtArgs["result"]["returnRequest"]>
  export type ReturnRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
  }

  export type $ReturnRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReturnRequest"
    objects: {
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderItemId: string
      reason: string
      status: $Enums.ReturnRequest_status
      requestedAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["returnRequest"]>
    composites: {}
  }

  type ReturnRequestGetPayload<S extends boolean | null | undefined | ReturnRequestDefaultArgs> = $Result.GetResult<Prisma.$ReturnRequestPayload, S>

  type ReturnRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReturnRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReturnRequestCountAggregateInputType | true
    }

  export interface ReturnRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReturnRequest'], meta: { name: 'ReturnRequest' } }
    /**
     * Find zero or one ReturnRequest that matches the filter.
     * @param {ReturnRequestFindUniqueArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnRequestFindUniqueArgs>(args: SelectSubset<T, ReturnRequestFindUniqueArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReturnRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReturnRequestFindUniqueOrThrowArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ReturnRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestFindFirstArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnRequestFindFirstArgs>(args?: SelectSubset<T, ReturnRequestFindFirstArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestFindFirstOrThrowArgs} args - Arguments to find a ReturnRequest
     * @example
     * // Get one ReturnRequest
     * const returnRequest = await prisma.returnRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ReturnRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReturnRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnRequests
     * const returnRequests = await prisma.returnRequest.findMany()
     * 
     * // Get first 10 ReturnRequests
     * const returnRequests = await prisma.returnRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnRequestWithIdOnly = await prisma.returnRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReturnRequestFindManyArgs>(args?: SelectSubset<T, ReturnRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReturnRequest.
     * @param {ReturnRequestCreateArgs} args - Arguments to create a ReturnRequest.
     * @example
     * // Create one ReturnRequest
     * const ReturnRequest = await prisma.returnRequest.create({
     *   data: {
     *     // ... data to create a ReturnRequest
     *   }
     * })
     * 
     */
    create<T extends ReturnRequestCreateArgs>(args: SelectSubset<T, ReturnRequestCreateArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReturnRequests.
     * @param {ReturnRequestCreateManyArgs} args - Arguments to create many ReturnRequests.
     * @example
     * // Create many ReturnRequests
     * const returnRequest = await prisma.returnRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReturnRequestCreateManyArgs>(args?: SelectSubset<T, ReturnRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReturnRequest.
     * @param {ReturnRequestDeleteArgs} args - Arguments to delete one ReturnRequest.
     * @example
     * // Delete one ReturnRequest
     * const ReturnRequest = await prisma.returnRequest.delete({
     *   where: {
     *     // ... filter to delete one ReturnRequest
     *   }
     * })
     * 
     */
    delete<T extends ReturnRequestDeleteArgs>(args: SelectSubset<T, ReturnRequestDeleteArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReturnRequest.
     * @param {ReturnRequestUpdateArgs} args - Arguments to update one ReturnRequest.
     * @example
     * // Update one ReturnRequest
     * const returnRequest = await prisma.returnRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReturnRequestUpdateArgs>(args: SelectSubset<T, ReturnRequestUpdateArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReturnRequests.
     * @param {ReturnRequestDeleteManyArgs} args - Arguments to filter ReturnRequests to delete.
     * @example
     * // Delete a few ReturnRequests
     * const { count } = await prisma.returnRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReturnRequestDeleteManyArgs>(args?: SelectSubset<T, ReturnRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnRequests
     * const returnRequest = await prisma.returnRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReturnRequestUpdateManyArgs>(args: SelectSubset<T, ReturnRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReturnRequest.
     * @param {ReturnRequestUpsertArgs} args - Arguments to update or create a ReturnRequest.
     * @example
     * // Update or create a ReturnRequest
     * const returnRequest = await prisma.returnRequest.upsert({
     *   create: {
     *     // ... data to create a ReturnRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnRequest we want to update
     *   }
     * })
     */
    upsert<T extends ReturnRequestUpsertArgs>(args: SelectSubset<T, ReturnRequestUpsertArgs<ExtArgs>>): Prisma__ReturnRequestClient<$Result.GetResult<Prisma.$ReturnRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReturnRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestCountArgs} args - Arguments to filter ReturnRequests to count.
     * @example
     * // Count the number of ReturnRequests
     * const count = await prisma.returnRequest.count({
     *   where: {
     *     // ... the filter for the ReturnRequests we want to count
     *   }
     * })
    **/
    count<T extends ReturnRequestCountArgs>(
      args?: Subset<T, ReturnRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnRequestAggregateArgs>(args: Subset<T, ReturnRequestAggregateArgs>): Prisma.PrismaPromise<GetReturnRequestAggregateType<T>>

    /**
     * Group by ReturnRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnRequestGroupByArgs['orderBy'] }
        : { orderBy?: ReturnRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReturnRequest model
   */
  readonly fields: ReturnRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReturnRequest model
   */ 
  interface ReturnRequestFieldRefs {
    readonly id: FieldRef<"ReturnRequest", 'String'>
    readonly orderItemId: FieldRef<"ReturnRequest", 'String'>
    readonly reason: FieldRef<"ReturnRequest", 'String'>
    readonly status: FieldRef<"ReturnRequest", 'ReturnRequest_status'>
    readonly requestedAt: FieldRef<"ReturnRequest", 'DateTime'>
    readonly resolvedAt: FieldRef<"ReturnRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReturnRequest findUnique
   */
  export type ReturnRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where: ReturnRequestWhereUniqueInput
  }

  /**
   * ReturnRequest findUniqueOrThrow
   */
  export type ReturnRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where: ReturnRequestWhereUniqueInput
  }

  /**
   * ReturnRequest findFirst
   */
  export type ReturnRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where?: ReturnRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnRequests.
     */
    cursor?: ReturnRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnRequests.
     */
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[]
  }

  /**
   * ReturnRequest findFirstOrThrow
   */
  export type ReturnRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequest to fetch.
     */
    where?: ReturnRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnRequests.
     */
    cursor?: ReturnRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnRequests.
     */
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[]
  }

  /**
   * ReturnRequest findMany
   */
  export type ReturnRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter, which ReturnRequests to fetch.
     */
    where?: ReturnRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnRequests to fetch.
     */
    orderBy?: ReturnRequestOrderByWithRelationInput | ReturnRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnRequests.
     */
    cursor?: ReturnRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnRequests.
     */
    skip?: number
    distinct?: ReturnRequestScalarFieldEnum | ReturnRequestScalarFieldEnum[]
  }

  /**
   * ReturnRequest create
   */
  export type ReturnRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ReturnRequest.
     */
    data: XOR<ReturnRequestCreateInput, ReturnRequestUncheckedCreateInput>
  }

  /**
   * ReturnRequest createMany
   */
  export type ReturnRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnRequests.
     */
    data: ReturnRequestCreateManyInput | ReturnRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReturnRequest update
   */
  export type ReturnRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ReturnRequest.
     */
    data: XOR<ReturnRequestUpdateInput, ReturnRequestUncheckedUpdateInput>
    /**
     * Choose, which ReturnRequest to update.
     */
    where: ReturnRequestWhereUniqueInput
  }

  /**
   * ReturnRequest updateMany
   */
  export type ReturnRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnRequests.
     */
    data: XOR<ReturnRequestUpdateManyMutationInput, ReturnRequestUncheckedUpdateManyInput>
    /**
     * Filter which ReturnRequests to update
     */
    where?: ReturnRequestWhereInput
    /**
     * Limit how many ReturnRequests to update.
     */
    limit?: number
  }

  /**
   * ReturnRequest upsert
   */
  export type ReturnRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ReturnRequest to update in case it exists.
     */
    where: ReturnRequestWhereUniqueInput
    /**
     * In case the ReturnRequest found by the `where` argument doesn't exist, create a new ReturnRequest with this data.
     */
    create: XOR<ReturnRequestCreateInput, ReturnRequestUncheckedCreateInput>
    /**
     * In case the ReturnRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnRequestUpdateInput, ReturnRequestUncheckedUpdateInput>
  }

  /**
   * ReturnRequest delete
   */
  export type ReturnRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
    /**
     * Filter which ReturnRequest to delete.
     */
    where: ReturnRequestWhereUniqueInput
  }

  /**
   * ReturnRequest deleteMany
   */
  export type ReturnRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnRequests to delete
     */
    where?: ReturnRequestWhereInput
    /**
     * Limit how many ReturnRequests to delete.
     */
    limit?: number
  }

  /**
   * ReturnRequest without action
   */
  export type ReturnRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnRequest
     */
    select?: ReturnRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnRequest
     */
    omit?: ReturnRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnRequestInclude<ExtArgs> | null
  }


  /**
   * Model Rewards
   */

  export type AggregateRewards = {
    _count: RewardsCountAggregateOutputType | null
    _min: RewardsMinAggregateOutputType | null
    _max: RewardsMaxAggregateOutputType | null
  }

  export type RewardsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    code: string | null
    description: string | null
  }

  export type RewardsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    code: string | null
    description: string | null
  }

  export type RewardsCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    code: number
    description: number
    _all: number
  }


  export type RewardsMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    code?: true
    description?: true
  }

  export type RewardsMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    code?: true
    description?: true
  }

  export type RewardsCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    code?: true
    description?: true
    _all?: true
  }

  export type RewardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rewards to aggregate.
     */
    where?: RewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardsOrderByWithRelationInput | RewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rewards
    **/
    _count?: true | RewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardsMaxAggregateInputType
  }

  export type GetRewardsAggregateType<T extends RewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateRewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewards[P]>
      : GetScalarType<T[P], AggregateRewards[P]>
  }




  export type RewardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardsWhereInput
    orderBy?: RewardsOrderByWithAggregationInput | RewardsOrderByWithAggregationInput[]
    by: RewardsScalarFieldEnum[] | RewardsScalarFieldEnum
    having?: RewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardsCountAggregateInputType | true
    _min?: RewardsMinAggregateInputType
    _max?: RewardsMaxAggregateInputType
  }

  export type RewardsGroupByOutputType = {
    id: string
    userId: string
    title: string | null
    code: string | null
    description: string | null
    _count: RewardsCountAggregateOutputType | null
    _min: RewardsMinAggregateOutputType | null
    _max: RewardsMaxAggregateOutputType | null
  }

  type GetRewardsGroupByPayload<T extends RewardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardsGroupByOutputType[P]>
            : GetScalarType<T[P], RewardsGroupByOutputType[P]>
        }
      >
    >


  export type RewardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    code?: boolean
    description?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewards"]>



  export type RewardsSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    code?: boolean
    description?: boolean
  }

  export type RewardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "code" | "description", ExtArgs["result"]["rewards"]>
  export type RewardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RewardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rewards"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string | null
      code: string | null
      description: string | null
    }, ExtArgs["result"]["rewards"]>
    composites: {}
  }

  type RewardsGetPayload<S extends boolean | null | undefined | RewardsDefaultArgs> = $Result.GetResult<Prisma.$RewardsPayload, S>

  type RewardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardsCountAggregateInputType | true
    }

  export interface RewardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rewards'], meta: { name: 'Rewards' } }
    /**
     * Find zero or one Rewards that matches the filter.
     * @param {RewardsFindUniqueArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardsFindUniqueArgs>(args: SelectSubset<T, RewardsFindUniqueArgs<ExtArgs>>): Prisma__RewardsClient<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rewards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardsFindUniqueOrThrowArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardsFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardsClient<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardsFindFirstArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardsFindFirstArgs>(args?: SelectSubset<T, RewardsFindFirstArgs<ExtArgs>>): Prisma__RewardsClient<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rewards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardsFindFirstOrThrowArgs} args - Arguments to find a Rewards
     * @example
     * // Get one Rewards
     * const rewards = await prisma.rewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardsFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardsClient<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.rewards.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.rewards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardsWithIdOnly = await prisma.rewards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardsFindManyArgs>(args?: SelectSubset<T, RewardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rewards.
     * @param {RewardsCreateArgs} args - Arguments to create a Rewards.
     * @example
     * // Create one Rewards
     * const Rewards = await prisma.rewards.create({
     *   data: {
     *     // ... data to create a Rewards
     *   }
     * })
     * 
     */
    create<T extends RewardsCreateArgs>(args: SelectSubset<T, RewardsCreateArgs<ExtArgs>>): Prisma__RewardsClient<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rewards.
     * @param {RewardsCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const rewards = await prisma.rewards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardsCreateManyArgs>(args?: SelectSubset<T, RewardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rewards.
     * @param {RewardsDeleteArgs} args - Arguments to delete one Rewards.
     * @example
     * // Delete one Rewards
     * const Rewards = await prisma.rewards.delete({
     *   where: {
     *     // ... filter to delete one Rewards
     *   }
     * })
     * 
     */
    delete<T extends RewardsDeleteArgs>(args: SelectSubset<T, RewardsDeleteArgs<ExtArgs>>): Prisma__RewardsClient<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rewards.
     * @param {RewardsUpdateArgs} args - Arguments to update one Rewards.
     * @example
     * // Update one Rewards
     * const rewards = await prisma.rewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardsUpdateArgs>(args: SelectSubset<T, RewardsUpdateArgs<ExtArgs>>): Prisma__RewardsClient<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rewards.
     * @param {RewardsDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.rewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardsDeleteManyArgs>(args?: SelectSubset<T, RewardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const rewards = await prisma.rewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardsUpdateManyArgs>(args: SelectSubset<T, RewardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rewards.
     * @param {RewardsUpsertArgs} args - Arguments to update or create a Rewards.
     * @example
     * // Update or create a Rewards
     * const rewards = await prisma.rewards.upsert({
     *   create: {
     *     // ... data to create a Rewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rewards we want to update
     *   }
     * })
     */
    upsert<T extends RewardsUpsertArgs>(args: SelectSubset<T, RewardsUpsertArgs<ExtArgs>>): Prisma__RewardsClient<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardsCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.rewards.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends RewardsCountArgs>(
      args?: Subset<T, RewardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardsAggregateArgs>(args: Subset<T, RewardsAggregateArgs>): Prisma.PrismaPromise<GetRewardsAggregateType<T>>

    /**
     * Group by Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardsGroupByArgs['orderBy'] }
        : { orderBy?: RewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rewards model
   */
  readonly fields: RewardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rewards model
   */ 
  interface RewardsFieldRefs {
    readonly id: FieldRef<"Rewards", 'String'>
    readonly userId: FieldRef<"Rewards", 'String'>
    readonly title: FieldRef<"Rewards", 'String'>
    readonly code: FieldRef<"Rewards", 'String'>
    readonly description: FieldRef<"Rewards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Rewards findUnique
   */
  export type RewardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where: RewardsWhereUniqueInput
  }

  /**
   * Rewards findUniqueOrThrow
   */
  export type RewardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where: RewardsWhereUniqueInput
  }

  /**
   * Rewards findFirst
   */
  export type RewardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardsOrderByWithRelationInput | RewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * Rewards findFirstOrThrow
   */
  export type RewardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardsOrderByWithRelationInput | RewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rewards.
     */
    cursor?: RewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rewards.
     */
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * Rewards findMany
   */
  export type RewardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    /**
     * Filter, which Rewards to fetch.
     */
    where?: RewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rewards to fetch.
     */
    orderBy?: RewardsOrderByWithRelationInput | RewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rewards.
     */
    cursor?: RewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rewards.
     */
    skip?: number
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * Rewards create
   */
  export type RewardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    /**
     * The data needed to create a Rewards.
     */
    data: XOR<RewardsCreateInput, RewardsUncheckedCreateInput>
  }

  /**
   * Rewards createMany
   */
  export type RewardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rewards.
     */
    data: RewardsCreateManyInput | RewardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rewards update
   */
  export type RewardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    /**
     * The data needed to update a Rewards.
     */
    data: XOR<RewardsUpdateInput, RewardsUncheckedUpdateInput>
    /**
     * Choose, which Rewards to update.
     */
    where: RewardsWhereUniqueInput
  }

  /**
   * Rewards updateMany
   */
  export type RewardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rewards.
     */
    data: XOR<RewardsUpdateManyMutationInput, RewardsUncheckedUpdateManyInput>
    /**
     * Filter which Rewards to update
     */
    where?: RewardsWhereInput
    /**
     * Limit how many Rewards to update.
     */
    limit?: number
  }

  /**
   * Rewards upsert
   */
  export type RewardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    /**
     * The filter to search for the Rewards to update in case it exists.
     */
    where: RewardsWhereUniqueInput
    /**
     * In case the Rewards found by the `where` argument doesn't exist, create a new Rewards with this data.
     */
    create: XOR<RewardsCreateInput, RewardsUncheckedCreateInput>
    /**
     * In case the Rewards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardsUpdateInput, RewardsUncheckedUpdateInput>
  }

  /**
   * Rewards delete
   */
  export type RewardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    /**
     * Filter which Rewards to delete.
     */
    where: RewardsWhereUniqueInput
  }

  /**
   * Rewards deleteMany
   */
  export type RewardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rewards to delete
     */
    where?: RewardsWhereInput
    /**
     * Limit how many Rewards to delete.
     */
    limit?: number
  }

  /**
   * Rewards without action
   */
  export type RewardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
  }


  /**
   * Model SearchQuery
   */

  export type AggregateSearchQuery = {
    _count: SearchQueryCountAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  export type SearchQueryMinAggregateOutputType = {
    id: string | null
    query: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type SearchQueryMaxAggregateOutputType = {
    id: string | null
    query: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type SearchQueryCountAggregateOutputType = {
    id: number
    query: number
    createdAt: number
    userId: number
    _all: number
  }


  export type SearchQueryMinAggregateInputType = {
    id?: true
    query?: true
    createdAt?: true
    userId?: true
  }

  export type SearchQueryMaxAggregateInputType = {
    id?: true
    query?: true
    createdAt?: true
    userId?: true
  }

  export type SearchQueryCountAggregateInputType = {
    id?: true
    query?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type SearchQueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQuery to aggregate.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchQueries
    **/
    _count?: true | SearchQueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchQueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchQueryMaxAggregateInputType
  }

  export type GetSearchQueryAggregateType<T extends SearchQueryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchQuery[P]>
      : GetScalarType<T[P], AggregateSearchQuery[P]>
  }




  export type SearchQueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchQueryWhereInput
    orderBy?: SearchQueryOrderByWithAggregationInput | SearchQueryOrderByWithAggregationInput[]
    by: SearchQueryScalarFieldEnum[] | SearchQueryScalarFieldEnum
    having?: SearchQueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchQueryCountAggregateInputType | true
    _min?: SearchQueryMinAggregateInputType
    _max?: SearchQueryMaxAggregateInputType
  }

  export type SearchQueryGroupByOutputType = {
    id: string
    query: string
    createdAt: Date
    userId: string
    _count: SearchQueryCountAggregateOutputType | null
    _min: SearchQueryMinAggregateOutputType | null
    _max: SearchQueryMaxAggregateOutputType | null
  }

  type GetSearchQueryGroupByPayload<T extends SearchQueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchQueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchQueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchQueryGroupByOutputType[P]>
        }
      >
    >


  export type SearchQuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    createdAt?: boolean
    userId?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchQuery"]>



  export type SearchQuerySelectScalar = {
    id?: boolean
    query?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type SearchQueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "query" | "createdAt" | "userId", ExtArgs["result"]["searchQuery"]>
  export type SearchQueryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SearchQueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchQuery"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["searchQuery"]>
    composites: {}
  }

  type SearchQueryGetPayload<S extends boolean | null | undefined | SearchQueryDefaultArgs> = $Result.GetResult<Prisma.$SearchQueryPayload, S>

  type SearchQueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchQueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchQueryCountAggregateInputType | true
    }

  export interface SearchQueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchQuery'], meta: { name: 'SearchQuery' } }
    /**
     * Find zero or one SearchQuery that matches the filter.
     * @param {SearchQueryFindUniqueArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchQueryFindUniqueArgs>(args: SelectSubset<T, SearchQueryFindUniqueArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchQuery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchQueryFindUniqueOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchQueryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchQueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchQuery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchQueryFindFirstArgs>(args?: SelectSubset<T, SearchQueryFindFirstArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchQuery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindFirstOrThrowArgs} args - Arguments to find a SearchQuery
     * @example
     * // Get one SearchQuery
     * const searchQuery = await prisma.searchQuery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchQueryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchQueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchQueries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany()
     * 
     * // Get first 10 SearchQueries
     * const searchQueries = await prisma.searchQuery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchQueryWithIdOnly = await prisma.searchQuery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchQueryFindManyArgs>(args?: SelectSubset<T, SearchQueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchQuery.
     * @param {SearchQueryCreateArgs} args - Arguments to create a SearchQuery.
     * @example
     * // Create one SearchQuery
     * const SearchQuery = await prisma.searchQuery.create({
     *   data: {
     *     // ... data to create a SearchQuery
     *   }
     * })
     * 
     */
    create<T extends SearchQueryCreateArgs>(args: SelectSubset<T, SearchQueryCreateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchQueries.
     * @param {SearchQueryCreateManyArgs} args - Arguments to create many SearchQueries.
     * @example
     * // Create many SearchQueries
     * const searchQuery = await prisma.searchQuery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchQueryCreateManyArgs>(args?: SelectSubset<T, SearchQueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SearchQuery.
     * @param {SearchQueryDeleteArgs} args - Arguments to delete one SearchQuery.
     * @example
     * // Delete one SearchQuery
     * const SearchQuery = await prisma.searchQuery.delete({
     *   where: {
     *     // ... filter to delete one SearchQuery
     *   }
     * })
     * 
     */
    delete<T extends SearchQueryDeleteArgs>(args: SelectSubset<T, SearchQueryDeleteArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchQuery.
     * @param {SearchQueryUpdateArgs} args - Arguments to update one SearchQuery.
     * @example
     * // Update one SearchQuery
     * const searchQuery = await prisma.searchQuery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchQueryUpdateArgs>(args: SelectSubset<T, SearchQueryUpdateArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchQueries.
     * @param {SearchQueryDeleteManyArgs} args - Arguments to filter SearchQueries to delete.
     * @example
     * // Delete a few SearchQueries
     * const { count } = await prisma.searchQuery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchQueryDeleteManyArgs>(args?: SelectSubset<T, SearchQueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchQueries
     * const searchQuery = await prisma.searchQuery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchQueryUpdateManyArgs>(args: SelectSubset<T, SearchQueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchQuery.
     * @param {SearchQueryUpsertArgs} args - Arguments to update or create a SearchQuery.
     * @example
     * // Update or create a SearchQuery
     * const searchQuery = await prisma.searchQuery.upsert({
     *   create: {
     *     // ... data to create a SearchQuery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchQuery we want to update
     *   }
     * })
     */
    upsert<T extends SearchQueryUpsertArgs>(args: SelectSubset<T, SearchQueryUpsertArgs<ExtArgs>>): Prisma__SearchQueryClient<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryCountArgs} args - Arguments to filter SearchQueries to count.
     * @example
     * // Count the number of SearchQueries
     * const count = await prisma.searchQuery.count({
     *   where: {
     *     // ... the filter for the SearchQueries we want to count
     *   }
     * })
    **/
    count<T extends SearchQueryCountArgs>(
      args?: Subset<T, SearchQueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchQueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchQueryAggregateArgs>(args: Subset<T, SearchQueryAggregateArgs>): Prisma.PrismaPromise<GetSearchQueryAggregateType<T>>

    /**
     * Group by SearchQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchQueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchQueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchQueryGroupByArgs['orderBy'] }
        : { orderBy?: SearchQueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchQueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchQuery model
   */
  readonly fields: SearchQueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchQuery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchQueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchQuery model
   */ 
  interface SearchQueryFieldRefs {
    readonly id: FieldRef<"SearchQuery", 'String'>
    readonly query: FieldRef<"SearchQuery", 'String'>
    readonly createdAt: FieldRef<"SearchQuery", 'DateTime'>
    readonly userId: FieldRef<"SearchQuery", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SearchQuery findUnique
   */
  export type SearchQueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findUniqueOrThrow
   */
  export type SearchQueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery findFirst
   */
  export type SearchQueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findFirstOrThrow
   */
  export type SearchQueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQuery to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchQueries.
     */
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery findMany
   */
  export type SearchQueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter, which SearchQueries to fetch.
     */
    where?: SearchQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchQueries to fetch.
     */
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchQueries.
     */
    cursor?: SearchQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchQueries.
     */
    skip?: number
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * SearchQuery create
   */
  export type SearchQueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchQuery.
     */
    data: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
  }

  /**
   * SearchQuery createMany
   */
  export type SearchQueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchQueries.
     */
    data: SearchQueryCreateManyInput | SearchQueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchQuery update
   */
  export type SearchQueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchQuery.
     */
    data: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
    /**
     * Choose, which SearchQuery to update.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery updateMany
   */
  export type SearchQueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchQueries.
     */
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyInput>
    /**
     * Filter which SearchQueries to update
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to update.
     */
    limit?: number
  }

  /**
   * SearchQuery upsert
   */
  export type SearchQueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchQuery to update in case it exists.
     */
    where: SearchQueryWhereUniqueInput
    /**
     * In case the SearchQuery found by the `where` argument doesn't exist, create a new SearchQuery with this data.
     */
    create: XOR<SearchQueryCreateInput, SearchQueryUncheckedCreateInput>
    /**
     * In case the SearchQuery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchQueryUpdateInput, SearchQueryUncheckedUpdateInput>
  }

  /**
   * SearchQuery delete
   */
  export type SearchQueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    /**
     * Filter which SearchQuery to delete.
     */
    where: SearchQueryWhereUniqueInput
  }

  /**
   * SearchQuery deleteMany
   */
  export type SearchQueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchQueries to delete
     */
    where?: SearchQueryWhereInput
    /**
     * Limit how many SearchQueries to delete.
     */
    limit?: number
  }

  /**
   * SearchQuery without action
   */
  export type SearchQueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    createdAt: Date
    updatedAt: Date
    expiresAt: Date | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "createdAt" | "updatedAt" | "expiresAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      createdAt: Date
      updatedAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model ShopByOccasion
   */

  export type AggregateShopByOccasion = {
    _count: ShopByOccasionCountAggregateOutputType | null
    _min: ShopByOccasionMinAggregateOutputType | null
    _max: ShopByOccasionMaxAggregateOutputType | null
  }

  export type ShopByOccasionMinAggregateOutputType = {
    id: string | null
    occasionName: string | null
    categoryHyperLinks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopByOccasionMaxAggregateOutputType = {
    id: string | null
    occasionName: string | null
    categoryHyperLinks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopByOccasionCountAggregateOutputType = {
    id: number
    occasionName: number
    categoryHyperLinks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopByOccasionMinAggregateInputType = {
    id?: true
    occasionName?: true
    categoryHyperLinks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopByOccasionMaxAggregateInputType = {
    id?: true
    occasionName?: true
    categoryHyperLinks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopByOccasionCountAggregateInputType = {
    id?: true
    occasionName?: true
    categoryHyperLinks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopByOccasionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopByOccasion to aggregate.
     */
    where?: ShopByOccasionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopByOccasions to fetch.
     */
    orderBy?: ShopByOccasionOrderByWithRelationInput | ShopByOccasionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopByOccasionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopByOccasions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopByOccasions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopByOccasions
    **/
    _count?: true | ShopByOccasionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopByOccasionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopByOccasionMaxAggregateInputType
  }

  export type GetShopByOccasionAggregateType<T extends ShopByOccasionAggregateArgs> = {
        [P in keyof T & keyof AggregateShopByOccasion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopByOccasion[P]>
      : GetScalarType<T[P], AggregateShopByOccasion[P]>
  }




  export type ShopByOccasionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopByOccasionWhereInput
    orderBy?: ShopByOccasionOrderByWithAggregationInput | ShopByOccasionOrderByWithAggregationInput[]
    by: ShopByOccasionScalarFieldEnum[] | ShopByOccasionScalarFieldEnum
    having?: ShopByOccasionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopByOccasionCountAggregateInputType | true
    _min?: ShopByOccasionMinAggregateInputType
    _max?: ShopByOccasionMaxAggregateInputType
  }

  export type ShopByOccasionGroupByOutputType = {
    id: string
    occasionName: string | null
    categoryHyperLinks: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShopByOccasionCountAggregateOutputType | null
    _min: ShopByOccasionMinAggregateOutputType | null
    _max: ShopByOccasionMaxAggregateOutputType | null
  }

  type GetShopByOccasionGroupByPayload<T extends ShopByOccasionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopByOccasionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopByOccasionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopByOccasionGroupByOutputType[P]>
            : GetScalarType<T[P], ShopByOccasionGroupByOutputType[P]>
        }
      >
    >


  export type ShopByOccasionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    occasionName?: boolean
    categoryHyperLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ShopByOccasionProduct?: boolean | ShopByOccasion$ShopByOccasionProductArgs<ExtArgs>
    _count?: boolean | ShopByOccasionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopByOccasion"]>



  export type ShopByOccasionSelectScalar = {
    id?: boolean
    occasionName?: boolean
    categoryHyperLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopByOccasionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "occasionName" | "categoryHyperLinks" | "createdAt" | "updatedAt", ExtArgs["result"]["shopByOccasion"]>
  export type ShopByOccasionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopByOccasionProduct?: boolean | ShopByOccasion$ShopByOccasionProductArgs<ExtArgs>
    _count?: boolean | ShopByOccasionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShopByOccasionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopByOccasion"
    objects: {
      ShopByOccasionProduct: Prisma.$ShopByOccasionProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      occasionName: string | null
      categoryHyperLinks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopByOccasion"]>
    composites: {}
  }

  type ShopByOccasionGetPayload<S extends boolean | null | undefined | ShopByOccasionDefaultArgs> = $Result.GetResult<Prisma.$ShopByOccasionPayload, S>

  type ShopByOccasionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopByOccasionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopByOccasionCountAggregateInputType | true
    }

  export interface ShopByOccasionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopByOccasion'], meta: { name: 'ShopByOccasion' } }
    /**
     * Find zero or one ShopByOccasion that matches the filter.
     * @param {ShopByOccasionFindUniqueArgs} args - Arguments to find a ShopByOccasion
     * @example
     * // Get one ShopByOccasion
     * const shopByOccasion = await prisma.shopByOccasion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopByOccasionFindUniqueArgs>(args: SelectSubset<T, ShopByOccasionFindUniqueArgs<ExtArgs>>): Prisma__ShopByOccasionClient<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopByOccasion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopByOccasionFindUniqueOrThrowArgs} args - Arguments to find a ShopByOccasion
     * @example
     * // Get one ShopByOccasion
     * const shopByOccasion = await prisma.shopByOccasion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopByOccasionFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopByOccasionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopByOccasionClient<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopByOccasion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionFindFirstArgs} args - Arguments to find a ShopByOccasion
     * @example
     * // Get one ShopByOccasion
     * const shopByOccasion = await prisma.shopByOccasion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopByOccasionFindFirstArgs>(args?: SelectSubset<T, ShopByOccasionFindFirstArgs<ExtArgs>>): Prisma__ShopByOccasionClient<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopByOccasion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionFindFirstOrThrowArgs} args - Arguments to find a ShopByOccasion
     * @example
     * // Get one ShopByOccasion
     * const shopByOccasion = await prisma.shopByOccasion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopByOccasionFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopByOccasionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopByOccasionClient<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopByOccasions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopByOccasions
     * const shopByOccasions = await prisma.shopByOccasion.findMany()
     * 
     * // Get first 10 ShopByOccasions
     * const shopByOccasions = await prisma.shopByOccasion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopByOccasionWithIdOnly = await prisma.shopByOccasion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopByOccasionFindManyArgs>(args?: SelectSubset<T, ShopByOccasionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopByOccasion.
     * @param {ShopByOccasionCreateArgs} args - Arguments to create a ShopByOccasion.
     * @example
     * // Create one ShopByOccasion
     * const ShopByOccasion = await prisma.shopByOccasion.create({
     *   data: {
     *     // ... data to create a ShopByOccasion
     *   }
     * })
     * 
     */
    create<T extends ShopByOccasionCreateArgs>(args: SelectSubset<T, ShopByOccasionCreateArgs<ExtArgs>>): Prisma__ShopByOccasionClient<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopByOccasions.
     * @param {ShopByOccasionCreateManyArgs} args - Arguments to create many ShopByOccasions.
     * @example
     * // Create many ShopByOccasions
     * const shopByOccasion = await prisma.shopByOccasion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopByOccasionCreateManyArgs>(args?: SelectSubset<T, ShopByOccasionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopByOccasion.
     * @param {ShopByOccasionDeleteArgs} args - Arguments to delete one ShopByOccasion.
     * @example
     * // Delete one ShopByOccasion
     * const ShopByOccasion = await prisma.shopByOccasion.delete({
     *   where: {
     *     // ... filter to delete one ShopByOccasion
     *   }
     * })
     * 
     */
    delete<T extends ShopByOccasionDeleteArgs>(args: SelectSubset<T, ShopByOccasionDeleteArgs<ExtArgs>>): Prisma__ShopByOccasionClient<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopByOccasion.
     * @param {ShopByOccasionUpdateArgs} args - Arguments to update one ShopByOccasion.
     * @example
     * // Update one ShopByOccasion
     * const shopByOccasion = await prisma.shopByOccasion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopByOccasionUpdateArgs>(args: SelectSubset<T, ShopByOccasionUpdateArgs<ExtArgs>>): Prisma__ShopByOccasionClient<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopByOccasions.
     * @param {ShopByOccasionDeleteManyArgs} args - Arguments to filter ShopByOccasions to delete.
     * @example
     * // Delete a few ShopByOccasions
     * const { count } = await prisma.shopByOccasion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopByOccasionDeleteManyArgs>(args?: SelectSubset<T, ShopByOccasionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopByOccasions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopByOccasions
     * const shopByOccasion = await prisma.shopByOccasion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopByOccasionUpdateManyArgs>(args: SelectSubset<T, ShopByOccasionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopByOccasion.
     * @param {ShopByOccasionUpsertArgs} args - Arguments to update or create a ShopByOccasion.
     * @example
     * // Update or create a ShopByOccasion
     * const shopByOccasion = await prisma.shopByOccasion.upsert({
     *   create: {
     *     // ... data to create a ShopByOccasion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopByOccasion we want to update
     *   }
     * })
     */
    upsert<T extends ShopByOccasionUpsertArgs>(args: SelectSubset<T, ShopByOccasionUpsertArgs<ExtArgs>>): Prisma__ShopByOccasionClient<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopByOccasions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionCountArgs} args - Arguments to filter ShopByOccasions to count.
     * @example
     * // Count the number of ShopByOccasions
     * const count = await prisma.shopByOccasion.count({
     *   where: {
     *     // ... the filter for the ShopByOccasions we want to count
     *   }
     * })
    **/
    count<T extends ShopByOccasionCountArgs>(
      args?: Subset<T, ShopByOccasionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopByOccasionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopByOccasion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopByOccasionAggregateArgs>(args: Subset<T, ShopByOccasionAggregateArgs>): Prisma.PrismaPromise<GetShopByOccasionAggregateType<T>>

    /**
     * Group by ShopByOccasion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopByOccasionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopByOccasionGroupByArgs['orderBy'] }
        : { orderBy?: ShopByOccasionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopByOccasionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopByOccasionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopByOccasion model
   */
  readonly fields: ShopByOccasionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopByOccasion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopByOccasionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ShopByOccasionProduct<T extends ShopByOccasion$ShopByOccasionProductArgs<ExtArgs> = {}>(args?: Subset<T, ShopByOccasion$ShopByOccasionProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopByOccasion model
   */ 
  interface ShopByOccasionFieldRefs {
    readonly id: FieldRef<"ShopByOccasion", 'String'>
    readonly occasionName: FieldRef<"ShopByOccasion", 'String'>
    readonly categoryHyperLinks: FieldRef<"ShopByOccasion", 'String'>
    readonly createdAt: FieldRef<"ShopByOccasion", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopByOccasion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopByOccasion findUnique
   */
  export type ShopByOccasionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasion to fetch.
     */
    where: ShopByOccasionWhereUniqueInput
  }

  /**
   * ShopByOccasion findUniqueOrThrow
   */
  export type ShopByOccasionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasion to fetch.
     */
    where: ShopByOccasionWhereUniqueInput
  }

  /**
   * ShopByOccasion findFirst
   */
  export type ShopByOccasionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasion to fetch.
     */
    where?: ShopByOccasionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopByOccasions to fetch.
     */
    orderBy?: ShopByOccasionOrderByWithRelationInput | ShopByOccasionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopByOccasions.
     */
    cursor?: ShopByOccasionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopByOccasions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopByOccasions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopByOccasions.
     */
    distinct?: ShopByOccasionScalarFieldEnum | ShopByOccasionScalarFieldEnum[]
  }

  /**
   * ShopByOccasion findFirstOrThrow
   */
  export type ShopByOccasionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasion to fetch.
     */
    where?: ShopByOccasionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopByOccasions to fetch.
     */
    orderBy?: ShopByOccasionOrderByWithRelationInput | ShopByOccasionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopByOccasions.
     */
    cursor?: ShopByOccasionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopByOccasions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopByOccasions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopByOccasions.
     */
    distinct?: ShopByOccasionScalarFieldEnum | ShopByOccasionScalarFieldEnum[]
  }

  /**
   * ShopByOccasion findMany
   */
  export type ShopByOccasionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasions to fetch.
     */
    where?: ShopByOccasionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopByOccasions to fetch.
     */
    orderBy?: ShopByOccasionOrderByWithRelationInput | ShopByOccasionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopByOccasions.
     */
    cursor?: ShopByOccasionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopByOccasions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopByOccasions.
     */
    skip?: number
    distinct?: ShopByOccasionScalarFieldEnum | ShopByOccasionScalarFieldEnum[]
  }

  /**
   * ShopByOccasion create
   */
  export type ShopByOccasionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopByOccasion.
     */
    data: XOR<ShopByOccasionCreateInput, ShopByOccasionUncheckedCreateInput>
  }

  /**
   * ShopByOccasion createMany
   */
  export type ShopByOccasionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopByOccasions.
     */
    data: ShopByOccasionCreateManyInput | ShopByOccasionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopByOccasion update
   */
  export type ShopByOccasionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopByOccasion.
     */
    data: XOR<ShopByOccasionUpdateInput, ShopByOccasionUncheckedUpdateInput>
    /**
     * Choose, which ShopByOccasion to update.
     */
    where: ShopByOccasionWhereUniqueInput
  }

  /**
   * ShopByOccasion updateMany
   */
  export type ShopByOccasionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopByOccasions.
     */
    data: XOR<ShopByOccasionUpdateManyMutationInput, ShopByOccasionUncheckedUpdateManyInput>
    /**
     * Filter which ShopByOccasions to update
     */
    where?: ShopByOccasionWhereInput
    /**
     * Limit how many ShopByOccasions to update.
     */
    limit?: number
  }

  /**
   * ShopByOccasion upsert
   */
  export type ShopByOccasionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopByOccasion to update in case it exists.
     */
    where: ShopByOccasionWhereUniqueInput
    /**
     * In case the ShopByOccasion found by the `where` argument doesn't exist, create a new ShopByOccasion with this data.
     */
    create: XOR<ShopByOccasionCreateInput, ShopByOccasionUncheckedCreateInput>
    /**
     * In case the ShopByOccasion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopByOccasionUpdateInput, ShopByOccasionUncheckedUpdateInput>
  }

  /**
   * ShopByOccasion delete
   */
  export type ShopByOccasionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    /**
     * Filter which ShopByOccasion to delete.
     */
    where: ShopByOccasionWhereUniqueInput
  }

  /**
   * ShopByOccasion deleteMany
   */
  export type ShopByOccasionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopByOccasions to delete
     */
    where?: ShopByOccasionWhereInput
    /**
     * Limit how many ShopByOccasions to delete.
     */
    limit?: number
  }

  /**
   * ShopByOccasion.ShopByOccasionProduct
   */
  export type ShopByOccasion$ShopByOccasionProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    where?: ShopByOccasionProductWhereInput
    orderBy?: ShopByOccasionProductOrderByWithRelationInput | ShopByOccasionProductOrderByWithRelationInput[]
    cursor?: ShopByOccasionProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopByOccasionProductScalarFieldEnum | ShopByOccasionProductScalarFieldEnum[]
  }

  /**
   * ShopByOccasion without action
   */
  export type ShopByOccasionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
  }


  /**
   * Model ShopByOccasionProduct
   */

  export type AggregateShopByOccasionProduct = {
    _count: ShopByOccasionProductCountAggregateOutputType | null
    _min: ShopByOccasionProductMinAggregateOutputType | null
    _max: ShopByOccasionProductMaxAggregateOutputType | null
  }

  export type ShopByOccasionProductMinAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
    shopByOccasionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopByOccasionProductMaxAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
    shopByOccasionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopByOccasionProductCountAggregateOutputType = {
    id: number
    imageUrl: number
    hyperLink: number
    shopByOccasionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopByOccasionProductMinAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    shopByOccasionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopByOccasionProductMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    shopByOccasionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopByOccasionProductCountAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    shopByOccasionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopByOccasionProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopByOccasionProduct to aggregate.
     */
    where?: ShopByOccasionProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopByOccasionProducts to fetch.
     */
    orderBy?: ShopByOccasionProductOrderByWithRelationInput | ShopByOccasionProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopByOccasionProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopByOccasionProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopByOccasionProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopByOccasionProducts
    **/
    _count?: true | ShopByOccasionProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopByOccasionProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopByOccasionProductMaxAggregateInputType
  }

  export type GetShopByOccasionProductAggregateType<T extends ShopByOccasionProductAggregateArgs> = {
        [P in keyof T & keyof AggregateShopByOccasionProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopByOccasionProduct[P]>
      : GetScalarType<T[P], AggregateShopByOccasionProduct[P]>
  }




  export type ShopByOccasionProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopByOccasionProductWhereInput
    orderBy?: ShopByOccasionProductOrderByWithAggregationInput | ShopByOccasionProductOrderByWithAggregationInput[]
    by: ShopByOccasionProductScalarFieldEnum[] | ShopByOccasionProductScalarFieldEnum
    having?: ShopByOccasionProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopByOccasionProductCountAggregateInputType | true
    _min?: ShopByOccasionProductMinAggregateInputType
    _max?: ShopByOccasionProductMaxAggregateInputType
  }

  export type ShopByOccasionProductGroupByOutputType = {
    id: string
    imageUrl: string
    hyperLink: string
    shopByOccasionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShopByOccasionProductCountAggregateOutputType | null
    _min: ShopByOccasionProductMinAggregateOutputType | null
    _max: ShopByOccasionProductMaxAggregateOutputType | null
  }

  type GetShopByOccasionProductGroupByPayload<T extends ShopByOccasionProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopByOccasionProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopByOccasionProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopByOccasionProductGroupByOutputType[P]>
            : GetScalarType<T[P], ShopByOccasionProductGroupByOutputType[P]>
        }
      >
    >


  export type ShopByOccasionProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    shopByOccasionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ShopByOccasion?: boolean | ShopByOccasionProduct$ShopByOccasionArgs<ExtArgs>
  }, ExtArgs["result"]["shopByOccasionProduct"]>



  export type ShopByOccasionProductSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    shopByOccasionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopByOccasionProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "imageUrl" | "hyperLink" | "shopByOccasionId" | "createdAt" | "updatedAt", ExtArgs["result"]["shopByOccasionProduct"]>
  export type ShopByOccasionProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopByOccasion?: boolean | ShopByOccasionProduct$ShopByOccasionArgs<ExtArgs>
  }

  export type $ShopByOccasionProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopByOccasionProduct"
    objects: {
      ShopByOccasion: Prisma.$ShopByOccasionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imageUrl: string
      hyperLink: string
      shopByOccasionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopByOccasionProduct"]>
    composites: {}
  }

  type ShopByOccasionProductGetPayload<S extends boolean | null | undefined | ShopByOccasionProductDefaultArgs> = $Result.GetResult<Prisma.$ShopByOccasionProductPayload, S>

  type ShopByOccasionProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopByOccasionProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopByOccasionProductCountAggregateInputType | true
    }

  export interface ShopByOccasionProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopByOccasionProduct'], meta: { name: 'ShopByOccasionProduct' } }
    /**
     * Find zero or one ShopByOccasionProduct that matches the filter.
     * @param {ShopByOccasionProductFindUniqueArgs} args - Arguments to find a ShopByOccasionProduct
     * @example
     * // Get one ShopByOccasionProduct
     * const shopByOccasionProduct = await prisma.shopByOccasionProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopByOccasionProductFindUniqueArgs>(args: SelectSubset<T, ShopByOccasionProductFindUniqueArgs<ExtArgs>>): Prisma__ShopByOccasionProductClient<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopByOccasionProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopByOccasionProductFindUniqueOrThrowArgs} args - Arguments to find a ShopByOccasionProduct
     * @example
     * // Get one ShopByOccasionProduct
     * const shopByOccasionProduct = await prisma.shopByOccasionProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopByOccasionProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopByOccasionProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopByOccasionProductClient<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopByOccasionProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionProductFindFirstArgs} args - Arguments to find a ShopByOccasionProduct
     * @example
     * // Get one ShopByOccasionProduct
     * const shopByOccasionProduct = await prisma.shopByOccasionProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopByOccasionProductFindFirstArgs>(args?: SelectSubset<T, ShopByOccasionProductFindFirstArgs<ExtArgs>>): Prisma__ShopByOccasionProductClient<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopByOccasionProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionProductFindFirstOrThrowArgs} args - Arguments to find a ShopByOccasionProduct
     * @example
     * // Get one ShopByOccasionProduct
     * const shopByOccasionProduct = await prisma.shopByOccasionProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopByOccasionProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopByOccasionProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopByOccasionProductClient<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopByOccasionProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopByOccasionProducts
     * const shopByOccasionProducts = await prisma.shopByOccasionProduct.findMany()
     * 
     * // Get first 10 ShopByOccasionProducts
     * const shopByOccasionProducts = await prisma.shopByOccasionProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopByOccasionProductWithIdOnly = await prisma.shopByOccasionProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopByOccasionProductFindManyArgs>(args?: SelectSubset<T, ShopByOccasionProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopByOccasionProduct.
     * @param {ShopByOccasionProductCreateArgs} args - Arguments to create a ShopByOccasionProduct.
     * @example
     * // Create one ShopByOccasionProduct
     * const ShopByOccasionProduct = await prisma.shopByOccasionProduct.create({
     *   data: {
     *     // ... data to create a ShopByOccasionProduct
     *   }
     * })
     * 
     */
    create<T extends ShopByOccasionProductCreateArgs>(args: SelectSubset<T, ShopByOccasionProductCreateArgs<ExtArgs>>): Prisma__ShopByOccasionProductClient<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopByOccasionProducts.
     * @param {ShopByOccasionProductCreateManyArgs} args - Arguments to create many ShopByOccasionProducts.
     * @example
     * // Create many ShopByOccasionProducts
     * const shopByOccasionProduct = await prisma.shopByOccasionProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopByOccasionProductCreateManyArgs>(args?: SelectSubset<T, ShopByOccasionProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopByOccasionProduct.
     * @param {ShopByOccasionProductDeleteArgs} args - Arguments to delete one ShopByOccasionProduct.
     * @example
     * // Delete one ShopByOccasionProduct
     * const ShopByOccasionProduct = await prisma.shopByOccasionProduct.delete({
     *   where: {
     *     // ... filter to delete one ShopByOccasionProduct
     *   }
     * })
     * 
     */
    delete<T extends ShopByOccasionProductDeleteArgs>(args: SelectSubset<T, ShopByOccasionProductDeleteArgs<ExtArgs>>): Prisma__ShopByOccasionProductClient<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopByOccasionProduct.
     * @param {ShopByOccasionProductUpdateArgs} args - Arguments to update one ShopByOccasionProduct.
     * @example
     * // Update one ShopByOccasionProduct
     * const shopByOccasionProduct = await prisma.shopByOccasionProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopByOccasionProductUpdateArgs>(args: SelectSubset<T, ShopByOccasionProductUpdateArgs<ExtArgs>>): Prisma__ShopByOccasionProductClient<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopByOccasionProducts.
     * @param {ShopByOccasionProductDeleteManyArgs} args - Arguments to filter ShopByOccasionProducts to delete.
     * @example
     * // Delete a few ShopByOccasionProducts
     * const { count } = await prisma.shopByOccasionProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopByOccasionProductDeleteManyArgs>(args?: SelectSubset<T, ShopByOccasionProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopByOccasionProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopByOccasionProducts
     * const shopByOccasionProduct = await prisma.shopByOccasionProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopByOccasionProductUpdateManyArgs>(args: SelectSubset<T, ShopByOccasionProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopByOccasionProduct.
     * @param {ShopByOccasionProductUpsertArgs} args - Arguments to update or create a ShopByOccasionProduct.
     * @example
     * // Update or create a ShopByOccasionProduct
     * const shopByOccasionProduct = await prisma.shopByOccasionProduct.upsert({
     *   create: {
     *     // ... data to create a ShopByOccasionProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopByOccasionProduct we want to update
     *   }
     * })
     */
    upsert<T extends ShopByOccasionProductUpsertArgs>(args: SelectSubset<T, ShopByOccasionProductUpsertArgs<ExtArgs>>): Prisma__ShopByOccasionProductClient<$Result.GetResult<Prisma.$ShopByOccasionProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopByOccasionProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionProductCountArgs} args - Arguments to filter ShopByOccasionProducts to count.
     * @example
     * // Count the number of ShopByOccasionProducts
     * const count = await prisma.shopByOccasionProduct.count({
     *   where: {
     *     // ... the filter for the ShopByOccasionProducts we want to count
     *   }
     * })
    **/
    count<T extends ShopByOccasionProductCountArgs>(
      args?: Subset<T, ShopByOccasionProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopByOccasionProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopByOccasionProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopByOccasionProductAggregateArgs>(args: Subset<T, ShopByOccasionProductAggregateArgs>): Prisma.PrismaPromise<GetShopByOccasionProductAggregateType<T>>

    /**
     * Group by ShopByOccasionProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopByOccasionProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopByOccasionProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopByOccasionProductGroupByArgs['orderBy'] }
        : { orderBy?: ShopByOccasionProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopByOccasionProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopByOccasionProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopByOccasionProduct model
   */
  readonly fields: ShopByOccasionProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopByOccasionProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopByOccasionProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ShopByOccasion<T extends ShopByOccasionProduct$ShopByOccasionArgs<ExtArgs> = {}>(args?: Subset<T, ShopByOccasionProduct$ShopByOccasionArgs<ExtArgs>>): Prisma__ShopByOccasionClient<$Result.GetResult<Prisma.$ShopByOccasionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopByOccasionProduct model
   */ 
  interface ShopByOccasionProductFieldRefs {
    readonly id: FieldRef<"ShopByOccasionProduct", 'String'>
    readonly imageUrl: FieldRef<"ShopByOccasionProduct", 'String'>
    readonly hyperLink: FieldRef<"ShopByOccasionProduct", 'String'>
    readonly shopByOccasionId: FieldRef<"ShopByOccasionProduct", 'String'>
    readonly createdAt: FieldRef<"ShopByOccasionProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopByOccasionProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopByOccasionProduct findUnique
   */
  export type ShopByOccasionProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasionProduct to fetch.
     */
    where: ShopByOccasionProductWhereUniqueInput
  }

  /**
   * ShopByOccasionProduct findUniqueOrThrow
   */
  export type ShopByOccasionProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasionProduct to fetch.
     */
    where: ShopByOccasionProductWhereUniqueInput
  }

  /**
   * ShopByOccasionProduct findFirst
   */
  export type ShopByOccasionProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasionProduct to fetch.
     */
    where?: ShopByOccasionProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopByOccasionProducts to fetch.
     */
    orderBy?: ShopByOccasionProductOrderByWithRelationInput | ShopByOccasionProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopByOccasionProducts.
     */
    cursor?: ShopByOccasionProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopByOccasionProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopByOccasionProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopByOccasionProducts.
     */
    distinct?: ShopByOccasionProductScalarFieldEnum | ShopByOccasionProductScalarFieldEnum[]
  }

  /**
   * ShopByOccasionProduct findFirstOrThrow
   */
  export type ShopByOccasionProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasionProduct to fetch.
     */
    where?: ShopByOccasionProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopByOccasionProducts to fetch.
     */
    orderBy?: ShopByOccasionProductOrderByWithRelationInput | ShopByOccasionProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopByOccasionProducts.
     */
    cursor?: ShopByOccasionProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopByOccasionProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopByOccasionProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopByOccasionProducts.
     */
    distinct?: ShopByOccasionProductScalarFieldEnum | ShopByOccasionProductScalarFieldEnum[]
  }

  /**
   * ShopByOccasionProduct findMany
   */
  export type ShopByOccasionProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopByOccasionProducts to fetch.
     */
    where?: ShopByOccasionProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopByOccasionProducts to fetch.
     */
    orderBy?: ShopByOccasionProductOrderByWithRelationInput | ShopByOccasionProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopByOccasionProducts.
     */
    cursor?: ShopByOccasionProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopByOccasionProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopByOccasionProducts.
     */
    skip?: number
    distinct?: ShopByOccasionProductScalarFieldEnum | ShopByOccasionProductScalarFieldEnum[]
  }

  /**
   * ShopByOccasionProduct create
   */
  export type ShopByOccasionProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopByOccasionProduct.
     */
    data: XOR<ShopByOccasionProductCreateInput, ShopByOccasionProductUncheckedCreateInput>
  }

  /**
   * ShopByOccasionProduct createMany
   */
  export type ShopByOccasionProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopByOccasionProducts.
     */
    data: ShopByOccasionProductCreateManyInput | ShopByOccasionProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopByOccasionProduct update
   */
  export type ShopByOccasionProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopByOccasionProduct.
     */
    data: XOR<ShopByOccasionProductUpdateInput, ShopByOccasionProductUncheckedUpdateInput>
    /**
     * Choose, which ShopByOccasionProduct to update.
     */
    where: ShopByOccasionProductWhereUniqueInput
  }

  /**
   * ShopByOccasionProduct updateMany
   */
  export type ShopByOccasionProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopByOccasionProducts.
     */
    data: XOR<ShopByOccasionProductUpdateManyMutationInput, ShopByOccasionProductUncheckedUpdateManyInput>
    /**
     * Filter which ShopByOccasionProducts to update
     */
    where?: ShopByOccasionProductWhereInput
    /**
     * Limit how many ShopByOccasionProducts to update.
     */
    limit?: number
  }

  /**
   * ShopByOccasionProduct upsert
   */
  export type ShopByOccasionProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopByOccasionProduct to update in case it exists.
     */
    where: ShopByOccasionProductWhereUniqueInput
    /**
     * In case the ShopByOccasionProduct found by the `where` argument doesn't exist, create a new ShopByOccasionProduct with this data.
     */
    create: XOR<ShopByOccasionProductCreateInput, ShopByOccasionProductUncheckedCreateInput>
    /**
     * In case the ShopByOccasionProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopByOccasionProductUpdateInput, ShopByOccasionProductUncheckedUpdateInput>
  }

  /**
   * ShopByOccasionProduct delete
   */
  export type ShopByOccasionProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
    /**
     * Filter which ShopByOccasionProduct to delete.
     */
    where: ShopByOccasionProductWhereUniqueInput
  }

  /**
   * ShopByOccasionProduct deleteMany
   */
  export type ShopByOccasionProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopByOccasionProducts to delete
     */
    where?: ShopByOccasionProductWhereInput
    /**
     * Limit how many ShopByOccasionProducts to delete.
     */
    limit?: number
  }

  /**
   * ShopByOccasionProduct.ShopByOccasion
   */
  export type ShopByOccasionProduct$ShopByOccasionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasion
     */
    select?: ShopByOccasionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasion
     */
    omit?: ShopByOccasionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionInclude<ExtArgs> | null
    where?: ShopByOccasionWhereInput
  }

  /**
   * ShopByOccasionProduct without action
   */
  export type ShopByOccasionProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopByOccasionProduct
     */
    select?: ShopByOccasionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopByOccasionProduct
     */
    omit?: ShopByOccasionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopByOccasionProductInclude<ExtArgs> | null
  }


  /**
   * Model ShopBySeason
   */

  export type AggregateShopBySeason = {
    _count: ShopBySeasonCountAggregateOutputType | null
    _min: ShopBySeasonMinAggregateOutputType | null
    _max: ShopBySeasonMaxAggregateOutputType | null
  }

  export type ShopBySeasonMinAggregateOutputType = {
    id: string | null
    videoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopBySeasonMaxAggregateOutputType = {
    id: string | null
    videoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopBySeasonCountAggregateOutputType = {
    id: number
    videoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopBySeasonMinAggregateInputType = {
    id?: true
    videoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopBySeasonMaxAggregateInputType = {
    id?: true
    videoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopBySeasonCountAggregateInputType = {
    id?: true
    videoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopBySeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopBySeason to aggregate.
     */
    where?: ShopBySeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopBySeasons to fetch.
     */
    orderBy?: ShopBySeasonOrderByWithRelationInput | ShopBySeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopBySeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopBySeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopBySeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopBySeasons
    **/
    _count?: true | ShopBySeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopBySeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopBySeasonMaxAggregateInputType
  }

  export type GetShopBySeasonAggregateType<T extends ShopBySeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateShopBySeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopBySeason[P]>
      : GetScalarType<T[P], AggregateShopBySeason[P]>
  }




  export type ShopBySeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopBySeasonWhereInput
    orderBy?: ShopBySeasonOrderByWithAggregationInput | ShopBySeasonOrderByWithAggregationInput[]
    by: ShopBySeasonScalarFieldEnum[] | ShopBySeasonScalarFieldEnum
    having?: ShopBySeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopBySeasonCountAggregateInputType | true
    _min?: ShopBySeasonMinAggregateInputType
    _max?: ShopBySeasonMaxAggregateInputType
  }

  export type ShopBySeasonGroupByOutputType = {
    id: string
    videoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShopBySeasonCountAggregateOutputType | null
    _min: ShopBySeasonMinAggregateOutputType | null
    _max: ShopBySeasonMaxAggregateOutputType | null
  }

  type GetShopBySeasonGroupByPayload<T extends ShopBySeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopBySeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopBySeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopBySeasonGroupByOutputType[P]>
            : GetScalarType<T[P], ShopBySeasonGroupByOutputType[P]>
        }
      >
    >


  export type ShopBySeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ShopBySeasonProduct?: boolean | ShopBySeason$ShopBySeasonProductArgs<ExtArgs>
    _count?: boolean | ShopBySeasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopBySeason"]>



  export type ShopBySeasonSelectScalar = {
    id?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopBySeasonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "videoUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["shopBySeason"]>
  export type ShopBySeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopBySeasonProduct?: boolean | ShopBySeason$ShopBySeasonProductArgs<ExtArgs>
    _count?: boolean | ShopBySeasonCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShopBySeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopBySeason"
    objects: {
      ShopBySeasonProduct: Prisma.$ShopBySeasonProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shopBySeason"]>
    composites: {}
  }

  type ShopBySeasonGetPayload<S extends boolean | null | undefined | ShopBySeasonDefaultArgs> = $Result.GetResult<Prisma.$ShopBySeasonPayload, S>

  type ShopBySeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopBySeasonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopBySeasonCountAggregateInputType | true
    }

  export interface ShopBySeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopBySeason'], meta: { name: 'ShopBySeason' } }
    /**
     * Find zero or one ShopBySeason that matches the filter.
     * @param {ShopBySeasonFindUniqueArgs} args - Arguments to find a ShopBySeason
     * @example
     * // Get one ShopBySeason
     * const shopBySeason = await prisma.shopBySeason.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopBySeasonFindUniqueArgs>(args: SelectSubset<T, ShopBySeasonFindUniqueArgs<ExtArgs>>): Prisma__ShopBySeasonClient<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopBySeason that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopBySeasonFindUniqueOrThrowArgs} args - Arguments to find a ShopBySeason
     * @example
     * // Get one ShopBySeason
     * const shopBySeason = await prisma.shopBySeason.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopBySeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopBySeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopBySeasonClient<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopBySeason that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonFindFirstArgs} args - Arguments to find a ShopBySeason
     * @example
     * // Get one ShopBySeason
     * const shopBySeason = await prisma.shopBySeason.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopBySeasonFindFirstArgs>(args?: SelectSubset<T, ShopBySeasonFindFirstArgs<ExtArgs>>): Prisma__ShopBySeasonClient<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopBySeason that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonFindFirstOrThrowArgs} args - Arguments to find a ShopBySeason
     * @example
     * // Get one ShopBySeason
     * const shopBySeason = await prisma.shopBySeason.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopBySeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopBySeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopBySeasonClient<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopBySeasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopBySeasons
     * const shopBySeasons = await prisma.shopBySeason.findMany()
     * 
     * // Get first 10 ShopBySeasons
     * const shopBySeasons = await prisma.shopBySeason.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopBySeasonWithIdOnly = await prisma.shopBySeason.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopBySeasonFindManyArgs>(args?: SelectSubset<T, ShopBySeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopBySeason.
     * @param {ShopBySeasonCreateArgs} args - Arguments to create a ShopBySeason.
     * @example
     * // Create one ShopBySeason
     * const ShopBySeason = await prisma.shopBySeason.create({
     *   data: {
     *     // ... data to create a ShopBySeason
     *   }
     * })
     * 
     */
    create<T extends ShopBySeasonCreateArgs>(args: SelectSubset<T, ShopBySeasonCreateArgs<ExtArgs>>): Prisma__ShopBySeasonClient<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopBySeasons.
     * @param {ShopBySeasonCreateManyArgs} args - Arguments to create many ShopBySeasons.
     * @example
     * // Create many ShopBySeasons
     * const shopBySeason = await prisma.shopBySeason.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopBySeasonCreateManyArgs>(args?: SelectSubset<T, ShopBySeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopBySeason.
     * @param {ShopBySeasonDeleteArgs} args - Arguments to delete one ShopBySeason.
     * @example
     * // Delete one ShopBySeason
     * const ShopBySeason = await prisma.shopBySeason.delete({
     *   where: {
     *     // ... filter to delete one ShopBySeason
     *   }
     * })
     * 
     */
    delete<T extends ShopBySeasonDeleteArgs>(args: SelectSubset<T, ShopBySeasonDeleteArgs<ExtArgs>>): Prisma__ShopBySeasonClient<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopBySeason.
     * @param {ShopBySeasonUpdateArgs} args - Arguments to update one ShopBySeason.
     * @example
     * // Update one ShopBySeason
     * const shopBySeason = await prisma.shopBySeason.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopBySeasonUpdateArgs>(args: SelectSubset<T, ShopBySeasonUpdateArgs<ExtArgs>>): Prisma__ShopBySeasonClient<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopBySeasons.
     * @param {ShopBySeasonDeleteManyArgs} args - Arguments to filter ShopBySeasons to delete.
     * @example
     * // Delete a few ShopBySeasons
     * const { count } = await prisma.shopBySeason.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopBySeasonDeleteManyArgs>(args?: SelectSubset<T, ShopBySeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopBySeasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopBySeasons
     * const shopBySeason = await prisma.shopBySeason.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopBySeasonUpdateManyArgs>(args: SelectSubset<T, ShopBySeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopBySeason.
     * @param {ShopBySeasonUpsertArgs} args - Arguments to update or create a ShopBySeason.
     * @example
     * // Update or create a ShopBySeason
     * const shopBySeason = await prisma.shopBySeason.upsert({
     *   create: {
     *     // ... data to create a ShopBySeason
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopBySeason we want to update
     *   }
     * })
     */
    upsert<T extends ShopBySeasonUpsertArgs>(args: SelectSubset<T, ShopBySeasonUpsertArgs<ExtArgs>>): Prisma__ShopBySeasonClient<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopBySeasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonCountArgs} args - Arguments to filter ShopBySeasons to count.
     * @example
     * // Count the number of ShopBySeasons
     * const count = await prisma.shopBySeason.count({
     *   where: {
     *     // ... the filter for the ShopBySeasons we want to count
     *   }
     * })
    **/
    count<T extends ShopBySeasonCountArgs>(
      args?: Subset<T, ShopBySeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopBySeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopBySeason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopBySeasonAggregateArgs>(args: Subset<T, ShopBySeasonAggregateArgs>): Prisma.PrismaPromise<GetShopBySeasonAggregateType<T>>

    /**
     * Group by ShopBySeason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopBySeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopBySeasonGroupByArgs['orderBy'] }
        : { orderBy?: ShopBySeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopBySeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopBySeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopBySeason model
   */
  readonly fields: ShopBySeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopBySeason.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopBySeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ShopBySeasonProduct<T extends ShopBySeason$ShopBySeasonProductArgs<ExtArgs> = {}>(args?: Subset<T, ShopBySeason$ShopBySeasonProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopBySeason model
   */ 
  interface ShopBySeasonFieldRefs {
    readonly id: FieldRef<"ShopBySeason", 'String'>
    readonly videoUrl: FieldRef<"ShopBySeason", 'String'>
    readonly createdAt: FieldRef<"ShopBySeason", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopBySeason", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShopBySeason findUnique
   */
  export type ShopBySeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeason to fetch.
     */
    where: ShopBySeasonWhereUniqueInput
  }

  /**
   * ShopBySeason findUniqueOrThrow
   */
  export type ShopBySeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeason to fetch.
     */
    where: ShopBySeasonWhereUniqueInput
  }

  /**
   * ShopBySeason findFirst
   */
  export type ShopBySeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeason to fetch.
     */
    where?: ShopBySeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopBySeasons to fetch.
     */
    orderBy?: ShopBySeasonOrderByWithRelationInput | ShopBySeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopBySeasons.
     */
    cursor?: ShopBySeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopBySeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopBySeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopBySeasons.
     */
    distinct?: ShopBySeasonScalarFieldEnum | ShopBySeasonScalarFieldEnum[]
  }

  /**
   * ShopBySeason findFirstOrThrow
   */
  export type ShopBySeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeason to fetch.
     */
    where?: ShopBySeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopBySeasons to fetch.
     */
    orderBy?: ShopBySeasonOrderByWithRelationInput | ShopBySeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopBySeasons.
     */
    cursor?: ShopBySeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopBySeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopBySeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopBySeasons.
     */
    distinct?: ShopBySeasonScalarFieldEnum | ShopBySeasonScalarFieldEnum[]
  }

  /**
   * ShopBySeason findMany
   */
  export type ShopBySeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeasons to fetch.
     */
    where?: ShopBySeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopBySeasons to fetch.
     */
    orderBy?: ShopBySeasonOrderByWithRelationInput | ShopBySeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopBySeasons.
     */
    cursor?: ShopBySeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopBySeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopBySeasons.
     */
    skip?: number
    distinct?: ShopBySeasonScalarFieldEnum | ShopBySeasonScalarFieldEnum[]
  }

  /**
   * ShopBySeason create
   */
  export type ShopBySeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopBySeason.
     */
    data: XOR<ShopBySeasonCreateInput, ShopBySeasonUncheckedCreateInput>
  }

  /**
   * ShopBySeason createMany
   */
  export type ShopBySeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopBySeasons.
     */
    data: ShopBySeasonCreateManyInput | ShopBySeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopBySeason update
   */
  export type ShopBySeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopBySeason.
     */
    data: XOR<ShopBySeasonUpdateInput, ShopBySeasonUncheckedUpdateInput>
    /**
     * Choose, which ShopBySeason to update.
     */
    where: ShopBySeasonWhereUniqueInput
  }

  /**
   * ShopBySeason updateMany
   */
  export type ShopBySeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopBySeasons.
     */
    data: XOR<ShopBySeasonUpdateManyMutationInput, ShopBySeasonUncheckedUpdateManyInput>
    /**
     * Filter which ShopBySeasons to update
     */
    where?: ShopBySeasonWhereInput
    /**
     * Limit how many ShopBySeasons to update.
     */
    limit?: number
  }

  /**
   * ShopBySeason upsert
   */
  export type ShopBySeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopBySeason to update in case it exists.
     */
    where: ShopBySeasonWhereUniqueInput
    /**
     * In case the ShopBySeason found by the `where` argument doesn't exist, create a new ShopBySeason with this data.
     */
    create: XOR<ShopBySeasonCreateInput, ShopBySeasonUncheckedCreateInput>
    /**
     * In case the ShopBySeason was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopBySeasonUpdateInput, ShopBySeasonUncheckedUpdateInput>
  }

  /**
   * ShopBySeason delete
   */
  export type ShopBySeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
    /**
     * Filter which ShopBySeason to delete.
     */
    where: ShopBySeasonWhereUniqueInput
  }

  /**
   * ShopBySeason deleteMany
   */
  export type ShopBySeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopBySeasons to delete
     */
    where?: ShopBySeasonWhereInput
    /**
     * Limit how many ShopBySeasons to delete.
     */
    limit?: number
  }

  /**
   * ShopBySeason.ShopBySeasonProduct
   */
  export type ShopBySeason$ShopBySeasonProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    where?: ShopBySeasonProductWhereInput
    orderBy?: ShopBySeasonProductOrderByWithRelationInput | ShopBySeasonProductOrderByWithRelationInput[]
    cursor?: ShopBySeasonProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopBySeasonProductScalarFieldEnum | ShopBySeasonProductScalarFieldEnum[]
  }

  /**
   * ShopBySeason without action
   */
  export type ShopBySeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeason
     */
    select?: ShopBySeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeason
     */
    omit?: ShopBySeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonInclude<ExtArgs> | null
  }


  /**
   * Model ShopBySeasonProduct
   */

  export type AggregateShopBySeasonProduct = {
    _count: ShopBySeasonProductCountAggregateOutputType | null
    _min: ShopBySeasonProductMinAggregateOutputType | null
    _max: ShopBySeasonProductMaxAggregateOutputType | null
  }

  export type ShopBySeasonProductMinAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    seasonId: string | null
    hyperLink: string | null
  }

  export type ShopBySeasonProductMaxAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    seasonId: string | null
    hyperLink: string | null
  }

  export type ShopBySeasonProductCountAggregateOutputType = {
    id: number
    imageUrl: number
    description: number
    createdAt: number
    updatedAt: number
    seasonId: number
    hyperLink: number
    _all: number
  }


  export type ShopBySeasonProductMinAggregateInputType = {
    id?: true
    imageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
    hyperLink?: true
  }

  export type ShopBySeasonProductMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
    hyperLink?: true
  }

  export type ShopBySeasonProductCountAggregateInputType = {
    id?: true
    imageUrl?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    seasonId?: true
    hyperLink?: true
    _all?: true
  }

  export type ShopBySeasonProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopBySeasonProduct to aggregate.
     */
    where?: ShopBySeasonProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopBySeasonProducts to fetch.
     */
    orderBy?: ShopBySeasonProductOrderByWithRelationInput | ShopBySeasonProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopBySeasonProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopBySeasonProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopBySeasonProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopBySeasonProducts
    **/
    _count?: true | ShopBySeasonProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopBySeasonProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopBySeasonProductMaxAggregateInputType
  }

  export type GetShopBySeasonProductAggregateType<T extends ShopBySeasonProductAggregateArgs> = {
        [P in keyof T & keyof AggregateShopBySeasonProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopBySeasonProduct[P]>
      : GetScalarType<T[P], AggregateShopBySeasonProduct[P]>
  }




  export type ShopBySeasonProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopBySeasonProductWhereInput
    orderBy?: ShopBySeasonProductOrderByWithAggregationInput | ShopBySeasonProductOrderByWithAggregationInput[]
    by: ShopBySeasonProductScalarFieldEnum[] | ShopBySeasonProductScalarFieldEnum
    having?: ShopBySeasonProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopBySeasonProductCountAggregateInputType | true
    _min?: ShopBySeasonProductMinAggregateInputType
    _max?: ShopBySeasonProductMaxAggregateInputType
  }

  export type ShopBySeasonProductGroupByOutputType = {
    id: string
    imageUrl: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    seasonId: string
    hyperLink: string
    _count: ShopBySeasonProductCountAggregateOutputType | null
    _min: ShopBySeasonProductMinAggregateOutputType | null
    _max: ShopBySeasonProductMaxAggregateOutputType | null
  }

  type GetShopBySeasonProductGroupByPayload<T extends ShopBySeasonProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopBySeasonProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopBySeasonProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopBySeasonProductGroupByOutputType[P]>
            : GetScalarType<T[P], ShopBySeasonProductGroupByOutputType[P]>
        }
      >
    >


  export type ShopBySeasonProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasonId?: boolean
    hyperLink?: boolean
    ShopBySeason?: boolean | ShopBySeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shopBySeasonProduct"]>



  export type ShopBySeasonProductSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seasonId?: boolean
    hyperLink?: boolean
  }

  export type ShopBySeasonProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "imageUrl" | "description" | "createdAt" | "updatedAt" | "seasonId" | "hyperLink", ExtArgs["result"]["shopBySeasonProduct"]>
  export type ShopBySeasonProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopBySeason?: boolean | ShopBySeasonDefaultArgs<ExtArgs>
  }

  export type $ShopBySeasonProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopBySeasonProduct"
    objects: {
      ShopBySeason: Prisma.$ShopBySeasonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imageUrl: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      seasonId: string
      hyperLink: string
    }, ExtArgs["result"]["shopBySeasonProduct"]>
    composites: {}
  }

  type ShopBySeasonProductGetPayload<S extends boolean | null | undefined | ShopBySeasonProductDefaultArgs> = $Result.GetResult<Prisma.$ShopBySeasonProductPayload, S>

  type ShopBySeasonProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopBySeasonProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopBySeasonProductCountAggregateInputType | true
    }

  export interface ShopBySeasonProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopBySeasonProduct'], meta: { name: 'ShopBySeasonProduct' } }
    /**
     * Find zero or one ShopBySeasonProduct that matches the filter.
     * @param {ShopBySeasonProductFindUniqueArgs} args - Arguments to find a ShopBySeasonProduct
     * @example
     * // Get one ShopBySeasonProduct
     * const shopBySeasonProduct = await prisma.shopBySeasonProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopBySeasonProductFindUniqueArgs>(args: SelectSubset<T, ShopBySeasonProductFindUniqueArgs<ExtArgs>>): Prisma__ShopBySeasonProductClient<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShopBySeasonProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopBySeasonProductFindUniqueOrThrowArgs} args - Arguments to find a ShopBySeasonProduct
     * @example
     * // Get one ShopBySeasonProduct
     * const shopBySeasonProduct = await prisma.shopBySeasonProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopBySeasonProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopBySeasonProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopBySeasonProductClient<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopBySeasonProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonProductFindFirstArgs} args - Arguments to find a ShopBySeasonProduct
     * @example
     * // Get one ShopBySeasonProduct
     * const shopBySeasonProduct = await prisma.shopBySeasonProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopBySeasonProductFindFirstArgs>(args?: SelectSubset<T, ShopBySeasonProductFindFirstArgs<ExtArgs>>): Prisma__ShopBySeasonProductClient<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShopBySeasonProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonProductFindFirstOrThrowArgs} args - Arguments to find a ShopBySeasonProduct
     * @example
     * // Get one ShopBySeasonProduct
     * const shopBySeasonProduct = await prisma.shopBySeasonProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopBySeasonProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopBySeasonProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopBySeasonProductClient<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShopBySeasonProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopBySeasonProducts
     * const shopBySeasonProducts = await prisma.shopBySeasonProduct.findMany()
     * 
     * // Get first 10 ShopBySeasonProducts
     * const shopBySeasonProducts = await prisma.shopBySeasonProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopBySeasonProductWithIdOnly = await prisma.shopBySeasonProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShopBySeasonProductFindManyArgs>(args?: SelectSubset<T, ShopBySeasonProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShopBySeasonProduct.
     * @param {ShopBySeasonProductCreateArgs} args - Arguments to create a ShopBySeasonProduct.
     * @example
     * // Create one ShopBySeasonProduct
     * const ShopBySeasonProduct = await prisma.shopBySeasonProduct.create({
     *   data: {
     *     // ... data to create a ShopBySeasonProduct
     *   }
     * })
     * 
     */
    create<T extends ShopBySeasonProductCreateArgs>(args: SelectSubset<T, ShopBySeasonProductCreateArgs<ExtArgs>>): Prisma__ShopBySeasonProductClient<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShopBySeasonProducts.
     * @param {ShopBySeasonProductCreateManyArgs} args - Arguments to create many ShopBySeasonProducts.
     * @example
     * // Create many ShopBySeasonProducts
     * const shopBySeasonProduct = await prisma.shopBySeasonProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopBySeasonProductCreateManyArgs>(args?: SelectSubset<T, ShopBySeasonProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopBySeasonProduct.
     * @param {ShopBySeasonProductDeleteArgs} args - Arguments to delete one ShopBySeasonProduct.
     * @example
     * // Delete one ShopBySeasonProduct
     * const ShopBySeasonProduct = await prisma.shopBySeasonProduct.delete({
     *   where: {
     *     // ... filter to delete one ShopBySeasonProduct
     *   }
     * })
     * 
     */
    delete<T extends ShopBySeasonProductDeleteArgs>(args: SelectSubset<T, ShopBySeasonProductDeleteArgs<ExtArgs>>): Prisma__ShopBySeasonProductClient<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShopBySeasonProduct.
     * @param {ShopBySeasonProductUpdateArgs} args - Arguments to update one ShopBySeasonProduct.
     * @example
     * // Update one ShopBySeasonProduct
     * const shopBySeasonProduct = await prisma.shopBySeasonProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopBySeasonProductUpdateArgs>(args: SelectSubset<T, ShopBySeasonProductUpdateArgs<ExtArgs>>): Prisma__ShopBySeasonProductClient<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShopBySeasonProducts.
     * @param {ShopBySeasonProductDeleteManyArgs} args - Arguments to filter ShopBySeasonProducts to delete.
     * @example
     * // Delete a few ShopBySeasonProducts
     * const { count } = await prisma.shopBySeasonProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopBySeasonProductDeleteManyArgs>(args?: SelectSubset<T, ShopBySeasonProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopBySeasonProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopBySeasonProducts
     * const shopBySeasonProduct = await prisma.shopBySeasonProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopBySeasonProductUpdateManyArgs>(args: SelectSubset<T, ShopBySeasonProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopBySeasonProduct.
     * @param {ShopBySeasonProductUpsertArgs} args - Arguments to update or create a ShopBySeasonProduct.
     * @example
     * // Update or create a ShopBySeasonProduct
     * const shopBySeasonProduct = await prisma.shopBySeasonProduct.upsert({
     *   create: {
     *     // ... data to create a ShopBySeasonProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopBySeasonProduct we want to update
     *   }
     * })
     */
    upsert<T extends ShopBySeasonProductUpsertArgs>(args: SelectSubset<T, ShopBySeasonProductUpsertArgs<ExtArgs>>): Prisma__ShopBySeasonProductClient<$Result.GetResult<Prisma.$ShopBySeasonProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShopBySeasonProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonProductCountArgs} args - Arguments to filter ShopBySeasonProducts to count.
     * @example
     * // Count the number of ShopBySeasonProducts
     * const count = await prisma.shopBySeasonProduct.count({
     *   where: {
     *     // ... the filter for the ShopBySeasonProducts we want to count
     *   }
     * })
    **/
    count<T extends ShopBySeasonProductCountArgs>(
      args?: Subset<T, ShopBySeasonProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopBySeasonProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopBySeasonProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopBySeasonProductAggregateArgs>(args: Subset<T, ShopBySeasonProductAggregateArgs>): Prisma.PrismaPromise<GetShopBySeasonProductAggregateType<T>>

    /**
     * Group by ShopBySeasonProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopBySeasonProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopBySeasonProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopBySeasonProductGroupByArgs['orderBy'] }
        : { orderBy?: ShopBySeasonProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopBySeasonProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopBySeasonProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopBySeasonProduct model
   */
  readonly fields: ShopBySeasonProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopBySeasonProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopBySeasonProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ShopBySeason<T extends ShopBySeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopBySeasonDefaultArgs<ExtArgs>>): Prisma__ShopBySeasonClient<$Result.GetResult<Prisma.$ShopBySeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShopBySeasonProduct model
   */ 
  interface ShopBySeasonProductFieldRefs {
    readonly id: FieldRef<"ShopBySeasonProduct", 'String'>
    readonly imageUrl: FieldRef<"ShopBySeasonProduct", 'String'>
    readonly description: FieldRef<"ShopBySeasonProduct", 'String'>
    readonly createdAt: FieldRef<"ShopBySeasonProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopBySeasonProduct", 'DateTime'>
    readonly seasonId: FieldRef<"ShopBySeasonProduct", 'String'>
    readonly hyperLink: FieldRef<"ShopBySeasonProduct", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ShopBySeasonProduct findUnique
   */
  export type ShopBySeasonProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeasonProduct to fetch.
     */
    where: ShopBySeasonProductWhereUniqueInput
  }

  /**
   * ShopBySeasonProduct findUniqueOrThrow
   */
  export type ShopBySeasonProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeasonProduct to fetch.
     */
    where: ShopBySeasonProductWhereUniqueInput
  }

  /**
   * ShopBySeasonProduct findFirst
   */
  export type ShopBySeasonProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeasonProduct to fetch.
     */
    where?: ShopBySeasonProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopBySeasonProducts to fetch.
     */
    orderBy?: ShopBySeasonProductOrderByWithRelationInput | ShopBySeasonProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopBySeasonProducts.
     */
    cursor?: ShopBySeasonProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopBySeasonProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopBySeasonProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopBySeasonProducts.
     */
    distinct?: ShopBySeasonProductScalarFieldEnum | ShopBySeasonProductScalarFieldEnum[]
  }

  /**
   * ShopBySeasonProduct findFirstOrThrow
   */
  export type ShopBySeasonProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeasonProduct to fetch.
     */
    where?: ShopBySeasonProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopBySeasonProducts to fetch.
     */
    orderBy?: ShopBySeasonProductOrderByWithRelationInput | ShopBySeasonProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopBySeasonProducts.
     */
    cursor?: ShopBySeasonProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopBySeasonProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopBySeasonProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopBySeasonProducts.
     */
    distinct?: ShopBySeasonProductScalarFieldEnum | ShopBySeasonProductScalarFieldEnum[]
  }

  /**
   * ShopBySeasonProduct findMany
   */
  export type ShopBySeasonProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    /**
     * Filter, which ShopBySeasonProducts to fetch.
     */
    where?: ShopBySeasonProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopBySeasonProducts to fetch.
     */
    orderBy?: ShopBySeasonProductOrderByWithRelationInput | ShopBySeasonProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopBySeasonProducts.
     */
    cursor?: ShopBySeasonProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopBySeasonProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopBySeasonProducts.
     */
    skip?: number
    distinct?: ShopBySeasonProductScalarFieldEnum | ShopBySeasonProductScalarFieldEnum[]
  }

  /**
   * ShopBySeasonProduct create
   */
  export type ShopBySeasonProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopBySeasonProduct.
     */
    data: XOR<ShopBySeasonProductCreateInput, ShopBySeasonProductUncheckedCreateInput>
  }

  /**
   * ShopBySeasonProduct createMany
   */
  export type ShopBySeasonProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopBySeasonProducts.
     */
    data: ShopBySeasonProductCreateManyInput | ShopBySeasonProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShopBySeasonProduct update
   */
  export type ShopBySeasonProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopBySeasonProduct.
     */
    data: XOR<ShopBySeasonProductUpdateInput, ShopBySeasonProductUncheckedUpdateInput>
    /**
     * Choose, which ShopBySeasonProduct to update.
     */
    where: ShopBySeasonProductWhereUniqueInput
  }

  /**
   * ShopBySeasonProduct updateMany
   */
  export type ShopBySeasonProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopBySeasonProducts.
     */
    data: XOR<ShopBySeasonProductUpdateManyMutationInput, ShopBySeasonProductUncheckedUpdateManyInput>
    /**
     * Filter which ShopBySeasonProducts to update
     */
    where?: ShopBySeasonProductWhereInput
    /**
     * Limit how many ShopBySeasonProducts to update.
     */
    limit?: number
  }

  /**
   * ShopBySeasonProduct upsert
   */
  export type ShopBySeasonProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopBySeasonProduct to update in case it exists.
     */
    where: ShopBySeasonProductWhereUniqueInput
    /**
     * In case the ShopBySeasonProduct found by the `where` argument doesn't exist, create a new ShopBySeasonProduct with this data.
     */
    create: XOR<ShopBySeasonProductCreateInput, ShopBySeasonProductUncheckedCreateInput>
    /**
     * In case the ShopBySeasonProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopBySeasonProductUpdateInput, ShopBySeasonProductUncheckedUpdateInput>
  }

  /**
   * ShopBySeasonProduct delete
   */
  export type ShopBySeasonProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
    /**
     * Filter which ShopBySeasonProduct to delete.
     */
    where: ShopBySeasonProductWhereUniqueInput
  }

  /**
   * ShopBySeasonProduct deleteMany
   */
  export type ShopBySeasonProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopBySeasonProducts to delete
     */
    where?: ShopBySeasonProductWhereInput
    /**
     * Limit how many ShopBySeasonProducts to delete.
     */
    limit?: number
  }

  /**
   * ShopBySeasonProduct without action
   */
  export type ShopBySeasonProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopBySeasonProduct
     */
    select?: ShopBySeasonProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShopBySeasonProduct
     */
    omit?: ShopBySeasonProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopBySeasonProductInclude<ExtArgs> | null
  }


  /**
   * Model Showcases
   */

  export type AggregateShowcases = {
    _count: ShowcasesCountAggregateOutputType | null
    _min: ShowcasesMinAggregateOutputType | null
    _max: ShowcasesMaxAggregateOutputType | null
  }

  export type ShowcasesMinAggregateOutputType = {
    id: string | null
    title: string | null
    imageUrl: string | null
    hyperLink: string | null
    categoryHyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShowcasesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    imageUrl: string | null
    hyperLink: string | null
    categoryHyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShowcasesCountAggregateOutputType = {
    id: number
    title: number
    imageUrl: number
    hyperLink: number
    categoryHyperLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShowcasesMinAggregateInputType = {
    id?: true
    title?: true
    imageUrl?: true
    hyperLink?: true
    categoryHyperLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShowcasesMaxAggregateInputType = {
    id?: true
    title?: true
    imageUrl?: true
    hyperLink?: true
    categoryHyperLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShowcasesCountAggregateInputType = {
    id?: true
    title?: true
    imageUrl?: true
    hyperLink?: true
    categoryHyperLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShowcasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Showcases to aggregate.
     */
    where?: ShowcasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showcases to fetch.
     */
    orderBy?: ShowcasesOrderByWithRelationInput | ShowcasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShowcasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showcases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Showcases
    **/
    _count?: true | ShowcasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShowcasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShowcasesMaxAggregateInputType
  }

  export type GetShowcasesAggregateType<T extends ShowcasesAggregateArgs> = {
        [P in keyof T & keyof AggregateShowcases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShowcases[P]>
      : GetScalarType<T[P], AggregateShowcases[P]>
  }




  export type ShowcasesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowcasesWhereInput
    orderBy?: ShowcasesOrderByWithAggregationInput | ShowcasesOrderByWithAggregationInput[]
    by: ShowcasesScalarFieldEnum[] | ShowcasesScalarFieldEnum
    having?: ShowcasesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShowcasesCountAggregateInputType | true
    _min?: ShowcasesMinAggregateInputType
    _max?: ShowcasesMaxAggregateInputType
  }

  export type ShowcasesGroupByOutputType = {
    id: string
    title: string
    imageUrl: string
    hyperLink: string
    categoryHyperLink: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShowcasesCountAggregateOutputType | null
    _min: ShowcasesMinAggregateOutputType | null
    _max: ShowcasesMaxAggregateOutputType | null
  }

  type GetShowcasesGroupByPayload<T extends ShowcasesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShowcasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShowcasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShowcasesGroupByOutputType[P]>
            : GetScalarType<T[P], ShowcasesGroupByOutputType[P]>
        }
      >
    >


  export type ShowcasesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    categoryHyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["showcases"]>



  export type ShowcasesSelectScalar = {
    id?: boolean
    title?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
    categoryHyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShowcasesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "imageUrl" | "hyperLink" | "categoryHyperLink" | "createdAt" | "updatedAt", ExtArgs["result"]["showcases"]>

  export type $ShowcasesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Showcases"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      imageUrl: string
      hyperLink: string
      categoryHyperLink: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["showcases"]>
    composites: {}
  }

  type ShowcasesGetPayload<S extends boolean | null | undefined | ShowcasesDefaultArgs> = $Result.GetResult<Prisma.$ShowcasesPayload, S>

  type ShowcasesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShowcasesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShowcasesCountAggregateInputType | true
    }

  export interface ShowcasesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Showcases'], meta: { name: 'Showcases' } }
    /**
     * Find zero or one Showcases that matches the filter.
     * @param {ShowcasesFindUniqueArgs} args - Arguments to find a Showcases
     * @example
     * // Get one Showcases
     * const showcases = await prisma.showcases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShowcasesFindUniqueArgs>(args: SelectSubset<T, ShowcasesFindUniqueArgs<ExtArgs>>): Prisma__ShowcasesClient<$Result.GetResult<Prisma.$ShowcasesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Showcases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShowcasesFindUniqueOrThrowArgs} args - Arguments to find a Showcases
     * @example
     * // Get one Showcases
     * const showcases = await prisma.showcases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShowcasesFindUniqueOrThrowArgs>(args: SelectSubset<T, ShowcasesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShowcasesClient<$Result.GetResult<Prisma.$ShowcasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Showcases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowcasesFindFirstArgs} args - Arguments to find a Showcases
     * @example
     * // Get one Showcases
     * const showcases = await prisma.showcases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShowcasesFindFirstArgs>(args?: SelectSubset<T, ShowcasesFindFirstArgs<ExtArgs>>): Prisma__ShowcasesClient<$Result.GetResult<Prisma.$ShowcasesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Showcases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowcasesFindFirstOrThrowArgs} args - Arguments to find a Showcases
     * @example
     * // Get one Showcases
     * const showcases = await prisma.showcases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShowcasesFindFirstOrThrowArgs>(args?: SelectSubset<T, ShowcasesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShowcasesClient<$Result.GetResult<Prisma.$ShowcasesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Showcases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowcasesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Showcases
     * const showcases = await prisma.showcases.findMany()
     * 
     * // Get first 10 Showcases
     * const showcases = await prisma.showcases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const showcasesWithIdOnly = await prisma.showcases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShowcasesFindManyArgs>(args?: SelectSubset<T, ShowcasesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowcasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Showcases.
     * @param {ShowcasesCreateArgs} args - Arguments to create a Showcases.
     * @example
     * // Create one Showcases
     * const Showcases = await prisma.showcases.create({
     *   data: {
     *     // ... data to create a Showcases
     *   }
     * })
     * 
     */
    create<T extends ShowcasesCreateArgs>(args: SelectSubset<T, ShowcasesCreateArgs<ExtArgs>>): Prisma__ShowcasesClient<$Result.GetResult<Prisma.$ShowcasesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Showcases.
     * @param {ShowcasesCreateManyArgs} args - Arguments to create many Showcases.
     * @example
     * // Create many Showcases
     * const showcases = await prisma.showcases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShowcasesCreateManyArgs>(args?: SelectSubset<T, ShowcasesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Showcases.
     * @param {ShowcasesDeleteArgs} args - Arguments to delete one Showcases.
     * @example
     * // Delete one Showcases
     * const Showcases = await prisma.showcases.delete({
     *   where: {
     *     // ... filter to delete one Showcases
     *   }
     * })
     * 
     */
    delete<T extends ShowcasesDeleteArgs>(args: SelectSubset<T, ShowcasesDeleteArgs<ExtArgs>>): Prisma__ShowcasesClient<$Result.GetResult<Prisma.$ShowcasesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Showcases.
     * @param {ShowcasesUpdateArgs} args - Arguments to update one Showcases.
     * @example
     * // Update one Showcases
     * const showcases = await prisma.showcases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShowcasesUpdateArgs>(args: SelectSubset<T, ShowcasesUpdateArgs<ExtArgs>>): Prisma__ShowcasesClient<$Result.GetResult<Prisma.$ShowcasesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Showcases.
     * @param {ShowcasesDeleteManyArgs} args - Arguments to filter Showcases to delete.
     * @example
     * // Delete a few Showcases
     * const { count } = await prisma.showcases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShowcasesDeleteManyArgs>(args?: SelectSubset<T, ShowcasesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Showcases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowcasesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Showcases
     * const showcases = await prisma.showcases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShowcasesUpdateManyArgs>(args: SelectSubset<T, ShowcasesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Showcases.
     * @param {ShowcasesUpsertArgs} args - Arguments to update or create a Showcases.
     * @example
     * // Update or create a Showcases
     * const showcases = await prisma.showcases.upsert({
     *   create: {
     *     // ... data to create a Showcases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Showcases we want to update
     *   }
     * })
     */
    upsert<T extends ShowcasesUpsertArgs>(args: SelectSubset<T, ShowcasesUpsertArgs<ExtArgs>>): Prisma__ShowcasesClient<$Result.GetResult<Prisma.$ShowcasesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Showcases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowcasesCountArgs} args - Arguments to filter Showcases to count.
     * @example
     * // Count the number of Showcases
     * const count = await prisma.showcases.count({
     *   where: {
     *     // ... the filter for the Showcases we want to count
     *   }
     * })
    **/
    count<T extends ShowcasesCountArgs>(
      args?: Subset<T, ShowcasesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShowcasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Showcases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowcasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShowcasesAggregateArgs>(args: Subset<T, ShowcasesAggregateArgs>): Prisma.PrismaPromise<GetShowcasesAggregateType<T>>

    /**
     * Group by Showcases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowcasesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShowcasesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShowcasesGroupByArgs['orderBy'] }
        : { orderBy?: ShowcasesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShowcasesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShowcasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Showcases model
   */
  readonly fields: ShowcasesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Showcases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShowcasesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Showcases model
   */ 
  interface ShowcasesFieldRefs {
    readonly id: FieldRef<"Showcases", 'String'>
    readonly title: FieldRef<"Showcases", 'String'>
    readonly imageUrl: FieldRef<"Showcases", 'String'>
    readonly hyperLink: FieldRef<"Showcases", 'String'>
    readonly categoryHyperLink: FieldRef<"Showcases", 'String'>
    readonly createdAt: FieldRef<"Showcases", 'DateTime'>
    readonly updatedAt: FieldRef<"Showcases", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Showcases findUnique
   */
  export type ShowcasesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
    /**
     * Filter, which Showcases to fetch.
     */
    where: ShowcasesWhereUniqueInput
  }

  /**
   * Showcases findUniqueOrThrow
   */
  export type ShowcasesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
    /**
     * Filter, which Showcases to fetch.
     */
    where: ShowcasesWhereUniqueInput
  }

  /**
   * Showcases findFirst
   */
  export type ShowcasesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
    /**
     * Filter, which Showcases to fetch.
     */
    where?: ShowcasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showcases to fetch.
     */
    orderBy?: ShowcasesOrderByWithRelationInput | ShowcasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Showcases.
     */
    cursor?: ShowcasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showcases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Showcases.
     */
    distinct?: ShowcasesScalarFieldEnum | ShowcasesScalarFieldEnum[]
  }

  /**
   * Showcases findFirstOrThrow
   */
  export type ShowcasesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
    /**
     * Filter, which Showcases to fetch.
     */
    where?: ShowcasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showcases to fetch.
     */
    orderBy?: ShowcasesOrderByWithRelationInput | ShowcasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Showcases.
     */
    cursor?: ShowcasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showcases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Showcases.
     */
    distinct?: ShowcasesScalarFieldEnum | ShowcasesScalarFieldEnum[]
  }

  /**
   * Showcases findMany
   */
  export type ShowcasesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
    /**
     * Filter, which Showcases to fetch.
     */
    where?: ShowcasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Showcases to fetch.
     */
    orderBy?: ShowcasesOrderByWithRelationInput | ShowcasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Showcases.
     */
    cursor?: ShowcasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Showcases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Showcases.
     */
    skip?: number
    distinct?: ShowcasesScalarFieldEnum | ShowcasesScalarFieldEnum[]
  }

  /**
   * Showcases create
   */
  export type ShowcasesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
    /**
     * The data needed to create a Showcases.
     */
    data: XOR<ShowcasesCreateInput, ShowcasesUncheckedCreateInput>
  }

  /**
   * Showcases createMany
   */
  export type ShowcasesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Showcases.
     */
    data: ShowcasesCreateManyInput | ShowcasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Showcases update
   */
  export type ShowcasesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
    /**
     * The data needed to update a Showcases.
     */
    data: XOR<ShowcasesUpdateInput, ShowcasesUncheckedUpdateInput>
    /**
     * Choose, which Showcases to update.
     */
    where: ShowcasesWhereUniqueInput
  }

  /**
   * Showcases updateMany
   */
  export type ShowcasesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Showcases.
     */
    data: XOR<ShowcasesUpdateManyMutationInput, ShowcasesUncheckedUpdateManyInput>
    /**
     * Filter which Showcases to update
     */
    where?: ShowcasesWhereInput
    /**
     * Limit how many Showcases to update.
     */
    limit?: number
  }

  /**
   * Showcases upsert
   */
  export type ShowcasesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
    /**
     * The filter to search for the Showcases to update in case it exists.
     */
    where: ShowcasesWhereUniqueInput
    /**
     * In case the Showcases found by the `where` argument doesn't exist, create a new Showcases with this data.
     */
    create: XOR<ShowcasesCreateInput, ShowcasesUncheckedCreateInput>
    /**
     * In case the Showcases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShowcasesUpdateInput, ShowcasesUncheckedUpdateInput>
  }

  /**
   * Showcases delete
   */
  export type ShowcasesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
    /**
     * Filter which Showcases to delete.
     */
    where: ShowcasesWhereUniqueInput
  }

  /**
   * Showcases deleteMany
   */
  export type ShowcasesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Showcases to delete
     */
    where?: ShowcasesWhereInput
    /**
     * Limit how many Showcases to delete.
     */
    limit?: number
  }

  /**
   * Showcases without action
   */
  export type ShowcasesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Showcases
     */
    select?: ShowcasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Showcases
     */
    omit?: ShowcasesOmit<ExtArgs> | null
  }


  /**
   * Model SizeChart
   */

  export type AggregateSizeChart = {
    _count: SizeChartCountAggregateOutputType | null
    _min: SizeChartMinAggregateOutputType | null
    _max: SizeChartMaxAggregateOutputType | null
  }

  export type SizeChartMinAggregateOutputType = {
    id: string | null
    title: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type SizeChartMaxAggregateOutputType = {
    id: string | null
    title: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type SizeChartCountAggregateOutputType = {
    id: number
    title: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type SizeChartMinAggregateInputType = {
    id?: true
    title?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type SizeChartMaxAggregateInputType = {
    id?: true
    title?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type SizeChartCountAggregateInputType = {
    id?: true
    title?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type SizeChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SizeChart to aggregate.
     */
    where?: SizeChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SizeCharts to fetch.
     */
    orderBy?: SizeChartOrderByWithRelationInput | SizeChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SizeChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SizeCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SizeCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SizeCharts
    **/
    _count?: true | SizeChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SizeChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SizeChartMaxAggregateInputType
  }

  export type GetSizeChartAggregateType<T extends SizeChartAggregateArgs> = {
        [P in keyof T & keyof AggregateSizeChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSizeChart[P]>
      : GetScalarType<T[P], AggregateSizeChart[P]>
  }




  export type SizeChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SizeChartWhereInput
    orderBy?: SizeChartOrderByWithAggregationInput | SizeChartOrderByWithAggregationInput[]
    by: SizeChartScalarFieldEnum[] | SizeChartScalarFieldEnum
    having?: SizeChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SizeChartCountAggregateInputType | true
    _min?: SizeChartMinAggregateInputType
    _max?: SizeChartMaxAggregateInputType
  }

  export type SizeChartGroupByOutputType = {
    id: string
    title: string | null
    imageUrl: string
    createdAt: Date
    updatedAt: Date
    productId: string | null
    _count: SizeChartCountAggregateOutputType | null
    _min: SizeChartMinAggregateOutputType | null
    _max: SizeChartMaxAggregateOutputType | null
  }

  type GetSizeChartGroupByPayload<T extends SizeChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SizeChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SizeChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SizeChartGroupByOutputType[P]>
            : GetScalarType<T[P], SizeChartGroupByOutputType[P]>
        }
      >
    >


  export type SizeChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    Product?: boolean | SizeChart$ProductArgs<ExtArgs>
    _count?: boolean | SizeChartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sizeChart"]>



  export type SizeChartSelectScalar = {
    id?: boolean
    title?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type SizeChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "imageUrl" | "createdAt" | "updatedAt" | "productId", ExtArgs["result"]["sizeChart"]>
  export type SizeChartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | SizeChart$ProductArgs<ExtArgs>
    _count?: boolean | SizeChartCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SizeChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SizeChart"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      imageUrl: string
      createdAt: Date
      updatedAt: Date
      productId: string | null
    }, ExtArgs["result"]["sizeChart"]>
    composites: {}
  }

  type SizeChartGetPayload<S extends boolean | null | undefined | SizeChartDefaultArgs> = $Result.GetResult<Prisma.$SizeChartPayload, S>

  type SizeChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SizeChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SizeChartCountAggregateInputType | true
    }

  export interface SizeChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SizeChart'], meta: { name: 'SizeChart' } }
    /**
     * Find zero or one SizeChart that matches the filter.
     * @param {SizeChartFindUniqueArgs} args - Arguments to find a SizeChart
     * @example
     * // Get one SizeChart
     * const sizeChart = await prisma.sizeChart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SizeChartFindUniqueArgs>(args: SelectSubset<T, SizeChartFindUniqueArgs<ExtArgs>>): Prisma__SizeChartClient<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SizeChart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SizeChartFindUniqueOrThrowArgs} args - Arguments to find a SizeChart
     * @example
     * // Get one SizeChart
     * const sizeChart = await prisma.sizeChart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SizeChartFindUniqueOrThrowArgs>(args: SelectSubset<T, SizeChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SizeChartClient<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SizeChart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeChartFindFirstArgs} args - Arguments to find a SizeChart
     * @example
     * // Get one SizeChart
     * const sizeChart = await prisma.sizeChart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SizeChartFindFirstArgs>(args?: SelectSubset<T, SizeChartFindFirstArgs<ExtArgs>>): Prisma__SizeChartClient<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SizeChart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeChartFindFirstOrThrowArgs} args - Arguments to find a SizeChart
     * @example
     * // Get one SizeChart
     * const sizeChart = await prisma.sizeChart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SizeChartFindFirstOrThrowArgs>(args?: SelectSubset<T, SizeChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__SizeChartClient<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SizeCharts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SizeCharts
     * const sizeCharts = await prisma.sizeChart.findMany()
     * 
     * // Get first 10 SizeCharts
     * const sizeCharts = await prisma.sizeChart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sizeChartWithIdOnly = await prisma.sizeChart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SizeChartFindManyArgs>(args?: SelectSubset<T, SizeChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SizeChart.
     * @param {SizeChartCreateArgs} args - Arguments to create a SizeChart.
     * @example
     * // Create one SizeChart
     * const SizeChart = await prisma.sizeChart.create({
     *   data: {
     *     // ... data to create a SizeChart
     *   }
     * })
     * 
     */
    create<T extends SizeChartCreateArgs>(args: SelectSubset<T, SizeChartCreateArgs<ExtArgs>>): Prisma__SizeChartClient<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SizeCharts.
     * @param {SizeChartCreateManyArgs} args - Arguments to create many SizeCharts.
     * @example
     * // Create many SizeCharts
     * const sizeChart = await prisma.sizeChart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SizeChartCreateManyArgs>(args?: SelectSubset<T, SizeChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SizeChart.
     * @param {SizeChartDeleteArgs} args - Arguments to delete one SizeChart.
     * @example
     * // Delete one SizeChart
     * const SizeChart = await prisma.sizeChart.delete({
     *   where: {
     *     // ... filter to delete one SizeChart
     *   }
     * })
     * 
     */
    delete<T extends SizeChartDeleteArgs>(args: SelectSubset<T, SizeChartDeleteArgs<ExtArgs>>): Prisma__SizeChartClient<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SizeChart.
     * @param {SizeChartUpdateArgs} args - Arguments to update one SizeChart.
     * @example
     * // Update one SizeChart
     * const sizeChart = await prisma.sizeChart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SizeChartUpdateArgs>(args: SelectSubset<T, SizeChartUpdateArgs<ExtArgs>>): Prisma__SizeChartClient<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SizeCharts.
     * @param {SizeChartDeleteManyArgs} args - Arguments to filter SizeCharts to delete.
     * @example
     * // Delete a few SizeCharts
     * const { count } = await prisma.sizeChart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SizeChartDeleteManyArgs>(args?: SelectSubset<T, SizeChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SizeCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SizeCharts
     * const sizeChart = await prisma.sizeChart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SizeChartUpdateManyArgs>(args: SelectSubset<T, SizeChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SizeChart.
     * @param {SizeChartUpsertArgs} args - Arguments to update or create a SizeChart.
     * @example
     * // Update or create a SizeChart
     * const sizeChart = await prisma.sizeChart.upsert({
     *   create: {
     *     // ... data to create a SizeChart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SizeChart we want to update
     *   }
     * })
     */
    upsert<T extends SizeChartUpsertArgs>(args: SelectSubset<T, SizeChartUpsertArgs<ExtArgs>>): Prisma__SizeChartClient<$Result.GetResult<Prisma.$SizeChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SizeCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeChartCountArgs} args - Arguments to filter SizeCharts to count.
     * @example
     * // Count the number of SizeCharts
     * const count = await prisma.sizeChart.count({
     *   where: {
     *     // ... the filter for the SizeCharts we want to count
     *   }
     * })
    **/
    count<T extends SizeChartCountArgs>(
      args?: Subset<T, SizeChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SizeChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SizeChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SizeChartAggregateArgs>(args: Subset<T, SizeChartAggregateArgs>): Prisma.PrismaPromise<GetSizeChartAggregateType<T>>

    /**
     * Group by SizeChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SizeChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SizeChartGroupByArgs['orderBy'] }
        : { orderBy?: SizeChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SizeChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSizeChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SizeChart model
   */
  readonly fields: SizeChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SizeChart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SizeChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends SizeChart$ProductArgs<ExtArgs> = {}>(args?: Subset<T, SizeChart$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SizeChart model
   */ 
  interface SizeChartFieldRefs {
    readonly id: FieldRef<"SizeChart", 'String'>
    readonly title: FieldRef<"SizeChart", 'String'>
    readonly imageUrl: FieldRef<"SizeChart", 'String'>
    readonly createdAt: FieldRef<"SizeChart", 'DateTime'>
    readonly updatedAt: FieldRef<"SizeChart", 'DateTime'>
    readonly productId: FieldRef<"SizeChart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SizeChart findUnique
   */
  export type SizeChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    /**
     * Filter, which SizeChart to fetch.
     */
    where: SizeChartWhereUniqueInput
  }

  /**
   * SizeChart findUniqueOrThrow
   */
  export type SizeChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    /**
     * Filter, which SizeChart to fetch.
     */
    where: SizeChartWhereUniqueInput
  }

  /**
   * SizeChart findFirst
   */
  export type SizeChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    /**
     * Filter, which SizeChart to fetch.
     */
    where?: SizeChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SizeCharts to fetch.
     */
    orderBy?: SizeChartOrderByWithRelationInput | SizeChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SizeCharts.
     */
    cursor?: SizeChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SizeCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SizeCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SizeCharts.
     */
    distinct?: SizeChartScalarFieldEnum | SizeChartScalarFieldEnum[]
  }

  /**
   * SizeChart findFirstOrThrow
   */
  export type SizeChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    /**
     * Filter, which SizeChart to fetch.
     */
    where?: SizeChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SizeCharts to fetch.
     */
    orderBy?: SizeChartOrderByWithRelationInput | SizeChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SizeCharts.
     */
    cursor?: SizeChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SizeCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SizeCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SizeCharts.
     */
    distinct?: SizeChartScalarFieldEnum | SizeChartScalarFieldEnum[]
  }

  /**
   * SizeChart findMany
   */
  export type SizeChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    /**
     * Filter, which SizeCharts to fetch.
     */
    where?: SizeChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SizeCharts to fetch.
     */
    orderBy?: SizeChartOrderByWithRelationInput | SizeChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SizeCharts.
     */
    cursor?: SizeChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SizeCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SizeCharts.
     */
    skip?: number
    distinct?: SizeChartScalarFieldEnum | SizeChartScalarFieldEnum[]
  }

  /**
   * SizeChart create
   */
  export type SizeChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    /**
     * The data needed to create a SizeChart.
     */
    data: XOR<SizeChartCreateInput, SizeChartUncheckedCreateInput>
  }

  /**
   * SizeChart createMany
   */
  export type SizeChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SizeCharts.
     */
    data: SizeChartCreateManyInput | SizeChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SizeChart update
   */
  export type SizeChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    /**
     * The data needed to update a SizeChart.
     */
    data: XOR<SizeChartUpdateInput, SizeChartUncheckedUpdateInput>
    /**
     * Choose, which SizeChart to update.
     */
    where: SizeChartWhereUniqueInput
  }

  /**
   * SizeChart updateMany
   */
  export type SizeChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SizeCharts.
     */
    data: XOR<SizeChartUpdateManyMutationInput, SizeChartUncheckedUpdateManyInput>
    /**
     * Filter which SizeCharts to update
     */
    where?: SizeChartWhereInput
    /**
     * Limit how many SizeCharts to update.
     */
    limit?: number
  }

  /**
   * SizeChart upsert
   */
  export type SizeChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    /**
     * The filter to search for the SizeChart to update in case it exists.
     */
    where: SizeChartWhereUniqueInput
    /**
     * In case the SizeChart found by the `where` argument doesn't exist, create a new SizeChart with this data.
     */
    create: XOR<SizeChartCreateInput, SizeChartUncheckedCreateInput>
    /**
     * In case the SizeChart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SizeChartUpdateInput, SizeChartUncheckedUpdateInput>
  }

  /**
   * SizeChart delete
   */
  export type SizeChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
    /**
     * Filter which SizeChart to delete.
     */
    where: SizeChartWhereUniqueInput
  }

  /**
   * SizeChart deleteMany
   */
  export type SizeChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SizeCharts to delete
     */
    where?: SizeChartWhereInput
    /**
     * Limit how many SizeCharts to delete.
     */
    limit?: number
  }

  /**
   * SizeChart.Product
   */
  export type SizeChart$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * SizeChart without action
   */
  export type SizeChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeChart
     */
    select?: SizeChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SizeChart
     */
    omit?: SizeChartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeChartInclude<ExtArgs> | null
  }


  /**
   * Model SocialLinks
   */

  export type AggregateSocialLinks = {
    _count: SocialLinksCountAggregateOutputType | null
    _min: SocialLinksMinAggregateOutputType | null
    _max: SocialLinksMaxAggregateOutputType | null
  }

  export type SocialLinksMinAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
  }

  export type SocialLinksMaxAggregateOutputType = {
    id: string | null
    imageUrl: string | null
    hyperLink: string | null
  }

  export type SocialLinksCountAggregateOutputType = {
    id: number
    imageUrl: number
    hyperLink: number
    _all: number
  }


  export type SocialLinksMinAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
  }

  export type SocialLinksMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
  }

  export type SocialLinksCountAggregateInputType = {
    id?: true
    imageUrl?: true
    hyperLink?: true
    _all?: true
  }

  export type SocialLinksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLinks to aggregate.
     */
    where?: SocialLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinksOrderByWithRelationInput | SocialLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialLinks
    **/
    _count?: true | SocialLinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialLinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialLinksMaxAggregateInputType
  }

  export type GetSocialLinksAggregateType<T extends SocialLinksAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialLinks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialLinks[P]>
      : GetScalarType<T[P], AggregateSocialLinks[P]>
  }




  export type SocialLinksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLinksWhereInput
    orderBy?: SocialLinksOrderByWithAggregationInput | SocialLinksOrderByWithAggregationInput[]
    by: SocialLinksScalarFieldEnum[] | SocialLinksScalarFieldEnum
    having?: SocialLinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialLinksCountAggregateInputType | true
    _min?: SocialLinksMinAggregateInputType
    _max?: SocialLinksMaxAggregateInputType
  }

  export type SocialLinksGroupByOutputType = {
    id: string
    imageUrl: string | null
    hyperLink: string | null
    _count: SocialLinksCountAggregateOutputType | null
    _min: SocialLinksMinAggregateOutputType | null
    _max: SocialLinksMaxAggregateOutputType | null
  }

  type GetSocialLinksGroupByPayload<T extends SocialLinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialLinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialLinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialLinksGroupByOutputType[P]>
            : GetScalarType<T[P], SocialLinksGroupByOutputType[P]>
        }
      >
    >


  export type SocialLinksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
  }, ExtArgs["result"]["socialLinks"]>



  export type SocialLinksSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    hyperLink?: boolean
  }

  export type SocialLinksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "imageUrl" | "hyperLink", ExtArgs["result"]["socialLinks"]>

  export type $SocialLinksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialLinks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imageUrl: string | null
      hyperLink: string | null
    }, ExtArgs["result"]["socialLinks"]>
    composites: {}
  }

  type SocialLinksGetPayload<S extends boolean | null | undefined | SocialLinksDefaultArgs> = $Result.GetResult<Prisma.$SocialLinksPayload, S>

  type SocialLinksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialLinksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialLinksCountAggregateInputType | true
    }

  export interface SocialLinksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialLinks'], meta: { name: 'SocialLinks' } }
    /**
     * Find zero or one SocialLinks that matches the filter.
     * @param {SocialLinksFindUniqueArgs} args - Arguments to find a SocialLinks
     * @example
     * // Get one SocialLinks
     * const socialLinks = await prisma.socialLinks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialLinksFindUniqueArgs>(args: SelectSubset<T, SocialLinksFindUniqueArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialLinks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialLinksFindUniqueOrThrowArgs} args - Arguments to find a SocialLinks
     * @example
     * // Get one SocialLinks
     * const socialLinks = await prisma.socialLinks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialLinksFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialLinksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksFindFirstArgs} args - Arguments to find a SocialLinks
     * @example
     * // Get one SocialLinks
     * const socialLinks = await prisma.socialLinks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialLinksFindFirstArgs>(args?: SelectSubset<T, SocialLinksFindFirstArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLinks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksFindFirstOrThrowArgs} args - Arguments to find a SocialLinks
     * @example
     * // Get one SocialLinks
     * const socialLinks = await prisma.socialLinks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialLinksFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialLinksFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialLinks
     * const socialLinks = await prisma.socialLinks.findMany()
     * 
     * // Get first 10 SocialLinks
     * const socialLinks = await prisma.socialLinks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialLinksWithIdOnly = await prisma.socialLinks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialLinksFindManyArgs>(args?: SelectSubset<T, SocialLinksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialLinks.
     * @param {SocialLinksCreateArgs} args - Arguments to create a SocialLinks.
     * @example
     * // Create one SocialLinks
     * const SocialLinks = await prisma.socialLinks.create({
     *   data: {
     *     // ... data to create a SocialLinks
     *   }
     * })
     * 
     */
    create<T extends SocialLinksCreateArgs>(args: SelectSubset<T, SocialLinksCreateArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialLinks.
     * @param {SocialLinksCreateManyArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLinks = await prisma.socialLinks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialLinksCreateManyArgs>(args?: SelectSubset<T, SocialLinksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialLinks.
     * @param {SocialLinksDeleteArgs} args - Arguments to delete one SocialLinks.
     * @example
     * // Delete one SocialLinks
     * const SocialLinks = await prisma.socialLinks.delete({
     *   where: {
     *     // ... filter to delete one SocialLinks
     *   }
     * })
     * 
     */
    delete<T extends SocialLinksDeleteArgs>(args: SelectSubset<T, SocialLinksDeleteArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialLinks.
     * @param {SocialLinksUpdateArgs} args - Arguments to update one SocialLinks.
     * @example
     * // Update one SocialLinks
     * const socialLinks = await prisma.socialLinks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialLinksUpdateArgs>(args: SelectSubset<T, SocialLinksUpdateArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialLinks.
     * @param {SocialLinksDeleteManyArgs} args - Arguments to filter SocialLinks to delete.
     * @example
     * // Delete a few SocialLinks
     * const { count } = await prisma.socialLinks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialLinksDeleteManyArgs>(args?: SelectSubset<T, SocialLinksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialLinks
     * const socialLinks = await prisma.socialLinks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialLinksUpdateManyArgs>(args: SelectSubset<T, SocialLinksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialLinks.
     * @param {SocialLinksUpsertArgs} args - Arguments to update or create a SocialLinks.
     * @example
     * // Update or create a SocialLinks
     * const socialLinks = await prisma.socialLinks.upsert({
     *   create: {
     *     // ... data to create a SocialLinks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialLinks we want to update
     *   }
     * })
     */
    upsert<T extends SocialLinksUpsertArgs>(args: SelectSubset<T, SocialLinksUpsertArgs<ExtArgs>>): Prisma__SocialLinksClient<$Result.GetResult<Prisma.$SocialLinksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksCountArgs} args - Arguments to filter SocialLinks to count.
     * @example
     * // Count the number of SocialLinks
     * const count = await prisma.socialLinks.count({
     *   where: {
     *     // ... the filter for the SocialLinks we want to count
     *   }
     * })
    **/
    count<T extends SocialLinksCountArgs>(
      args?: Subset<T, SocialLinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialLinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialLinksAggregateArgs>(args: Subset<T, SocialLinksAggregateArgs>): Prisma.PrismaPromise<GetSocialLinksAggregateType<T>>

    /**
     * Group by SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialLinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialLinksGroupByArgs['orderBy'] }
        : { orderBy?: SocialLinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialLinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialLinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialLinks model
   */
  readonly fields: SocialLinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialLinks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialLinksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialLinks model
   */ 
  interface SocialLinksFieldRefs {
    readonly id: FieldRef<"SocialLinks", 'String'>
    readonly imageUrl: FieldRef<"SocialLinks", 'String'>
    readonly hyperLink: FieldRef<"SocialLinks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SocialLinks findUnique
   */
  export type SocialLinksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where: SocialLinksWhereUniqueInput
  }

  /**
   * SocialLinks findUniqueOrThrow
   */
  export type SocialLinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where: SocialLinksWhereUniqueInput
  }

  /**
   * SocialLinks findFirst
   */
  export type SocialLinksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinksOrderByWithRelationInput | SocialLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinksScalarFieldEnum | SocialLinksScalarFieldEnum[]
  }

  /**
   * SocialLinks findFirstOrThrow
   */
  export type SocialLinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinksOrderByWithRelationInput | SocialLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinksScalarFieldEnum | SocialLinksScalarFieldEnum[]
  }

  /**
   * SocialLinks findMany
   */
  export type SocialLinksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinksOrderByWithRelationInput | SocialLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialLinks.
     */
    cursor?: SocialLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    distinct?: SocialLinksScalarFieldEnum | SocialLinksScalarFieldEnum[]
  }

  /**
   * SocialLinks create
   */
  export type SocialLinksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * The data needed to create a SocialLinks.
     */
    data: XOR<SocialLinksCreateInput, SocialLinksUncheckedCreateInput>
  }

  /**
   * SocialLinks createMany
   */
  export type SocialLinksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialLinks.
     */
    data: SocialLinksCreateManyInput | SocialLinksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialLinks update
   */
  export type SocialLinksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * The data needed to update a SocialLinks.
     */
    data: XOR<SocialLinksUpdateInput, SocialLinksUncheckedUpdateInput>
    /**
     * Choose, which SocialLinks to update.
     */
    where: SocialLinksWhereUniqueInput
  }

  /**
   * SocialLinks updateMany
   */
  export type SocialLinksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialLinks.
     */
    data: XOR<SocialLinksUpdateManyMutationInput, SocialLinksUncheckedUpdateManyInput>
    /**
     * Filter which SocialLinks to update
     */
    where?: SocialLinksWhereInput
    /**
     * Limit how many SocialLinks to update.
     */
    limit?: number
  }

  /**
   * SocialLinks upsert
   */
  export type SocialLinksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * The filter to search for the SocialLinks to update in case it exists.
     */
    where: SocialLinksWhereUniqueInput
    /**
     * In case the SocialLinks found by the `where` argument doesn't exist, create a new SocialLinks with this data.
     */
    create: XOR<SocialLinksCreateInput, SocialLinksUncheckedCreateInput>
    /**
     * In case the SocialLinks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialLinksUpdateInput, SocialLinksUncheckedUpdateInput>
  }

  /**
   * SocialLinks delete
   */
  export type SocialLinksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
    /**
     * Filter which SocialLinks to delete.
     */
    where: SocialLinksWhereUniqueInput
  }

  /**
   * SocialLinks deleteMany
   */
  export type SocialLinksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLinks to delete
     */
    where?: SocialLinksWhereInput
    /**
     * Limit how many SocialLinks to delete.
     */
    limit?: number
  }

  /**
   * SocialLinks without action
   */
  export type SocialLinksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLinks
     */
    select?: SocialLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLinks
     */
    omit?: SocialLinksOmit<ExtArgs> | null
  }


  /**
   * Model StaticMessages
   */

  export type AggregateStaticMessages = {
    _count: StaticMessagesCountAggregateOutputType | null
    _min: StaticMessagesMinAggregateOutputType | null
    _max: StaticMessagesMaxAggregateOutputType | null
  }

  export type StaticMessagesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.StaticMessages_status | null
    message: string | null
    createdAt: Date | null
  }

  export type StaticMessagesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.StaticMessages_status | null
    message: string | null
    createdAt: Date | null
  }

  export type StaticMessagesCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    message: number
    createdAt: number
    _all: number
  }


  export type StaticMessagesMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type StaticMessagesMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    message?: true
    createdAt?: true
  }

  export type StaticMessagesCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type StaticMessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaticMessages to aggregate.
     */
    where?: StaticMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaticMessages to fetch.
     */
    orderBy?: StaticMessagesOrderByWithRelationInput | StaticMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaticMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaticMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaticMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaticMessages
    **/
    _count?: true | StaticMessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaticMessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaticMessagesMaxAggregateInputType
  }

  export type GetStaticMessagesAggregateType<T extends StaticMessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateStaticMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaticMessages[P]>
      : GetScalarType<T[P], AggregateStaticMessages[P]>
  }




  export type StaticMessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaticMessagesWhereInput
    orderBy?: StaticMessagesOrderByWithAggregationInput | StaticMessagesOrderByWithAggregationInput[]
    by: StaticMessagesScalarFieldEnum[] | StaticMessagesScalarFieldEnum
    having?: StaticMessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaticMessagesCountAggregateInputType | true
    _min?: StaticMessagesMinAggregateInputType
    _max?: StaticMessagesMaxAggregateInputType
  }

  export type StaticMessagesGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.StaticMessages_status
    message: string
    createdAt: Date
    _count: StaticMessagesCountAggregateOutputType | null
    _min: StaticMessagesMinAggregateOutputType | null
    _max: StaticMessagesMaxAggregateOutputType | null
  }

  type GetStaticMessagesGroupByPayload<T extends StaticMessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaticMessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaticMessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaticMessagesGroupByOutputType[P]>
            : GetScalarType<T[P], StaticMessagesGroupByOutputType[P]>
        }
      >
    >


  export type StaticMessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staticMessages"]>



  export type StaticMessagesSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type StaticMessagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "message" | "createdAt", ExtArgs["result"]["staticMessages"]>
  export type StaticMessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StaticMessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaticMessages"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.StaticMessages_status
      message: string
      createdAt: Date
    }, ExtArgs["result"]["staticMessages"]>
    composites: {}
  }

  type StaticMessagesGetPayload<S extends boolean | null | undefined | StaticMessagesDefaultArgs> = $Result.GetResult<Prisma.$StaticMessagesPayload, S>

  type StaticMessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaticMessagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaticMessagesCountAggregateInputType | true
    }

  export interface StaticMessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaticMessages'], meta: { name: 'StaticMessages' } }
    /**
     * Find zero or one StaticMessages that matches the filter.
     * @param {StaticMessagesFindUniqueArgs} args - Arguments to find a StaticMessages
     * @example
     * // Get one StaticMessages
     * const staticMessages = await prisma.staticMessages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaticMessagesFindUniqueArgs>(args: SelectSubset<T, StaticMessagesFindUniqueArgs<ExtArgs>>): Prisma__StaticMessagesClient<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaticMessages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaticMessagesFindUniqueOrThrowArgs} args - Arguments to find a StaticMessages
     * @example
     * // Get one StaticMessages
     * const staticMessages = await prisma.staticMessages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaticMessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, StaticMessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaticMessagesClient<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaticMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticMessagesFindFirstArgs} args - Arguments to find a StaticMessages
     * @example
     * // Get one StaticMessages
     * const staticMessages = await prisma.staticMessages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaticMessagesFindFirstArgs>(args?: SelectSubset<T, StaticMessagesFindFirstArgs<ExtArgs>>): Prisma__StaticMessagesClient<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaticMessages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticMessagesFindFirstOrThrowArgs} args - Arguments to find a StaticMessages
     * @example
     * // Get one StaticMessages
     * const staticMessages = await prisma.staticMessages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaticMessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, StaticMessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaticMessagesClient<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaticMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticMessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaticMessages
     * const staticMessages = await prisma.staticMessages.findMany()
     * 
     * // Get first 10 StaticMessages
     * const staticMessages = await prisma.staticMessages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staticMessagesWithIdOnly = await prisma.staticMessages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaticMessagesFindManyArgs>(args?: SelectSubset<T, StaticMessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaticMessages.
     * @param {StaticMessagesCreateArgs} args - Arguments to create a StaticMessages.
     * @example
     * // Create one StaticMessages
     * const StaticMessages = await prisma.staticMessages.create({
     *   data: {
     *     // ... data to create a StaticMessages
     *   }
     * })
     * 
     */
    create<T extends StaticMessagesCreateArgs>(args: SelectSubset<T, StaticMessagesCreateArgs<ExtArgs>>): Prisma__StaticMessagesClient<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaticMessages.
     * @param {StaticMessagesCreateManyArgs} args - Arguments to create many StaticMessages.
     * @example
     * // Create many StaticMessages
     * const staticMessages = await prisma.staticMessages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaticMessagesCreateManyArgs>(args?: SelectSubset<T, StaticMessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StaticMessages.
     * @param {StaticMessagesDeleteArgs} args - Arguments to delete one StaticMessages.
     * @example
     * // Delete one StaticMessages
     * const StaticMessages = await prisma.staticMessages.delete({
     *   where: {
     *     // ... filter to delete one StaticMessages
     *   }
     * })
     * 
     */
    delete<T extends StaticMessagesDeleteArgs>(args: SelectSubset<T, StaticMessagesDeleteArgs<ExtArgs>>): Prisma__StaticMessagesClient<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaticMessages.
     * @param {StaticMessagesUpdateArgs} args - Arguments to update one StaticMessages.
     * @example
     * // Update one StaticMessages
     * const staticMessages = await prisma.staticMessages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaticMessagesUpdateArgs>(args: SelectSubset<T, StaticMessagesUpdateArgs<ExtArgs>>): Prisma__StaticMessagesClient<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaticMessages.
     * @param {StaticMessagesDeleteManyArgs} args - Arguments to filter StaticMessages to delete.
     * @example
     * // Delete a few StaticMessages
     * const { count } = await prisma.staticMessages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaticMessagesDeleteManyArgs>(args?: SelectSubset<T, StaticMessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaticMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticMessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaticMessages
     * const staticMessages = await prisma.staticMessages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaticMessagesUpdateManyArgs>(args: SelectSubset<T, StaticMessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StaticMessages.
     * @param {StaticMessagesUpsertArgs} args - Arguments to update or create a StaticMessages.
     * @example
     * // Update or create a StaticMessages
     * const staticMessages = await prisma.staticMessages.upsert({
     *   create: {
     *     // ... data to create a StaticMessages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaticMessages we want to update
     *   }
     * })
     */
    upsert<T extends StaticMessagesUpsertArgs>(args: SelectSubset<T, StaticMessagesUpsertArgs<ExtArgs>>): Prisma__StaticMessagesClient<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaticMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticMessagesCountArgs} args - Arguments to filter StaticMessages to count.
     * @example
     * // Count the number of StaticMessages
     * const count = await prisma.staticMessages.count({
     *   where: {
     *     // ... the filter for the StaticMessages we want to count
     *   }
     * })
    **/
    count<T extends StaticMessagesCountArgs>(
      args?: Subset<T, StaticMessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaticMessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaticMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticMessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaticMessagesAggregateArgs>(args: Subset<T, StaticMessagesAggregateArgs>): Prisma.PrismaPromise<GetStaticMessagesAggregateType<T>>

    /**
     * Group by StaticMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaticMessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaticMessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaticMessagesGroupByArgs['orderBy'] }
        : { orderBy?: StaticMessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaticMessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaticMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaticMessages model
   */
  readonly fields: StaticMessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaticMessages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaticMessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaticMessages model
   */ 
  interface StaticMessagesFieldRefs {
    readonly id: FieldRef<"StaticMessages", 'String'>
    readonly userId: FieldRef<"StaticMessages", 'String'>
    readonly status: FieldRef<"StaticMessages", 'StaticMessages_status'>
    readonly message: FieldRef<"StaticMessages", 'String'>
    readonly createdAt: FieldRef<"StaticMessages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaticMessages findUnique
   */
  export type StaticMessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    /**
     * Filter, which StaticMessages to fetch.
     */
    where: StaticMessagesWhereUniqueInput
  }

  /**
   * StaticMessages findUniqueOrThrow
   */
  export type StaticMessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    /**
     * Filter, which StaticMessages to fetch.
     */
    where: StaticMessagesWhereUniqueInput
  }

  /**
   * StaticMessages findFirst
   */
  export type StaticMessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    /**
     * Filter, which StaticMessages to fetch.
     */
    where?: StaticMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaticMessages to fetch.
     */
    orderBy?: StaticMessagesOrderByWithRelationInput | StaticMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaticMessages.
     */
    cursor?: StaticMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaticMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaticMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaticMessages.
     */
    distinct?: StaticMessagesScalarFieldEnum | StaticMessagesScalarFieldEnum[]
  }

  /**
   * StaticMessages findFirstOrThrow
   */
  export type StaticMessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    /**
     * Filter, which StaticMessages to fetch.
     */
    where?: StaticMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaticMessages to fetch.
     */
    orderBy?: StaticMessagesOrderByWithRelationInput | StaticMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaticMessages.
     */
    cursor?: StaticMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaticMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaticMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaticMessages.
     */
    distinct?: StaticMessagesScalarFieldEnum | StaticMessagesScalarFieldEnum[]
  }

  /**
   * StaticMessages findMany
   */
  export type StaticMessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    /**
     * Filter, which StaticMessages to fetch.
     */
    where?: StaticMessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaticMessages to fetch.
     */
    orderBy?: StaticMessagesOrderByWithRelationInput | StaticMessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaticMessages.
     */
    cursor?: StaticMessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaticMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaticMessages.
     */
    skip?: number
    distinct?: StaticMessagesScalarFieldEnum | StaticMessagesScalarFieldEnum[]
  }

  /**
   * StaticMessages create
   */
  export type StaticMessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a StaticMessages.
     */
    data: XOR<StaticMessagesCreateInput, StaticMessagesUncheckedCreateInput>
  }

  /**
   * StaticMessages createMany
   */
  export type StaticMessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaticMessages.
     */
    data: StaticMessagesCreateManyInput | StaticMessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaticMessages update
   */
  export type StaticMessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a StaticMessages.
     */
    data: XOR<StaticMessagesUpdateInput, StaticMessagesUncheckedUpdateInput>
    /**
     * Choose, which StaticMessages to update.
     */
    where: StaticMessagesWhereUniqueInput
  }

  /**
   * StaticMessages updateMany
   */
  export type StaticMessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaticMessages.
     */
    data: XOR<StaticMessagesUpdateManyMutationInput, StaticMessagesUncheckedUpdateManyInput>
    /**
     * Filter which StaticMessages to update
     */
    where?: StaticMessagesWhereInput
    /**
     * Limit how many StaticMessages to update.
     */
    limit?: number
  }

  /**
   * StaticMessages upsert
   */
  export type StaticMessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the StaticMessages to update in case it exists.
     */
    where: StaticMessagesWhereUniqueInput
    /**
     * In case the StaticMessages found by the `where` argument doesn't exist, create a new StaticMessages with this data.
     */
    create: XOR<StaticMessagesCreateInput, StaticMessagesUncheckedCreateInput>
    /**
     * In case the StaticMessages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaticMessagesUpdateInput, StaticMessagesUncheckedUpdateInput>
  }

  /**
   * StaticMessages delete
   */
  export type StaticMessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    /**
     * Filter which StaticMessages to delete.
     */
    where: StaticMessagesWhereUniqueInput
  }

  /**
   * StaticMessages deleteMany
   */
  export type StaticMessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaticMessages to delete
     */
    where?: StaticMessagesWhereInput
    /**
     * Limit how many StaticMessages to delete.
     */
    limit?: number
  }

  /**
   * StaticMessages without action
   */
  export type StaticMessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
  }


  /**
   * Model SubCategory
   */

  export type AggregateSubCategory = {
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  export type SubCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    categoryId: string | null
    imageUrl: string | null
    seoTitle: string | null
    seoDescription: string | null
  }

  export type SubCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    categoryId: string | null
    imageUrl: string | null
    seoTitle: string | null
    seoDescription: string | null
  }

  export type SubCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    categoryId: number
    imageUrl: number
    seoTitle: number
    seoDescription: number
    _all: number
  }


  export type SubCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    categoryId?: true
    imageUrl?: true
    seoTitle?: true
    seoDescription?: true
  }

  export type SubCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    categoryId?: true
    imageUrl?: true
    seoTitle?: true
    seoDescription?: true
  }

  export type SubCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    categoryId?: true
    imageUrl?: true
    seoTitle?: true
    seoDescription?: true
    _all?: true
  }

  export type SubCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategory to aggregate.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategories
    **/
    _count?: true | SubCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoryMaxAggregateInputType
  }

  export type GetSubCategoryAggregateType<T extends SubCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategory[P]>
      : GetScalarType<T[P], AggregateSubCategory[P]>
  }




  export type SubCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithAggregationInput | SubCategoryOrderByWithAggregationInput[]
    by: SubCategoryScalarFieldEnum[] | SubCategoryScalarFieldEnum
    having?: SubCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoryCountAggregateInputType | true
    _min?: SubCategoryMinAggregateInputType
    _max?: SubCategoryMaxAggregateInputType
  }

  export type SubCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    categoryId: string
    imageUrl: string | null
    seoTitle: string | null
    seoDescription: string | null
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  type GetSubCategoryGroupByPayload<T extends SubCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    categoryId?: boolean
    imageUrl?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    Product?: boolean | SubCategory$ProductArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subCategory"]>



  export type SubCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    categoryId?: boolean
    imageUrl?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
  }

  export type SubCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "categoryId" | "imageUrl" | "seoTitle" | "seoDescription", ExtArgs["result"]["subCategory"]>
  export type SubCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    Product?: boolean | SubCategory$ProductArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubCategory"
    objects: {
      ProductCategory: Prisma.$ProductCategoryPayload<ExtArgs>
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      categoryId: string
      imageUrl: string | null
      seoTitle: string | null
      seoDescription: string | null
    }, ExtArgs["result"]["subCategory"]>
    composites: {}
  }

  type SubCategoryGetPayload<S extends boolean | null | undefined | SubCategoryDefaultArgs> = $Result.GetResult<Prisma.$SubCategoryPayload, S>

  type SubCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubCategoryCountAggregateInputType | true
    }

  export interface SubCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubCategory'], meta: { name: 'SubCategory' } }
    /**
     * Find zero or one SubCategory that matches the filter.
     * @param {SubCategoryFindUniqueArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubCategoryFindUniqueArgs>(args: SelectSubset<T, SubCategoryFindUniqueArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubCategoryFindUniqueOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubCategoryFindFirstArgs>(args?: SelectSubset<T, SubCategoryFindFirstArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategories
     * const subCategories = await prisma.subCategory.findMany()
     * 
     * // Get first 10 SubCategories
     * const subCategories = await prisma.subCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoryWithIdOnly = await prisma.subCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubCategoryFindManyArgs>(args?: SelectSubset<T, SubCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubCategory.
     * @param {SubCategoryCreateArgs} args - Arguments to create a SubCategory.
     * @example
     * // Create one SubCategory
     * const SubCategory = await prisma.subCategory.create({
     *   data: {
     *     // ... data to create a SubCategory
     *   }
     * })
     * 
     */
    create<T extends SubCategoryCreateArgs>(args: SelectSubset<T, SubCategoryCreateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubCategories.
     * @param {SubCategoryCreateManyArgs} args - Arguments to create many SubCategories.
     * @example
     * // Create many SubCategories
     * const subCategory = await prisma.subCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubCategoryCreateManyArgs>(args?: SelectSubset<T, SubCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubCategory.
     * @param {SubCategoryDeleteArgs} args - Arguments to delete one SubCategory.
     * @example
     * // Delete one SubCategory
     * const SubCategory = await prisma.subCategory.delete({
     *   where: {
     *     // ... filter to delete one SubCategory
     *   }
     * })
     * 
     */
    delete<T extends SubCategoryDeleteArgs>(args: SelectSubset<T, SubCategoryDeleteArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubCategory.
     * @param {SubCategoryUpdateArgs} args - Arguments to update one SubCategory.
     * @example
     * // Update one SubCategory
     * const subCategory = await prisma.subCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubCategoryUpdateArgs>(args: SelectSubset<T, SubCategoryUpdateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubCategories.
     * @param {SubCategoryDeleteManyArgs} args - Arguments to filter SubCategories to delete.
     * @example
     * // Delete a few SubCategories
     * const { count } = await prisma.subCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubCategoryDeleteManyArgs>(args?: SelectSubset<T, SubCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategories
     * const subCategory = await prisma.subCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubCategoryUpdateManyArgs>(args: SelectSubset<T, SubCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategory.
     * @param {SubCategoryUpsertArgs} args - Arguments to update or create a SubCategory.
     * @example
     * // Update or create a SubCategory
     * const subCategory = await prisma.subCategory.upsert({
     *   create: {
     *     // ... data to create a SubCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategory we want to update
     *   }
     * })
     */
    upsert<T extends SubCategoryUpsertArgs>(args: SelectSubset<T, SubCategoryUpsertArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryCountArgs} args - Arguments to filter SubCategories to count.
     * @example
     * // Count the number of SubCategories
     * const count = await prisma.subCategory.count({
     *   where: {
     *     // ... the filter for the SubCategories we want to count
     *   }
     * })
    **/
    count<T extends SubCategoryCountArgs>(
      args?: Subset<T, SubCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoryAggregateArgs>(args: Subset<T, SubCategoryAggregateArgs>): Prisma.PrismaPromise<GetSubCategoryAggregateType<T>>

    /**
     * Group by SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubCategory model
   */
  readonly fields: SubCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProductCategory<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Product<T extends SubCategory$ProductArgs<ExtArgs> = {}>(args?: Subset<T, SubCategory$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubCategory model
   */ 
  interface SubCategoryFieldRefs {
    readonly id: FieldRef<"SubCategory", 'String'>
    readonly name: FieldRef<"SubCategory", 'String'>
    readonly slug: FieldRef<"SubCategory", 'String'>
    readonly categoryId: FieldRef<"SubCategory", 'String'>
    readonly imageUrl: FieldRef<"SubCategory", 'String'>
    readonly seoTitle: FieldRef<"SubCategory", 'String'>
    readonly seoDescription: FieldRef<"SubCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubCategory findUnique
   */
  export type SubCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findUniqueOrThrow
   */
  export type SubCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findFirst
   */
  export type SubCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findFirstOrThrow
   */
  export type SubCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findMany
   */
  export type SubCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategories to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory create
   */
  export type SubCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SubCategory.
     */
    data: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
  }

  /**
   * SubCategory createMany
   */
  export type SubCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubCategories.
     */
    data: SubCategoryCreateManyInput | SubCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubCategory update
   */
  export type SubCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SubCategory.
     */
    data: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
    /**
     * Choose, which SubCategory to update.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory updateMany
   */
  export type SubCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubCategories.
     */
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SubCategories to update
     */
    where?: SubCategoryWhereInput
    /**
     * Limit how many SubCategories to update.
     */
    limit?: number
  }

  /**
   * SubCategory upsert
   */
  export type SubCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SubCategory to update in case it exists.
     */
    where: SubCategoryWhereUniqueInput
    /**
     * In case the SubCategory found by the `where` argument doesn't exist, create a new SubCategory with this data.
     */
    create: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
    /**
     * In case the SubCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
  }

  /**
   * SubCategory delete
   */
  export type SubCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter which SubCategory to delete.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory deleteMany
   */
  export type SubCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategories to delete
     */
    where?: SubCategoryWhereInput
    /**
     * Limit how many SubCategories to delete.
     */
    limit?: number
  }

  /**
   * SubCategory.Product
   */
  export type SubCategory$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * SubCategory without action
   */
  export type SubCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubCategory
     */
    omit?: SubCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subject: string | null
    message: string | null
    status: $Enums.SupportTicket_status | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subject: string | null
    message: string | null
    status: $Enums.SupportTicket_status | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    userId: number
    subject: number
    message: number
    status: number
    createdAt: number
    resolvedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    message?: true
    status?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    message?: true
    status?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    message?: true
    status?: true
    createdAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    userId: string
    subject: string
    message: string
    status: $Enums.SupportTicket_status
    createdAt: Date
    resolvedAt: Date | null
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>



  export type SupportTicketSelectScalar = {
    id?: boolean
    userId?: boolean
    subject?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
  }

  export type SupportTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "subject" | "message" | "status" | "createdAt" | "resolvedAt", ExtArgs["result"]["supportTicket"]>
  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subject: string
      message: string
      status: $Enums.SupportTicket_status
      createdAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */ 
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly message: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'SupportTicket_status'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly resolvedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to delete.
     */
    limit?: number
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model Tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsMinAggregateOutputType = {
    id: string | null
    tag: string | null
  }

  export type TagsMaxAggregateOutputType = {
    id: string | null
    tag: string | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    tag: number
    _all: number
  }


  export type TagsMinAggregateInputType = {
    id?: true
    tag?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    tag?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    tag?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to aggregate.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type TagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithAggregationInput | TagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: TagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: string
    tag: string
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends TagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type TagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
  }, ExtArgs["result"]["tags"]>



  export type TagsSelectScalar = {
    id?: boolean
    tag?: boolean
  }

  export type TagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag", ExtArgs["result"]["tags"]>

  export type $TagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tags"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag: string
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type TagsGetPayload<S extends boolean | null | undefined | TagsDefaultArgs> = $Result.GetResult<Prisma.$TagsPayload, S>

  type TagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface TagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tags'], meta: { name: 'Tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {TagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagsFindUniqueArgs>(args: SelectSubset<T, TagsFindUniqueArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagsFindUniqueOrThrowArgs>(args: SelectSubset<T, TagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagsFindFirstArgs>(args?: SelectSubset<T, TagsFindFirstArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagsFindFirstOrThrowArgs>(args?: SelectSubset<T, TagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagsFindManyArgs>(args?: SelectSubset<T, TagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {TagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends TagsCreateArgs>(args: SelectSubset<T, TagsCreateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagsCreateManyArgs>(args?: SelectSubset<T, TagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tags.
     * @param {TagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends TagsDeleteArgs>(args: SelectSubset<T, TagsDeleteArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {TagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagsUpdateArgs>(args: SelectSubset<T, TagsUpdateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagsDeleteManyArgs>(args?: SelectSubset<T, TagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagsUpdateManyArgs>(args: SelectSubset<T, TagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tags.
     * @param {TagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends TagsUpsertArgs>(args: SelectSubset<T, TagsUpsertArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagsCountArgs>(
      args?: Subset<T, TagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsGroupByArgs['orderBy'] }
        : { orderBy?: TagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tags model
   */
  readonly fields: TagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tags model
   */ 
  interface TagsFieldRefs {
    readonly id: FieldRef<"Tags", 'String'>
    readonly tag: FieldRef<"Tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tags findUnique
   */
  export type TagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findUniqueOrThrow
   */
  export type TagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findFirst
   */
  export type TagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findFirstOrThrow
   */
  export type TagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findMany
   */
  export type TagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags create
   */
  export type TagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * The data needed to create a Tags.
     */
    data: XOR<TagsCreateInput, TagsUncheckedCreateInput>
  }

  /**
   * Tags createMany
   */
  export type TagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tags update
   */
  export type TagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * The data needed to update a Tags.
     */
    data: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
    /**
     * Choose, which Tags to update.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags updateMany
   */
  export type TagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tags upsert
   */
  export type TagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * The filter to search for the Tags to update in case it exists.
     */
    where: TagsWhereUniqueInput
    /**
     * In case the Tags found by the `where` argument doesn't exist, create a new Tags with this data.
     */
    create: XOR<TagsCreateInput, TagsUncheckedCreateInput>
    /**
     * In case the Tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
  }

  /**
   * Tags delete
   */
  export type TagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Filter which Tags to delete.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags deleteMany
   */
  export type TagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tags without action
   */
  export type TagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
  }


  /**
   * Model Trending
   */

  export type AggregateTrending = {
    _count: TrendingCountAggregateOutputType | null
    _min: TrendingMinAggregateOutputType | null
    _max: TrendingMaxAggregateOutputType | null
  }

  export type TrendingMinAggregateOutputType = {
    id: string | null
    videoUrl: string | null
    title: string | null
    price: string | null
    hyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    avatarUrl: string | null
  }

  export type TrendingMaxAggregateOutputType = {
    id: string | null
    videoUrl: string | null
    title: string | null
    price: string | null
    hyperLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
    avatarUrl: string | null
  }

  export type TrendingCountAggregateOutputType = {
    id: number
    videoUrl: number
    title: number
    price: number
    hyperLink: number
    createdAt: number
    updatedAt: number
    avatarUrl: number
    _all: number
  }


  export type TrendingMinAggregateInputType = {
    id?: true
    videoUrl?: true
    title?: true
    price?: true
    hyperLink?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
  }

  export type TrendingMaxAggregateInputType = {
    id?: true
    videoUrl?: true
    title?: true
    price?: true
    hyperLink?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
  }

  export type TrendingCountAggregateInputType = {
    id?: true
    videoUrl?: true
    title?: true
    price?: true
    hyperLink?: true
    createdAt?: true
    updatedAt?: true
    avatarUrl?: true
    _all?: true
  }

  export type TrendingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trending to aggregate.
     */
    where?: TrendingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trendings to fetch.
     */
    orderBy?: TrendingOrderByWithRelationInput | TrendingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrendingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trendings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trendings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trendings
    **/
    _count?: true | TrendingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrendingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrendingMaxAggregateInputType
  }

  export type GetTrendingAggregateType<T extends TrendingAggregateArgs> = {
        [P in keyof T & keyof AggregateTrending]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrending[P]>
      : GetScalarType<T[P], AggregateTrending[P]>
  }




  export type TrendingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrendingWhereInput
    orderBy?: TrendingOrderByWithAggregationInput | TrendingOrderByWithAggregationInput[]
    by: TrendingScalarFieldEnum[] | TrendingScalarFieldEnum
    having?: TrendingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrendingCountAggregateInputType | true
    _min?: TrendingMinAggregateInputType
    _max?: TrendingMaxAggregateInputType
  }

  export type TrendingGroupByOutputType = {
    id: string
    videoUrl: string | null
    title: string | null
    price: string | null
    hyperLink: string | null
    createdAt: Date
    updatedAt: Date
    avatarUrl: string | null
    _count: TrendingCountAggregateOutputType | null
    _min: TrendingMinAggregateOutputType | null
    _max: TrendingMaxAggregateOutputType | null
  }

  type GetTrendingGroupByPayload<T extends TrendingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrendingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrendingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrendingGroupByOutputType[P]>
            : GetScalarType<T[P], TrendingGroupByOutputType[P]>
        }
      >
    >


  export type TrendingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoUrl?: boolean
    title?: boolean
    price?: boolean
    hyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
  }, ExtArgs["result"]["trending"]>



  export type TrendingSelectScalar = {
    id?: boolean
    videoUrl?: boolean
    title?: boolean
    price?: boolean
    hyperLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarUrl?: boolean
  }

  export type TrendingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "videoUrl" | "title" | "price" | "hyperLink" | "createdAt" | "updatedAt" | "avatarUrl", ExtArgs["result"]["trending"]>

  export type $TrendingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trending"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoUrl: string | null
      title: string | null
      price: string | null
      hyperLink: string | null
      createdAt: Date
      updatedAt: Date
      avatarUrl: string | null
    }, ExtArgs["result"]["trending"]>
    composites: {}
  }

  type TrendingGetPayload<S extends boolean | null | undefined | TrendingDefaultArgs> = $Result.GetResult<Prisma.$TrendingPayload, S>

  type TrendingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrendingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrendingCountAggregateInputType | true
    }

  export interface TrendingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trending'], meta: { name: 'Trending' } }
    /**
     * Find zero or one Trending that matches the filter.
     * @param {TrendingFindUniqueArgs} args - Arguments to find a Trending
     * @example
     * // Get one Trending
     * const trending = await prisma.trending.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrendingFindUniqueArgs>(args: SelectSubset<T, TrendingFindUniqueArgs<ExtArgs>>): Prisma__TrendingClient<$Result.GetResult<Prisma.$TrendingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trending that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrendingFindUniqueOrThrowArgs} args - Arguments to find a Trending
     * @example
     * // Get one Trending
     * const trending = await prisma.trending.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrendingFindUniqueOrThrowArgs>(args: SelectSubset<T, TrendingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrendingClient<$Result.GetResult<Prisma.$TrendingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trending that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingFindFirstArgs} args - Arguments to find a Trending
     * @example
     * // Get one Trending
     * const trending = await prisma.trending.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrendingFindFirstArgs>(args?: SelectSubset<T, TrendingFindFirstArgs<ExtArgs>>): Prisma__TrendingClient<$Result.GetResult<Prisma.$TrendingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trending that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingFindFirstOrThrowArgs} args - Arguments to find a Trending
     * @example
     * // Get one Trending
     * const trending = await prisma.trending.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrendingFindFirstOrThrowArgs>(args?: SelectSubset<T, TrendingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrendingClient<$Result.GetResult<Prisma.$TrendingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trendings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trendings
     * const trendings = await prisma.trending.findMany()
     * 
     * // Get first 10 Trendings
     * const trendings = await prisma.trending.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trendingWithIdOnly = await prisma.trending.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrendingFindManyArgs>(args?: SelectSubset<T, TrendingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrendingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trending.
     * @param {TrendingCreateArgs} args - Arguments to create a Trending.
     * @example
     * // Create one Trending
     * const Trending = await prisma.trending.create({
     *   data: {
     *     // ... data to create a Trending
     *   }
     * })
     * 
     */
    create<T extends TrendingCreateArgs>(args: SelectSubset<T, TrendingCreateArgs<ExtArgs>>): Prisma__TrendingClient<$Result.GetResult<Prisma.$TrendingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trendings.
     * @param {TrendingCreateManyArgs} args - Arguments to create many Trendings.
     * @example
     * // Create many Trendings
     * const trending = await prisma.trending.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrendingCreateManyArgs>(args?: SelectSubset<T, TrendingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trending.
     * @param {TrendingDeleteArgs} args - Arguments to delete one Trending.
     * @example
     * // Delete one Trending
     * const Trending = await prisma.trending.delete({
     *   where: {
     *     // ... filter to delete one Trending
     *   }
     * })
     * 
     */
    delete<T extends TrendingDeleteArgs>(args: SelectSubset<T, TrendingDeleteArgs<ExtArgs>>): Prisma__TrendingClient<$Result.GetResult<Prisma.$TrendingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trending.
     * @param {TrendingUpdateArgs} args - Arguments to update one Trending.
     * @example
     * // Update one Trending
     * const trending = await prisma.trending.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrendingUpdateArgs>(args: SelectSubset<T, TrendingUpdateArgs<ExtArgs>>): Prisma__TrendingClient<$Result.GetResult<Prisma.$TrendingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trendings.
     * @param {TrendingDeleteManyArgs} args - Arguments to filter Trendings to delete.
     * @example
     * // Delete a few Trendings
     * const { count } = await prisma.trending.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrendingDeleteManyArgs>(args?: SelectSubset<T, TrendingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trendings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trendings
     * const trending = await prisma.trending.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrendingUpdateManyArgs>(args: SelectSubset<T, TrendingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trending.
     * @param {TrendingUpsertArgs} args - Arguments to update or create a Trending.
     * @example
     * // Update or create a Trending
     * const trending = await prisma.trending.upsert({
     *   create: {
     *     // ... data to create a Trending
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trending we want to update
     *   }
     * })
     */
    upsert<T extends TrendingUpsertArgs>(args: SelectSubset<T, TrendingUpsertArgs<ExtArgs>>): Prisma__TrendingClient<$Result.GetResult<Prisma.$TrendingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trendings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingCountArgs} args - Arguments to filter Trendings to count.
     * @example
     * // Count the number of Trendings
     * const count = await prisma.trending.count({
     *   where: {
     *     // ... the filter for the Trendings we want to count
     *   }
     * })
    **/
    count<T extends TrendingCountArgs>(
      args?: Subset<T, TrendingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrendingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trending.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrendingAggregateArgs>(args: Subset<T, TrendingAggregateArgs>): Prisma.PrismaPromise<GetTrendingAggregateType<T>>

    /**
     * Group by Trending.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrendingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrendingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrendingGroupByArgs['orderBy'] }
        : { orderBy?: TrendingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrendingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrendingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trending model
   */
  readonly fields: TrendingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trending.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrendingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trending model
   */ 
  interface TrendingFieldRefs {
    readonly id: FieldRef<"Trending", 'String'>
    readonly videoUrl: FieldRef<"Trending", 'String'>
    readonly title: FieldRef<"Trending", 'String'>
    readonly price: FieldRef<"Trending", 'String'>
    readonly hyperLink: FieldRef<"Trending", 'String'>
    readonly createdAt: FieldRef<"Trending", 'DateTime'>
    readonly updatedAt: FieldRef<"Trending", 'DateTime'>
    readonly avatarUrl: FieldRef<"Trending", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trending findUnique
   */
  export type TrendingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
    /**
     * Filter, which Trending to fetch.
     */
    where: TrendingWhereUniqueInput
  }

  /**
   * Trending findUniqueOrThrow
   */
  export type TrendingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
    /**
     * Filter, which Trending to fetch.
     */
    where: TrendingWhereUniqueInput
  }

  /**
   * Trending findFirst
   */
  export type TrendingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
    /**
     * Filter, which Trending to fetch.
     */
    where?: TrendingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trendings to fetch.
     */
    orderBy?: TrendingOrderByWithRelationInput | TrendingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trendings.
     */
    cursor?: TrendingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trendings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trendings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trendings.
     */
    distinct?: TrendingScalarFieldEnum | TrendingScalarFieldEnum[]
  }

  /**
   * Trending findFirstOrThrow
   */
  export type TrendingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
    /**
     * Filter, which Trending to fetch.
     */
    where?: TrendingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trendings to fetch.
     */
    orderBy?: TrendingOrderByWithRelationInput | TrendingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trendings.
     */
    cursor?: TrendingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trendings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trendings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trendings.
     */
    distinct?: TrendingScalarFieldEnum | TrendingScalarFieldEnum[]
  }

  /**
   * Trending findMany
   */
  export type TrendingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
    /**
     * Filter, which Trendings to fetch.
     */
    where?: TrendingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trendings to fetch.
     */
    orderBy?: TrendingOrderByWithRelationInput | TrendingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trendings.
     */
    cursor?: TrendingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trendings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trendings.
     */
    skip?: number
    distinct?: TrendingScalarFieldEnum | TrendingScalarFieldEnum[]
  }

  /**
   * Trending create
   */
  export type TrendingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
    /**
     * The data needed to create a Trending.
     */
    data: XOR<TrendingCreateInput, TrendingUncheckedCreateInput>
  }

  /**
   * Trending createMany
   */
  export type TrendingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trendings.
     */
    data: TrendingCreateManyInput | TrendingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trending update
   */
  export type TrendingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
    /**
     * The data needed to update a Trending.
     */
    data: XOR<TrendingUpdateInput, TrendingUncheckedUpdateInput>
    /**
     * Choose, which Trending to update.
     */
    where: TrendingWhereUniqueInput
  }

  /**
   * Trending updateMany
   */
  export type TrendingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trendings.
     */
    data: XOR<TrendingUpdateManyMutationInput, TrendingUncheckedUpdateManyInput>
    /**
     * Filter which Trendings to update
     */
    where?: TrendingWhereInput
    /**
     * Limit how many Trendings to update.
     */
    limit?: number
  }

  /**
   * Trending upsert
   */
  export type TrendingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
    /**
     * The filter to search for the Trending to update in case it exists.
     */
    where: TrendingWhereUniqueInput
    /**
     * In case the Trending found by the `where` argument doesn't exist, create a new Trending with this data.
     */
    create: XOR<TrendingCreateInput, TrendingUncheckedCreateInput>
    /**
     * In case the Trending was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrendingUpdateInput, TrendingUncheckedUpdateInput>
  }

  /**
   * Trending delete
   */
  export type TrendingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
    /**
     * Filter which Trending to delete.
     */
    where: TrendingWhereUniqueInput
  }

  /**
   * Trending deleteMany
   */
  export type TrendingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trendings to delete
     */
    where?: TrendingWhereInput
    /**
     * Limit how many Trendings to delete.
     */
    limit?: number
  }

  /**
   * Trending without action
   */
  export type TrendingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trending
     */
    select?: TrendingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trending
     */
    omit?: TrendingOmit<ExtArgs> | null
  }


  /**
   * Model UpdateHistory
   */

  export type AggregateUpdateHistory = {
    _count: UpdateHistoryCountAggregateOutputType | null
    _min: UpdateHistoryMinAggregateOutputType | null
    _max: UpdateHistoryMaxAggregateOutputType | null
  }

  export type UpdateHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
  }

  export type UpdateHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
  }

  export type UpdateHistoryCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    createdAt: number
    _all: number
  }


  export type UpdateHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    createdAt?: true
  }

  export type UpdateHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    createdAt?: true
  }

  export type UpdateHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type UpdateHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpdateHistory to aggregate.
     */
    where?: UpdateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdateHistories to fetch.
     */
    orderBy?: UpdateHistoryOrderByWithRelationInput | UpdateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UpdateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdateHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UpdateHistories
    **/
    _count?: true | UpdateHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UpdateHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UpdateHistoryMaxAggregateInputType
  }

  export type GetUpdateHistoryAggregateType<T extends UpdateHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUpdateHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpdateHistory[P]>
      : GetScalarType<T[P], AggregateUpdateHistory[P]>
  }




  export type UpdateHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdateHistoryWhereInput
    orderBy?: UpdateHistoryOrderByWithAggregationInput | UpdateHistoryOrderByWithAggregationInput[]
    by: UpdateHistoryScalarFieldEnum[] | UpdateHistoryScalarFieldEnum
    having?: UpdateHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UpdateHistoryCountAggregateInputType | true
    _min?: UpdateHistoryMinAggregateInputType
    _max?: UpdateHistoryMaxAggregateInputType
  }

  export type UpdateHistoryGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string
    createdAt: Date
    _count: UpdateHistoryCountAggregateOutputType | null
    _min: UpdateHistoryMinAggregateOutputType | null
    _max: UpdateHistoryMaxAggregateOutputType | null
  }

  type GetUpdateHistoryGroupByPayload<T extends UpdateHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UpdateHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UpdateHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UpdateHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UpdateHistoryGroupByOutputType[P]>
        }
      >
    >


  export type UpdateHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["updateHistory"]>



  export type UpdateHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type UpdateHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "createdAt", ExtArgs["result"]["updateHistory"]>
  export type UpdateHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UpdateHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UpdateHistory"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string
      createdAt: Date
    }, ExtArgs["result"]["updateHistory"]>
    composites: {}
  }

  type UpdateHistoryGetPayload<S extends boolean | null | undefined | UpdateHistoryDefaultArgs> = $Result.GetResult<Prisma.$UpdateHistoryPayload, S>

  type UpdateHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UpdateHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UpdateHistoryCountAggregateInputType | true
    }

  export interface UpdateHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UpdateHistory'], meta: { name: 'UpdateHistory' } }
    /**
     * Find zero or one UpdateHistory that matches the filter.
     * @param {UpdateHistoryFindUniqueArgs} args - Arguments to find a UpdateHistory
     * @example
     * // Get one UpdateHistory
     * const updateHistory = await prisma.updateHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UpdateHistoryFindUniqueArgs>(args: SelectSubset<T, UpdateHistoryFindUniqueArgs<ExtArgs>>): Prisma__UpdateHistoryClient<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UpdateHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UpdateHistoryFindUniqueOrThrowArgs} args - Arguments to find a UpdateHistory
     * @example
     * // Get one UpdateHistory
     * const updateHistory = await prisma.updateHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UpdateHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UpdateHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UpdateHistoryClient<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UpdateHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateHistoryFindFirstArgs} args - Arguments to find a UpdateHistory
     * @example
     * // Get one UpdateHistory
     * const updateHistory = await prisma.updateHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UpdateHistoryFindFirstArgs>(args?: SelectSubset<T, UpdateHistoryFindFirstArgs<ExtArgs>>): Prisma__UpdateHistoryClient<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UpdateHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateHistoryFindFirstOrThrowArgs} args - Arguments to find a UpdateHistory
     * @example
     * // Get one UpdateHistory
     * const updateHistory = await prisma.updateHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UpdateHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UpdateHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UpdateHistoryClient<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UpdateHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UpdateHistories
     * const updateHistories = await prisma.updateHistory.findMany()
     * 
     * // Get first 10 UpdateHistories
     * const updateHistories = await prisma.updateHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const updateHistoryWithIdOnly = await prisma.updateHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UpdateHistoryFindManyArgs>(args?: SelectSubset<T, UpdateHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UpdateHistory.
     * @param {UpdateHistoryCreateArgs} args - Arguments to create a UpdateHistory.
     * @example
     * // Create one UpdateHistory
     * const UpdateHistory = await prisma.updateHistory.create({
     *   data: {
     *     // ... data to create a UpdateHistory
     *   }
     * })
     * 
     */
    create<T extends UpdateHistoryCreateArgs>(args: SelectSubset<T, UpdateHistoryCreateArgs<ExtArgs>>): Prisma__UpdateHistoryClient<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UpdateHistories.
     * @param {UpdateHistoryCreateManyArgs} args - Arguments to create many UpdateHistories.
     * @example
     * // Create many UpdateHistories
     * const updateHistory = await prisma.updateHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UpdateHistoryCreateManyArgs>(args?: SelectSubset<T, UpdateHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UpdateHistory.
     * @param {UpdateHistoryDeleteArgs} args - Arguments to delete one UpdateHistory.
     * @example
     * // Delete one UpdateHistory
     * const UpdateHistory = await prisma.updateHistory.delete({
     *   where: {
     *     // ... filter to delete one UpdateHistory
     *   }
     * })
     * 
     */
    delete<T extends UpdateHistoryDeleteArgs>(args: SelectSubset<T, UpdateHistoryDeleteArgs<ExtArgs>>): Prisma__UpdateHistoryClient<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UpdateHistory.
     * @param {UpdateHistoryUpdateArgs} args - Arguments to update one UpdateHistory.
     * @example
     * // Update one UpdateHistory
     * const updateHistory = await prisma.updateHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UpdateHistoryUpdateArgs>(args: SelectSubset<T, UpdateHistoryUpdateArgs<ExtArgs>>): Prisma__UpdateHistoryClient<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UpdateHistories.
     * @param {UpdateHistoryDeleteManyArgs} args - Arguments to filter UpdateHistories to delete.
     * @example
     * // Delete a few UpdateHistories
     * const { count } = await prisma.updateHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UpdateHistoryDeleteManyArgs>(args?: SelectSubset<T, UpdateHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UpdateHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UpdateHistories
     * const updateHistory = await prisma.updateHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UpdateHistoryUpdateManyArgs>(args: SelectSubset<T, UpdateHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UpdateHistory.
     * @param {UpdateHistoryUpsertArgs} args - Arguments to update or create a UpdateHistory.
     * @example
     * // Update or create a UpdateHistory
     * const updateHistory = await prisma.updateHistory.upsert({
     *   create: {
     *     // ... data to create a UpdateHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UpdateHistory we want to update
     *   }
     * })
     */
    upsert<T extends UpdateHistoryUpsertArgs>(args: SelectSubset<T, UpdateHistoryUpsertArgs<ExtArgs>>): Prisma__UpdateHistoryClient<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UpdateHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateHistoryCountArgs} args - Arguments to filter UpdateHistories to count.
     * @example
     * // Count the number of UpdateHistories
     * const count = await prisma.updateHistory.count({
     *   where: {
     *     // ... the filter for the UpdateHistories we want to count
     *   }
     * })
    **/
    count<T extends UpdateHistoryCountArgs>(
      args?: Subset<T, UpdateHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UpdateHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UpdateHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UpdateHistoryAggregateArgs>(args: Subset<T, UpdateHistoryAggregateArgs>): Prisma.PrismaPromise<GetUpdateHistoryAggregateType<T>>

    /**
     * Group by UpdateHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UpdateHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UpdateHistoryGroupByArgs['orderBy'] }
        : { orderBy?: UpdateHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UpdateHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpdateHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UpdateHistory model
   */
  readonly fields: UpdateHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UpdateHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UpdateHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UpdateHistory model
   */ 
  interface UpdateHistoryFieldRefs {
    readonly id: FieldRef<"UpdateHistory", 'String'>
    readonly userId: FieldRef<"UpdateHistory", 'String'>
    readonly title: FieldRef<"UpdateHistory", 'String'>
    readonly description: FieldRef<"UpdateHistory", 'String'>
    readonly createdAt: FieldRef<"UpdateHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UpdateHistory findUnique
   */
  export type UpdateHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UpdateHistory to fetch.
     */
    where: UpdateHistoryWhereUniqueInput
  }

  /**
   * UpdateHistory findUniqueOrThrow
   */
  export type UpdateHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UpdateHistory to fetch.
     */
    where: UpdateHistoryWhereUniqueInput
  }

  /**
   * UpdateHistory findFirst
   */
  export type UpdateHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UpdateHistory to fetch.
     */
    where?: UpdateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdateHistories to fetch.
     */
    orderBy?: UpdateHistoryOrderByWithRelationInput | UpdateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpdateHistories.
     */
    cursor?: UpdateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdateHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpdateHistories.
     */
    distinct?: UpdateHistoryScalarFieldEnum | UpdateHistoryScalarFieldEnum[]
  }

  /**
   * UpdateHistory findFirstOrThrow
   */
  export type UpdateHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UpdateHistory to fetch.
     */
    where?: UpdateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdateHistories to fetch.
     */
    orderBy?: UpdateHistoryOrderByWithRelationInput | UpdateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpdateHistories.
     */
    cursor?: UpdateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdateHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpdateHistories.
     */
    distinct?: UpdateHistoryScalarFieldEnum | UpdateHistoryScalarFieldEnum[]
  }

  /**
   * UpdateHistory findMany
   */
  export type UpdateHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which UpdateHistories to fetch.
     */
    where?: UpdateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdateHistories to fetch.
     */
    orderBy?: UpdateHistoryOrderByWithRelationInput | UpdateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UpdateHistories.
     */
    cursor?: UpdateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdateHistories.
     */
    skip?: number
    distinct?: UpdateHistoryScalarFieldEnum | UpdateHistoryScalarFieldEnum[]
  }

  /**
   * UpdateHistory create
   */
  export type UpdateHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UpdateHistory.
     */
    data: XOR<UpdateHistoryCreateInput, UpdateHistoryUncheckedCreateInput>
  }

  /**
   * UpdateHistory createMany
   */
  export type UpdateHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UpdateHistories.
     */
    data: UpdateHistoryCreateManyInput | UpdateHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UpdateHistory update
   */
  export type UpdateHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UpdateHistory.
     */
    data: XOR<UpdateHistoryUpdateInput, UpdateHistoryUncheckedUpdateInput>
    /**
     * Choose, which UpdateHistory to update.
     */
    where: UpdateHistoryWhereUniqueInput
  }

  /**
   * UpdateHistory updateMany
   */
  export type UpdateHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UpdateHistories.
     */
    data: XOR<UpdateHistoryUpdateManyMutationInput, UpdateHistoryUncheckedUpdateManyInput>
    /**
     * Filter which UpdateHistories to update
     */
    where?: UpdateHistoryWhereInput
    /**
     * Limit how many UpdateHistories to update.
     */
    limit?: number
  }

  /**
   * UpdateHistory upsert
   */
  export type UpdateHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UpdateHistory to update in case it exists.
     */
    where: UpdateHistoryWhereUniqueInput
    /**
     * In case the UpdateHistory found by the `where` argument doesn't exist, create a new UpdateHistory with this data.
     */
    create: XOR<UpdateHistoryCreateInput, UpdateHistoryUncheckedCreateInput>
    /**
     * In case the UpdateHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UpdateHistoryUpdateInput, UpdateHistoryUncheckedUpdateInput>
  }

  /**
   * UpdateHistory delete
   */
  export type UpdateHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    /**
     * Filter which UpdateHistory to delete.
     */
    where: UpdateHistoryWhereUniqueInput
  }

  /**
   * UpdateHistory deleteMany
   */
  export type UpdateHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpdateHistories to delete
     */
    where?: UpdateHistoryWhereInput
    /**
     * Limit how many UpdateHistories to delete.
     */
    limit?: number
  }

  /**
   * UpdateHistory without action
   */
  export type UpdateHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isVerified: boolean | null
    role: $Enums.User_role | null
    firstName: string | null
    lastName: string | null
    status: $Enums.User_status | null
    profileUrl: string | null
    mobileNumber: string | null
    whatsAppNumber: string | null
    isLoggedIn: boolean | null
    isViewed: boolean | null
    is2FA: boolean | null
    assignedStaffId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isVerified: boolean | null
    role: $Enums.User_role | null
    firstName: string | null
    lastName: string | null
    status: $Enums.User_status | null
    profileUrl: string | null
    mobileNumber: string | null
    whatsAppNumber: string | null
    isLoggedIn: boolean | null
    isViewed: boolean | null
    is2FA: boolean | null
    assignedStaffId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    isVerified: number
    role: number
    firstName: number
    lastName: number
    status: number
    profileUrl: number
    mobileNumber: number
    whatsAppNumber: number
    isLoggedIn: number
    isViewed: number
    is2FA: number
    assignedStaffId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    isVerified?: true
    role?: true
    firstName?: true
    lastName?: true
    status?: true
    profileUrl?: true
    mobileNumber?: true
    whatsAppNumber?: true
    isLoggedIn?: true
    isViewed?: true
    is2FA?: true
    assignedStaffId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    isVerified?: true
    role?: true
    firstName?: true
    lastName?: true
    status?: true
    profileUrl?: true
    mobileNumber?: true
    whatsAppNumber?: true
    isLoggedIn?: true
    isViewed?: true
    is2FA?: true
    assignedStaffId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    isVerified?: true
    role?: true
    firstName?: true
    lastName?: true
    status?: true
    profileUrl?: true
    mobileNumber?: true
    whatsAppNumber?: true
    isLoggedIn?: true
    isViewed?: true
    is2FA?: true
    assignedStaffId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    createdAt: Date
    updatedAt: Date
    isVerified: boolean
    role: $Enums.User_role
    firstName: string | null
    lastName: string | null
    status: $Enums.User_status
    profileUrl: string | null
    mobileNumber: string | null
    whatsAppNumber: string | null
    isLoggedIn: boolean
    isViewed: boolean
    is2FA: boolean
    assignedStaffId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isVerified?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    status?: boolean
    profileUrl?: boolean
    mobileNumber?: boolean
    whatsAppNumber?: boolean
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: boolean
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    CartItem?: boolean | User$CartItemArgs<ExtArgs>
    DeleteRequest?: boolean | User$DeleteRequestArgs<ExtArgs>
    DropMessage?: boolean | User$DropMessageArgs<ExtArgs>
    Message_Message_handledByIdToUser?: boolean | User$Message_Message_handledByIdToUserArgs<ExtArgs>
    Message_Message_receiverIdToUser?: boolean | User$Message_Message_receiverIdToUserArgs<ExtArgs>
    Message_Message_senderIdToUser?: boolean | User$Message_Message_senderIdToUserArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    OrderDetails?: boolean | User$OrderDetailsArgs<ExtArgs>
    Otp?: boolean | User$OtpArgs<ExtArgs>
    Product?: boolean | User$ProductArgs<ExtArgs>
    ProductReview?: boolean | User$ProductReviewArgs<ExtArgs>
    Rewards?: boolean | User$RewardsArgs<ExtArgs>
    SearchQuery?: boolean | User$SearchQueryArgs<ExtArgs>
    Session?: boolean | User$SessionArgs<ExtArgs>
    StaticMessages?: boolean | User$StaticMessagesArgs<ExtArgs>
    SupportTicket?: boolean | User$SupportTicketArgs<ExtArgs>
    UpdateHistory?: boolean | User$UpdateHistoryArgs<ExtArgs>
    User?: boolean | User$UserArgs<ExtArgs>
    other_User?: boolean | User$other_UserArgs<ExtArgs>
    UserAddress?: boolean | User$UserAddressArgs<ExtArgs>
    UserPrivilege?: boolean | User$UserPrivilegeArgs<ExtArgs>
    WishlistItem?: boolean | User$WishlistItemArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isVerified?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    status?: boolean
    profileUrl?: boolean
    mobileNumber?: boolean
    whatsAppNumber?: boolean
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "createdAt" | "updatedAt" | "isVerified" | "role" | "firstName" | "lastName" | "status" | "profileUrl" | "mobileNumber" | "whatsAppNumber" | "isLoggedIn" | "isViewed" | "is2FA" | "assignedStaffId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    CartItem?: boolean | User$CartItemArgs<ExtArgs>
    DeleteRequest?: boolean | User$DeleteRequestArgs<ExtArgs>
    DropMessage?: boolean | User$DropMessageArgs<ExtArgs>
    Message_Message_handledByIdToUser?: boolean | User$Message_Message_handledByIdToUserArgs<ExtArgs>
    Message_Message_receiverIdToUser?: boolean | User$Message_Message_receiverIdToUserArgs<ExtArgs>
    Message_Message_senderIdToUser?: boolean | User$Message_Message_senderIdToUserArgs<ExtArgs>
    Notification?: boolean | User$NotificationArgs<ExtArgs>
    OrderDetails?: boolean | User$OrderDetailsArgs<ExtArgs>
    Otp?: boolean | User$OtpArgs<ExtArgs>
    Product?: boolean | User$ProductArgs<ExtArgs>
    ProductReview?: boolean | User$ProductReviewArgs<ExtArgs>
    Rewards?: boolean | User$RewardsArgs<ExtArgs>
    SearchQuery?: boolean | User$SearchQueryArgs<ExtArgs>
    Session?: boolean | User$SessionArgs<ExtArgs>
    StaticMessages?: boolean | User$StaticMessagesArgs<ExtArgs>
    SupportTicket?: boolean | User$SupportTicketArgs<ExtArgs>
    UpdateHistory?: boolean | User$UpdateHistoryArgs<ExtArgs>
    User?: boolean | User$UserArgs<ExtArgs>
    other_User?: boolean | User$other_UserArgs<ExtArgs>
    UserAddress?: boolean | User$UserAddressArgs<ExtArgs>
    UserPrivilege?: boolean | User$UserPrivilegeArgs<ExtArgs>
    WishlistItem?: boolean | User$WishlistItemArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[]
      CartItem: Prisma.$CartItemPayload<ExtArgs>[]
      DeleteRequest: Prisma.$DeleteRequestPayload<ExtArgs>[]
      DropMessage: Prisma.$DropMessagePayload<ExtArgs>[]
      Message_Message_handledByIdToUser: Prisma.$MessagePayload<ExtArgs>[]
      Message_Message_receiverIdToUser: Prisma.$MessagePayload<ExtArgs>[]
      Message_Message_senderIdToUser: Prisma.$MessagePayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      OrderDetails: Prisma.$OrderDetailsPayload<ExtArgs>[]
      Otp: Prisma.$OtpPayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>[]
      ProductReview: Prisma.$ProductReviewPayload<ExtArgs>[]
      Rewards: Prisma.$RewardsPayload<ExtArgs>[]
      SearchQuery: Prisma.$SearchQueryPayload<ExtArgs>[]
      Session: Prisma.$SessionPayload<ExtArgs>[]
      StaticMessages: Prisma.$StaticMessagesPayload<ExtArgs>[]
      SupportTicket: Prisma.$SupportTicketPayload<ExtArgs>[]
      UpdateHistory: Prisma.$UpdateHistoryPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
      other_User: Prisma.$UserPayload<ExtArgs>[]
      UserAddress: Prisma.$UserAddressPayload<ExtArgs>[]
      UserPrivilege: Prisma.$UserPrivilegePayload<ExtArgs>[]
      WishlistItem: Prisma.$WishlistItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      createdAt: Date
      updatedAt: Date
      isVerified: boolean
      role: $Enums.User_role
      firstName: string | null
      lastName: string | null
      status: $Enums.User_status
      profileUrl: string | null
      mobileNumber: string | null
      whatsAppNumber: string | null
      isLoggedIn: boolean
      isViewed: boolean
      is2FA: boolean
      assignedStaffId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AuditLog<T extends User$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, User$AuditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CartItem<T extends User$CartItemArgs<ExtArgs> = {}>(args?: Subset<T, User$CartItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DeleteRequest<T extends User$DeleteRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$DeleteRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeleteRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DropMessage<T extends User$DropMessageArgs<ExtArgs> = {}>(args?: Subset<T, User$DropMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Message_Message_handledByIdToUser<T extends User$Message_Message_handledByIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Message_Message_handledByIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Message_Message_receiverIdToUser<T extends User$Message_Message_receiverIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Message_Message_receiverIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Message_Message_senderIdToUser<T extends User$Message_Message_senderIdToUserArgs<ExtArgs> = {}>(args?: Subset<T, User$Message_Message_senderIdToUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends User$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OrderDetails<T extends User$OrderDetailsArgs<ExtArgs> = {}>(args?: Subset<T, User$OrderDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Otp<T extends User$OtpArgs<ExtArgs> = {}>(args?: Subset<T, User$OtpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Product<T extends User$ProductArgs<ExtArgs> = {}>(args?: Subset<T, User$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductReview<T extends User$ProductReviewArgs<ExtArgs> = {}>(args?: Subset<T, User$ProductReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Rewards<T extends User$RewardsArgs<ExtArgs> = {}>(args?: Subset<T, User$RewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SearchQuery<T extends User$SearchQueryArgs<ExtArgs> = {}>(args?: Subset<T, User$SearchQueryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchQueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Session<T extends User$SessionArgs<ExtArgs> = {}>(args?: Subset<T, User$SessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StaticMessages<T extends User$StaticMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$StaticMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaticMessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SupportTicket<T extends User$SupportTicketArgs<ExtArgs> = {}>(args?: Subset<T, User$SupportTicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UpdateHistory<T extends User$UpdateHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$UpdateHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdateHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends User$UserArgs<ExtArgs> = {}>(args?: Subset<T, User$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_User<T extends User$other_UserArgs<ExtArgs> = {}>(args?: Subset<T, User$other_UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserAddress<T extends User$UserAddressArgs<ExtArgs> = {}>(args?: Subset<T, User$UserAddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserPrivilege<T extends User$UserPrivilegeArgs<ExtArgs> = {}>(args?: Subset<T, User$UserPrivilegeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WishlistItem<T extends User$WishlistItemArgs<ExtArgs> = {}>(args?: Subset<T, User$WishlistItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'User_role'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'User_status'>
    readonly profileUrl: FieldRef<"User", 'String'>
    readonly mobileNumber: FieldRef<"User", 'String'>
    readonly whatsAppNumber: FieldRef<"User", 'String'>
    readonly isLoggedIn: FieldRef<"User", 'Boolean'>
    readonly isViewed: FieldRef<"User", 'Boolean'>
    readonly is2FA: FieldRef<"User", 'Boolean'>
    readonly assignedStaffId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.AuditLog
   */
  export type User$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.CartItem
   */
  export type User$CartItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * User.DeleteRequest
   */
  export type User$DeleteRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleteRequest
     */
    select?: DeleteRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeleteRequest
     */
    omit?: DeleteRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeleteRequestInclude<ExtArgs> | null
    where?: DeleteRequestWhereInput
    orderBy?: DeleteRequestOrderByWithRelationInput | DeleteRequestOrderByWithRelationInput[]
    cursor?: DeleteRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeleteRequestScalarFieldEnum | DeleteRequestScalarFieldEnum[]
  }

  /**
   * User.DropMessage
   */
  export type User$DropMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropMessage
     */
    select?: DropMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DropMessage
     */
    omit?: DropMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DropMessageInclude<ExtArgs> | null
    where?: DropMessageWhereInput
    orderBy?: DropMessageOrderByWithRelationInput | DropMessageOrderByWithRelationInput[]
    cursor?: DropMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropMessageScalarFieldEnum | DropMessageScalarFieldEnum[]
  }

  /**
   * User.Message_Message_handledByIdToUser
   */
  export type User$Message_Message_handledByIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.Message_Message_receiverIdToUser
   */
  export type User$Message_Message_receiverIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.Message_Message_senderIdToUser
   */
  export type User$Message_Message_senderIdToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.Notification
   */
  export type User$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.OrderDetails
   */
  export type User$OrderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    where?: OrderDetailsWhereInput
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    cursor?: OrderDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * User.Otp
   */
  export type User$OtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    cursor?: OtpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * User.Product
   */
  export type User$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User.ProductReview
   */
  export type User$ProductReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductReview
     */
    omit?: ProductReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReviewInclude<ExtArgs> | null
    where?: ProductReviewWhereInput
    orderBy?: ProductReviewOrderByWithRelationInput | ProductReviewOrderByWithRelationInput[]
    cursor?: ProductReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductReviewScalarFieldEnum | ProductReviewScalarFieldEnum[]
  }

  /**
   * User.Rewards
   */
  export type User$RewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rewards
     */
    select?: RewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rewards
     */
    omit?: RewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardsInclude<ExtArgs> | null
    where?: RewardsWhereInput
    orderBy?: RewardsOrderByWithRelationInput | RewardsOrderByWithRelationInput[]
    cursor?: RewardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardsScalarFieldEnum | RewardsScalarFieldEnum[]
  }

  /**
   * User.SearchQuery
   */
  export type User$SearchQueryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchQuery
     */
    select?: SearchQuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchQuery
     */
    omit?: SearchQueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchQueryInclude<ExtArgs> | null
    where?: SearchQueryWhereInput
    orderBy?: SearchQueryOrderByWithRelationInput | SearchQueryOrderByWithRelationInput[]
    cursor?: SearchQueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchQueryScalarFieldEnum | SearchQueryScalarFieldEnum[]
  }

  /**
   * User.Session
   */
  export type User$SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.StaticMessages
   */
  export type User$StaticMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaticMessages
     */
    select?: StaticMessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaticMessages
     */
    omit?: StaticMessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaticMessagesInclude<ExtArgs> | null
    where?: StaticMessagesWhereInput
    orderBy?: StaticMessagesOrderByWithRelationInput | StaticMessagesOrderByWithRelationInput[]
    cursor?: StaticMessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaticMessagesScalarFieldEnum | StaticMessagesScalarFieldEnum[]
  }

  /**
   * User.SupportTicket
   */
  export type User$SupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.UpdateHistory
   */
  export type User$UpdateHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateHistory
     */
    select?: UpdateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateHistory
     */
    omit?: UpdateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateHistoryInclude<ExtArgs> | null
    where?: UpdateHistoryWhereInput
    orderBy?: UpdateHistoryOrderByWithRelationInput | UpdateHistoryOrderByWithRelationInput[]
    cursor?: UpdateHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UpdateHistoryScalarFieldEnum | UpdateHistoryScalarFieldEnum[]
  }

  /**
   * User.User
   */
  export type User$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.other_User
   */
  export type User$other_UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.UserAddress
   */
  export type User$UserAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    cursor?: UserAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * User.UserPrivilege
   */
  export type User$UserPrivilegeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    where?: UserPrivilegeWhereInput
    orderBy?: UserPrivilegeOrderByWithRelationInput | UserPrivilegeOrderByWithRelationInput[]
    cursor?: UserPrivilegeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPrivilegeScalarFieldEnum | UserPrivilegeScalarFieldEnum[]
  }

  /**
   * User.WishlistItem
   */
  export type User$WishlistItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserAddress
   */

  export type AggregateUserAddress = {
    _count: UserAddressCountAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  export type UserAddressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    mobileNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDefault: boolean | null
    fullName: string | null
    altMobileNumber: string | null
  }

  export type UserAddressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    mobileNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDefault: boolean | null
    fullName: string | null
    altMobileNumber: string | null
  }

  export type UserAddressCountAggregateOutputType = {
    id: number
    userId: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    zipCode: number
    country: number
    mobileNumber: number
    createdAt: number
    updatedAt: number
    isDefault: number
    fullName: number
    altMobileNumber: number
    _all: number
  }


  export type UserAddressMinAggregateInputType = {
    id?: true
    userId?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    mobileNumber?: true
    createdAt?: true
    updatedAt?: true
    isDefault?: true
    fullName?: true
    altMobileNumber?: true
  }

  export type UserAddressMaxAggregateInputType = {
    id?: true
    userId?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    mobileNumber?: true
    createdAt?: true
    updatedAt?: true
    isDefault?: true
    fullName?: true
    altMobileNumber?: true
  }

  export type UserAddressCountAggregateInputType = {
    id?: true
    userId?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    mobileNumber?: true
    createdAt?: true
    updatedAt?: true
    isDefault?: true
    fullName?: true
    altMobileNumber?: true
    _all?: true
  }

  export type UserAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddress to aggregate.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAddresses
    **/
    _count?: true | UserAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAddressMaxAggregateInputType
  }

  export type GetUserAddressAggregateType<T extends UserAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAddress[P]>
      : GetScalarType<T[P], AggregateUserAddress[P]>
  }




  export type UserAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
    orderBy?: UserAddressOrderByWithAggregationInput | UserAddressOrderByWithAggregationInput[]
    by: UserAddressScalarFieldEnum[] | UserAddressScalarFieldEnum
    having?: UserAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAddressCountAggregateInputType | true
    _min?: UserAddressMinAggregateInputType
    _max?: UserAddressMaxAggregateInputType
  }

  export type UserAddressGroupByOutputType = {
    id: string
    userId: string
    addressLine1: string
    addressLine2: string | null
    city: string
    state: string
    zipCode: string
    country: string
    mobileNumber: string
    createdAt: Date
    updatedAt: Date
    isDefault: boolean
    fullName: string | null
    altMobileNumber: string | null
    _count: UserAddressCountAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  type GetUserAddressGroupByPayload<T extends UserAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
            : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
        }
      >
    >


  export type UserAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    mobileNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDefault?: boolean
    fullName?: boolean
    altMobileNumber?: boolean
    OrderDetails?: boolean | UserAddress$OrderDetailsArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | UserAddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>



  export type UserAddressSelectScalar = {
    id?: boolean
    userId?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    mobileNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDefault?: boolean
    fullName?: boolean
    altMobileNumber?: boolean
  }

  export type UserAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "addressLine1" | "addressLine2" | "city" | "state" | "zipCode" | "country" | "mobileNumber" | "createdAt" | "updatedAt" | "isDefault" | "fullName" | "altMobileNumber", ExtArgs["result"]["userAddress"]>
  export type UserAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderDetails?: boolean | UserAddress$OrderDetailsArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | UserAddressCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAddress"
    objects: {
      OrderDetails: Prisma.$OrderDetailsPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      addressLine1: string
      addressLine2: string | null
      city: string
      state: string
      zipCode: string
      country: string
      mobileNumber: string
      createdAt: Date
      updatedAt: Date
      isDefault: boolean
      fullName: string | null
      altMobileNumber: string | null
    }, ExtArgs["result"]["userAddress"]>
    composites: {}
  }

  type UserAddressGetPayload<S extends boolean | null | undefined | UserAddressDefaultArgs> = $Result.GetResult<Prisma.$UserAddressPayload, S>

  type UserAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAddressCountAggregateInputType | true
    }

  export interface UserAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAddress'], meta: { name: 'UserAddress' } }
    /**
     * Find zero or one UserAddress that matches the filter.
     * @param {UserAddressFindUniqueArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAddressFindUniqueArgs>(args: SelectSubset<T, UserAddressFindUniqueArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAddressFindUniqueOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAddressFindFirstArgs>(args?: SelectSubset<T, UserAddressFindFirstArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAddresses
     * const userAddresses = await prisma.userAddress.findMany()
     * 
     * // Get first 10 UserAddresses
     * const userAddresses = await prisma.userAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAddressFindManyArgs>(args?: SelectSubset<T, UserAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAddress.
     * @param {UserAddressCreateArgs} args - Arguments to create a UserAddress.
     * @example
     * // Create one UserAddress
     * const UserAddress = await prisma.userAddress.create({
     *   data: {
     *     // ... data to create a UserAddress
     *   }
     * })
     * 
     */
    create<T extends UserAddressCreateArgs>(args: SelectSubset<T, UserAddressCreateArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAddresses.
     * @param {UserAddressCreateManyArgs} args - Arguments to create many UserAddresses.
     * @example
     * // Create many UserAddresses
     * const userAddress = await prisma.userAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAddressCreateManyArgs>(args?: SelectSubset<T, UserAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAddress.
     * @param {UserAddressDeleteArgs} args - Arguments to delete one UserAddress.
     * @example
     * // Delete one UserAddress
     * const UserAddress = await prisma.userAddress.delete({
     *   where: {
     *     // ... filter to delete one UserAddress
     *   }
     * })
     * 
     */
    delete<T extends UserAddressDeleteArgs>(args: SelectSubset<T, UserAddressDeleteArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAddress.
     * @param {UserAddressUpdateArgs} args - Arguments to update one UserAddress.
     * @example
     * // Update one UserAddress
     * const userAddress = await prisma.userAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAddressUpdateArgs>(args: SelectSubset<T, UserAddressUpdateArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAddresses.
     * @param {UserAddressDeleteManyArgs} args - Arguments to filter UserAddresses to delete.
     * @example
     * // Delete a few UserAddresses
     * const { count } = await prisma.userAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAddressDeleteManyArgs>(args?: SelectSubset<T, UserAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAddressUpdateManyArgs>(args: SelectSubset<T, UserAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAddress.
     * @param {UserAddressUpsertArgs} args - Arguments to update or create a UserAddress.
     * @example
     * // Update or create a UserAddress
     * const userAddress = await prisma.userAddress.upsert({
     *   create: {
     *     // ... data to create a UserAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAddress we want to update
     *   }
     * })
     */
    upsert<T extends UserAddressUpsertArgs>(args: SelectSubset<T, UserAddressUpsertArgs<ExtArgs>>): Prisma__UserAddressClient<$Result.GetResult<Prisma.$UserAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressCountArgs} args - Arguments to filter UserAddresses to count.
     * @example
     * // Count the number of UserAddresses
     * const count = await prisma.userAddress.count({
     *   where: {
     *     // ... the filter for the UserAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserAddressCountArgs>(
      args?: Subset<T, UserAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAddressAggregateArgs>(args: Subset<T, UserAddressAggregateArgs>): Prisma.PrismaPromise<GetUserAddressAggregateType<T>>

    /**
     * Group by UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAddress model
   */
  readonly fields: UserAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrderDetails<T extends UserAddress$OrderDetailsArgs<ExtArgs> = {}>(args?: Subset<T, UserAddress$OrderDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAddress model
   */ 
  interface UserAddressFieldRefs {
    readonly id: FieldRef<"UserAddress", 'String'>
    readonly userId: FieldRef<"UserAddress", 'String'>
    readonly addressLine1: FieldRef<"UserAddress", 'String'>
    readonly addressLine2: FieldRef<"UserAddress", 'String'>
    readonly city: FieldRef<"UserAddress", 'String'>
    readonly state: FieldRef<"UserAddress", 'String'>
    readonly zipCode: FieldRef<"UserAddress", 'String'>
    readonly country: FieldRef<"UserAddress", 'String'>
    readonly mobileNumber: FieldRef<"UserAddress", 'String'>
    readonly createdAt: FieldRef<"UserAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAddress", 'DateTime'>
    readonly isDefault: FieldRef<"UserAddress", 'Boolean'>
    readonly fullName: FieldRef<"UserAddress", 'String'>
    readonly altMobileNumber: FieldRef<"UserAddress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserAddress findUnique
   */
  export type UserAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findUniqueOrThrow
   */
  export type UserAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findFirst
   */
  export type UserAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findFirstOrThrow
   */
  export type UserAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress findMany
   */
  export type UserAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddresses to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: UserAddressOrderByWithRelationInput | UserAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    distinct?: UserAddressScalarFieldEnum | UserAddressScalarFieldEnum[]
  }

  /**
   * UserAddress create
   */
  export type UserAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAddress.
     */
    data: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
  }

  /**
   * UserAddress createMany
   */
  export type UserAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAddresses.
     */
    data: UserAddressCreateManyInput | UserAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAddress update
   */
  export type UserAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAddress.
     */
    data: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
    /**
     * Choose, which UserAddress to update.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress updateMany
   */
  export type UserAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAddresses.
     */
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     */
    where?: UserAddressWhereInput
    /**
     * Limit how many UserAddresses to update.
     */
    limit?: number
  }

  /**
   * UserAddress upsert
   */
  export type UserAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAddress to update in case it exists.
     */
    where: UserAddressWhereUniqueInput
    /**
     * In case the UserAddress found by the `where` argument doesn't exist, create a new UserAddress with this data.
     */
    create: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
    /**
     * In case the UserAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
  }

  /**
   * UserAddress delete
   */
  export type UserAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter which UserAddress to delete.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress deleteMany
   */
  export type UserAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddresses to delete
     */
    where?: UserAddressWhereInput
    /**
     * Limit how many UserAddresses to delete.
     */
    limit?: number
  }

  /**
   * UserAddress.OrderDetails
   */
  export type UserAddress$OrderDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetails
     */
    select?: OrderDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderDetails
     */
    omit?: OrderDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDetailsInclude<ExtArgs> | null
    where?: OrderDetailsWhereInput
    orderBy?: OrderDetailsOrderByWithRelationInput | OrderDetailsOrderByWithRelationInput[]
    cursor?: OrderDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderDetailsScalarFieldEnum | OrderDetailsScalarFieldEnum[]
  }

  /**
   * UserAddress without action
   */
  export type UserAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAddress
     */
    omit?: UserAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAddressInclude<ExtArgs> | null
  }


  /**
   * Model UserPrivilege
   */

  export type AggregateUserPrivilege = {
    _count: UserPrivilegeCountAggregateOutputType | null
    _min: UserPrivilegeMinAggregateOutputType | null
    _max: UserPrivilegeMaxAggregateOutputType | null
  }

  export type UserPrivilegeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    privilegeId: string | null
    createdAt: Date | null
  }

  export type UserPrivilegeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    privilegeId: string | null
    createdAt: Date | null
  }

  export type UserPrivilegeCountAggregateOutputType = {
    id: number
    userId: number
    privilegeId: number
    createdAt: number
    _all: number
  }


  export type UserPrivilegeMinAggregateInputType = {
    id?: true
    userId?: true
    privilegeId?: true
    createdAt?: true
  }

  export type UserPrivilegeMaxAggregateInputType = {
    id?: true
    userId?: true
    privilegeId?: true
    createdAt?: true
  }

  export type UserPrivilegeCountAggregateInputType = {
    id?: true
    userId?: true
    privilegeId?: true
    createdAt?: true
    _all?: true
  }

  export type UserPrivilegeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPrivilege to aggregate.
     */
    where?: UserPrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPrivileges to fetch.
     */
    orderBy?: UserPrivilegeOrderByWithRelationInput | UserPrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPrivileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPrivileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPrivileges
    **/
    _count?: true | UserPrivilegeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPrivilegeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPrivilegeMaxAggregateInputType
  }

  export type GetUserPrivilegeAggregateType<T extends UserPrivilegeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPrivilege]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPrivilege[P]>
      : GetScalarType<T[P], AggregateUserPrivilege[P]>
  }




  export type UserPrivilegeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPrivilegeWhereInput
    orderBy?: UserPrivilegeOrderByWithAggregationInput | UserPrivilegeOrderByWithAggregationInput[]
    by: UserPrivilegeScalarFieldEnum[] | UserPrivilegeScalarFieldEnum
    having?: UserPrivilegeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPrivilegeCountAggregateInputType | true
    _min?: UserPrivilegeMinAggregateInputType
    _max?: UserPrivilegeMaxAggregateInputType
  }

  export type UserPrivilegeGroupByOutputType = {
    id: string
    userId: string
    privilegeId: string
    createdAt: Date
    _count: UserPrivilegeCountAggregateOutputType | null
    _min: UserPrivilegeMinAggregateOutputType | null
    _max: UserPrivilegeMaxAggregateOutputType | null
  }

  type GetUserPrivilegeGroupByPayload<T extends UserPrivilegeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPrivilegeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPrivilegeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPrivilegeGroupByOutputType[P]>
            : GetScalarType<T[P], UserPrivilegeGroupByOutputType[P]>
        }
      >
    >


  export type UserPrivilegeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    privilegeId?: boolean
    createdAt?: boolean
    Privilege?: boolean | PrivilegeDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPrivilege"]>



  export type UserPrivilegeSelectScalar = {
    id?: boolean
    userId?: boolean
    privilegeId?: boolean
    createdAt?: boolean
  }

  export type UserPrivilegeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "privilegeId" | "createdAt", ExtArgs["result"]["userPrivilege"]>
  export type UserPrivilegeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Privilege?: boolean | PrivilegeDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPrivilegePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPrivilege"
    objects: {
      Privilege: Prisma.$PrivilegePayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      privilegeId: string
      createdAt: Date
    }, ExtArgs["result"]["userPrivilege"]>
    composites: {}
  }

  type UserPrivilegeGetPayload<S extends boolean | null | undefined | UserPrivilegeDefaultArgs> = $Result.GetResult<Prisma.$UserPrivilegePayload, S>

  type UserPrivilegeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPrivilegeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPrivilegeCountAggregateInputType | true
    }

  export interface UserPrivilegeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPrivilege'], meta: { name: 'UserPrivilege' } }
    /**
     * Find zero or one UserPrivilege that matches the filter.
     * @param {UserPrivilegeFindUniqueArgs} args - Arguments to find a UserPrivilege
     * @example
     * // Get one UserPrivilege
     * const userPrivilege = await prisma.userPrivilege.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPrivilegeFindUniqueArgs>(args: SelectSubset<T, UserPrivilegeFindUniqueArgs<ExtArgs>>): Prisma__UserPrivilegeClient<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPrivilege that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPrivilegeFindUniqueOrThrowArgs} args - Arguments to find a UserPrivilege
     * @example
     * // Get one UserPrivilege
     * const userPrivilege = await prisma.userPrivilege.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPrivilegeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPrivilegeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPrivilegeClient<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPrivilege that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivilegeFindFirstArgs} args - Arguments to find a UserPrivilege
     * @example
     * // Get one UserPrivilege
     * const userPrivilege = await prisma.userPrivilege.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPrivilegeFindFirstArgs>(args?: SelectSubset<T, UserPrivilegeFindFirstArgs<ExtArgs>>): Prisma__UserPrivilegeClient<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPrivilege that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivilegeFindFirstOrThrowArgs} args - Arguments to find a UserPrivilege
     * @example
     * // Get one UserPrivilege
     * const userPrivilege = await prisma.userPrivilege.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPrivilegeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPrivilegeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPrivilegeClient<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPrivileges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivilegeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPrivileges
     * const userPrivileges = await prisma.userPrivilege.findMany()
     * 
     * // Get first 10 UserPrivileges
     * const userPrivileges = await prisma.userPrivilege.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPrivilegeWithIdOnly = await prisma.userPrivilege.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPrivilegeFindManyArgs>(args?: SelectSubset<T, UserPrivilegeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPrivilege.
     * @param {UserPrivilegeCreateArgs} args - Arguments to create a UserPrivilege.
     * @example
     * // Create one UserPrivilege
     * const UserPrivilege = await prisma.userPrivilege.create({
     *   data: {
     *     // ... data to create a UserPrivilege
     *   }
     * })
     * 
     */
    create<T extends UserPrivilegeCreateArgs>(args: SelectSubset<T, UserPrivilegeCreateArgs<ExtArgs>>): Prisma__UserPrivilegeClient<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPrivileges.
     * @param {UserPrivilegeCreateManyArgs} args - Arguments to create many UserPrivileges.
     * @example
     * // Create many UserPrivileges
     * const userPrivilege = await prisma.userPrivilege.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPrivilegeCreateManyArgs>(args?: SelectSubset<T, UserPrivilegeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPrivilege.
     * @param {UserPrivilegeDeleteArgs} args - Arguments to delete one UserPrivilege.
     * @example
     * // Delete one UserPrivilege
     * const UserPrivilege = await prisma.userPrivilege.delete({
     *   where: {
     *     // ... filter to delete one UserPrivilege
     *   }
     * })
     * 
     */
    delete<T extends UserPrivilegeDeleteArgs>(args: SelectSubset<T, UserPrivilegeDeleteArgs<ExtArgs>>): Prisma__UserPrivilegeClient<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPrivilege.
     * @param {UserPrivilegeUpdateArgs} args - Arguments to update one UserPrivilege.
     * @example
     * // Update one UserPrivilege
     * const userPrivilege = await prisma.userPrivilege.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPrivilegeUpdateArgs>(args: SelectSubset<T, UserPrivilegeUpdateArgs<ExtArgs>>): Prisma__UserPrivilegeClient<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPrivileges.
     * @param {UserPrivilegeDeleteManyArgs} args - Arguments to filter UserPrivileges to delete.
     * @example
     * // Delete a few UserPrivileges
     * const { count } = await prisma.userPrivilege.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPrivilegeDeleteManyArgs>(args?: SelectSubset<T, UserPrivilegeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPrivileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivilegeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPrivileges
     * const userPrivilege = await prisma.userPrivilege.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPrivilegeUpdateManyArgs>(args: SelectSubset<T, UserPrivilegeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPrivilege.
     * @param {UserPrivilegeUpsertArgs} args - Arguments to update or create a UserPrivilege.
     * @example
     * // Update or create a UserPrivilege
     * const userPrivilege = await prisma.userPrivilege.upsert({
     *   create: {
     *     // ... data to create a UserPrivilege
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPrivilege we want to update
     *   }
     * })
     */
    upsert<T extends UserPrivilegeUpsertArgs>(args: SelectSubset<T, UserPrivilegeUpsertArgs<ExtArgs>>): Prisma__UserPrivilegeClient<$Result.GetResult<Prisma.$UserPrivilegePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPrivileges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivilegeCountArgs} args - Arguments to filter UserPrivileges to count.
     * @example
     * // Count the number of UserPrivileges
     * const count = await prisma.userPrivilege.count({
     *   where: {
     *     // ... the filter for the UserPrivileges we want to count
     *   }
     * })
    **/
    count<T extends UserPrivilegeCountArgs>(
      args?: Subset<T, UserPrivilegeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPrivilegeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPrivilege.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivilegeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPrivilegeAggregateArgs>(args: Subset<T, UserPrivilegeAggregateArgs>): Prisma.PrismaPromise<GetUserPrivilegeAggregateType<T>>

    /**
     * Group by UserPrivilege.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPrivilegeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPrivilegeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPrivilegeGroupByArgs['orderBy'] }
        : { orderBy?: UserPrivilegeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPrivilegeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPrivilegeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPrivilege model
   */
  readonly fields: UserPrivilegeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPrivilege.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPrivilegeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Privilege<T extends PrivilegeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrivilegeDefaultArgs<ExtArgs>>): Prisma__PrivilegeClient<$Result.GetResult<Prisma.$PrivilegePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPrivilege model
   */ 
  interface UserPrivilegeFieldRefs {
    readonly id: FieldRef<"UserPrivilege", 'String'>
    readonly userId: FieldRef<"UserPrivilege", 'String'>
    readonly privilegeId: FieldRef<"UserPrivilege", 'String'>
    readonly createdAt: FieldRef<"UserPrivilege", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPrivilege findUnique
   */
  export type UserPrivilegeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivilege to fetch.
     */
    where: UserPrivilegeWhereUniqueInput
  }

  /**
   * UserPrivilege findUniqueOrThrow
   */
  export type UserPrivilegeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivilege to fetch.
     */
    where: UserPrivilegeWhereUniqueInput
  }

  /**
   * UserPrivilege findFirst
   */
  export type UserPrivilegeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivilege to fetch.
     */
    where?: UserPrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPrivileges to fetch.
     */
    orderBy?: UserPrivilegeOrderByWithRelationInput | UserPrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPrivileges.
     */
    cursor?: UserPrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPrivileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPrivileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPrivileges.
     */
    distinct?: UserPrivilegeScalarFieldEnum | UserPrivilegeScalarFieldEnum[]
  }

  /**
   * UserPrivilege findFirstOrThrow
   */
  export type UserPrivilegeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivilege to fetch.
     */
    where?: UserPrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPrivileges to fetch.
     */
    orderBy?: UserPrivilegeOrderByWithRelationInput | UserPrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPrivileges.
     */
    cursor?: UserPrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPrivileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPrivileges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPrivileges.
     */
    distinct?: UserPrivilegeScalarFieldEnum | UserPrivilegeScalarFieldEnum[]
  }

  /**
   * UserPrivilege findMany
   */
  export type UserPrivilegeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    /**
     * Filter, which UserPrivileges to fetch.
     */
    where?: UserPrivilegeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPrivileges to fetch.
     */
    orderBy?: UserPrivilegeOrderByWithRelationInput | UserPrivilegeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPrivileges.
     */
    cursor?: UserPrivilegeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPrivileges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPrivileges.
     */
    skip?: number
    distinct?: UserPrivilegeScalarFieldEnum | UserPrivilegeScalarFieldEnum[]
  }

  /**
   * UserPrivilege create
   */
  export type UserPrivilegeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPrivilege.
     */
    data: XOR<UserPrivilegeCreateInput, UserPrivilegeUncheckedCreateInput>
  }

  /**
   * UserPrivilege createMany
   */
  export type UserPrivilegeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPrivileges.
     */
    data: UserPrivilegeCreateManyInput | UserPrivilegeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPrivilege update
   */
  export type UserPrivilegeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPrivilege.
     */
    data: XOR<UserPrivilegeUpdateInput, UserPrivilegeUncheckedUpdateInput>
    /**
     * Choose, which UserPrivilege to update.
     */
    where: UserPrivilegeWhereUniqueInput
  }

  /**
   * UserPrivilege updateMany
   */
  export type UserPrivilegeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPrivileges.
     */
    data: XOR<UserPrivilegeUpdateManyMutationInput, UserPrivilegeUncheckedUpdateManyInput>
    /**
     * Filter which UserPrivileges to update
     */
    where?: UserPrivilegeWhereInput
    /**
     * Limit how many UserPrivileges to update.
     */
    limit?: number
  }

  /**
   * UserPrivilege upsert
   */
  export type UserPrivilegeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPrivilege to update in case it exists.
     */
    where: UserPrivilegeWhereUniqueInput
    /**
     * In case the UserPrivilege found by the `where` argument doesn't exist, create a new UserPrivilege with this data.
     */
    create: XOR<UserPrivilegeCreateInput, UserPrivilegeUncheckedCreateInput>
    /**
     * In case the UserPrivilege was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPrivilegeUpdateInput, UserPrivilegeUncheckedUpdateInput>
  }

  /**
   * UserPrivilege delete
   */
  export type UserPrivilegeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
    /**
     * Filter which UserPrivilege to delete.
     */
    where: UserPrivilegeWhereUniqueInput
  }

  /**
   * UserPrivilege deleteMany
   */
  export type UserPrivilegeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPrivileges to delete
     */
    where?: UserPrivilegeWhereInput
    /**
     * Limit how many UserPrivileges to delete.
     */
    limit?: number
  }

  /**
   * UserPrivilege without action
   */
  export type UserPrivilegeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPrivilege
     */
    select?: UserPrivilegeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPrivilege
     */
    omit?: UserPrivilegeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPrivilegeInclude<ExtArgs> | null
  }


  /**
   * Model Vides
   */

  export type AggregateVides = {
    _count: VidesCountAggregateOutputType | null
    _avg: VidesAvgAggregateOutputType | null
    _sum: VidesSumAggregateOutputType | null
    _min: VidesMinAggregateOutputType | null
    _max: VidesMaxAggregateOutputType | null
  }

  export type VidesAvgAggregateOutputType = {
    price: number | null
  }

  export type VidesSumAggregateOutputType = {
    price: number | null
  }

  export type VidesMinAggregateOutputType = {
    id: string | null
    videoUrl: string | null
    title: string | null
    description: string | null
    hyperLink: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type VidesMaxAggregateOutputType = {
    id: string | null
    videoUrl: string | null
    title: string | null
    description: string | null
    hyperLink: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type VidesCountAggregateOutputType = {
    id: number
    videoUrl: number
    title: number
    description: number
    hyperLink: number
    price: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type VidesAvgAggregateInputType = {
    price?: true
  }

  export type VidesSumAggregateInputType = {
    price?: true
  }

  export type VidesMinAggregateInputType = {
    id?: true
    videoUrl?: true
    title?: true
    description?: true
    hyperLink?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type VidesMaxAggregateInputType = {
    id?: true
    videoUrl?: true
    title?: true
    description?: true
    hyperLink?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type VidesCountAggregateInputType = {
    id?: true
    videoUrl?: true
    title?: true
    description?: true
    hyperLink?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type VidesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vides to aggregate.
     */
    where?: VidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vides to fetch.
     */
    orderBy?: VidesOrderByWithRelationInput | VidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vides
    **/
    _count?: true | VidesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VidesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VidesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VidesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VidesMaxAggregateInputType
  }

  export type GetVidesAggregateType<T extends VidesAggregateArgs> = {
        [P in keyof T & keyof AggregateVides]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVides[P]>
      : GetScalarType<T[P], AggregateVides[P]>
  }




  export type VidesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VidesWhereInput
    orderBy?: VidesOrderByWithAggregationInput | VidesOrderByWithAggregationInput[]
    by: VidesScalarFieldEnum[] | VidesScalarFieldEnum
    having?: VidesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VidesCountAggregateInputType | true
    _avg?: VidesAvgAggregateInputType
    _sum?: VidesSumAggregateInputType
    _min?: VidesMinAggregateInputType
    _max?: VidesMaxAggregateInputType
  }

  export type VidesGroupByOutputType = {
    id: string
    videoUrl: string
    title: string
    description: string
    hyperLink: string
    price: number | null
    createdAt: Date
    updatedAt: Date
    productId: string | null
    _count: VidesCountAggregateOutputType | null
    _avg: VidesAvgAggregateOutputType | null
    _sum: VidesSumAggregateOutputType | null
    _min: VidesMinAggregateOutputType | null
    _max: VidesMaxAggregateOutputType | null
  }

  type GetVidesGroupByPayload<T extends VidesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VidesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VidesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VidesGroupByOutputType[P]>
            : GetScalarType<T[P], VidesGroupByOutputType[P]>
        }
      >
    >


  export type VidesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoUrl?: boolean
    title?: boolean
    description?: boolean
    hyperLink?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }, ExtArgs["result"]["vides"]>



  export type VidesSelectScalar = {
    id?: boolean
    videoUrl?: boolean
    title?: boolean
    description?: boolean
    hyperLink?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type VidesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "videoUrl" | "title" | "description" | "hyperLink" | "price" | "createdAt" | "updatedAt" | "productId", ExtArgs["result"]["vides"]>

  export type $VidesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vides"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoUrl: string
      title: string
      description: string
      hyperLink: string
      price: number | null
      createdAt: Date
      updatedAt: Date
      productId: string | null
    }, ExtArgs["result"]["vides"]>
    composites: {}
  }

  type VidesGetPayload<S extends boolean | null | undefined | VidesDefaultArgs> = $Result.GetResult<Prisma.$VidesPayload, S>

  type VidesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VidesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VidesCountAggregateInputType | true
    }

  export interface VidesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vides'], meta: { name: 'Vides' } }
    /**
     * Find zero or one Vides that matches the filter.
     * @param {VidesFindUniqueArgs} args - Arguments to find a Vides
     * @example
     * // Get one Vides
     * const vides = await prisma.vides.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VidesFindUniqueArgs>(args: SelectSubset<T, VidesFindUniqueArgs<ExtArgs>>): Prisma__VidesClient<$Result.GetResult<Prisma.$VidesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vides that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VidesFindUniqueOrThrowArgs} args - Arguments to find a Vides
     * @example
     * // Get one Vides
     * const vides = await prisma.vides.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VidesFindUniqueOrThrowArgs>(args: SelectSubset<T, VidesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VidesClient<$Result.GetResult<Prisma.$VidesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VidesFindFirstArgs} args - Arguments to find a Vides
     * @example
     * // Get one Vides
     * const vides = await prisma.vides.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VidesFindFirstArgs>(args?: SelectSubset<T, VidesFindFirstArgs<ExtArgs>>): Prisma__VidesClient<$Result.GetResult<Prisma.$VidesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vides that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VidesFindFirstOrThrowArgs} args - Arguments to find a Vides
     * @example
     * // Get one Vides
     * const vides = await prisma.vides.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VidesFindFirstOrThrowArgs>(args?: SelectSubset<T, VidesFindFirstOrThrowArgs<ExtArgs>>): Prisma__VidesClient<$Result.GetResult<Prisma.$VidesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VidesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vides
     * const vides = await prisma.vides.findMany()
     * 
     * // Get first 10 Vides
     * const vides = await prisma.vides.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videsWithIdOnly = await prisma.vides.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VidesFindManyArgs>(args?: SelectSubset<T, VidesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VidesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vides.
     * @param {VidesCreateArgs} args - Arguments to create a Vides.
     * @example
     * // Create one Vides
     * const Vides = await prisma.vides.create({
     *   data: {
     *     // ... data to create a Vides
     *   }
     * })
     * 
     */
    create<T extends VidesCreateArgs>(args: SelectSubset<T, VidesCreateArgs<ExtArgs>>): Prisma__VidesClient<$Result.GetResult<Prisma.$VidesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vides.
     * @param {VidesCreateManyArgs} args - Arguments to create many Vides.
     * @example
     * // Create many Vides
     * const vides = await prisma.vides.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VidesCreateManyArgs>(args?: SelectSubset<T, VidesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vides.
     * @param {VidesDeleteArgs} args - Arguments to delete one Vides.
     * @example
     * // Delete one Vides
     * const Vides = await prisma.vides.delete({
     *   where: {
     *     // ... filter to delete one Vides
     *   }
     * })
     * 
     */
    delete<T extends VidesDeleteArgs>(args: SelectSubset<T, VidesDeleteArgs<ExtArgs>>): Prisma__VidesClient<$Result.GetResult<Prisma.$VidesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vides.
     * @param {VidesUpdateArgs} args - Arguments to update one Vides.
     * @example
     * // Update one Vides
     * const vides = await prisma.vides.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VidesUpdateArgs>(args: SelectSubset<T, VidesUpdateArgs<ExtArgs>>): Prisma__VidesClient<$Result.GetResult<Prisma.$VidesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vides.
     * @param {VidesDeleteManyArgs} args - Arguments to filter Vides to delete.
     * @example
     * // Delete a few Vides
     * const { count } = await prisma.vides.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VidesDeleteManyArgs>(args?: SelectSubset<T, VidesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VidesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vides
     * const vides = await prisma.vides.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VidesUpdateManyArgs>(args: SelectSubset<T, VidesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vides.
     * @param {VidesUpsertArgs} args - Arguments to update or create a Vides.
     * @example
     * // Update or create a Vides
     * const vides = await prisma.vides.upsert({
     *   create: {
     *     // ... data to create a Vides
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vides we want to update
     *   }
     * })
     */
    upsert<T extends VidesUpsertArgs>(args: SelectSubset<T, VidesUpsertArgs<ExtArgs>>): Prisma__VidesClient<$Result.GetResult<Prisma.$VidesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VidesCountArgs} args - Arguments to filter Vides to count.
     * @example
     * // Count the number of Vides
     * const count = await prisma.vides.count({
     *   where: {
     *     // ... the filter for the Vides we want to count
     *   }
     * })
    **/
    count<T extends VidesCountArgs>(
      args?: Subset<T, VidesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VidesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VidesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VidesAggregateArgs>(args: Subset<T, VidesAggregateArgs>): Prisma.PrismaPromise<GetVidesAggregateType<T>>

    /**
     * Group by Vides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VidesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VidesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VidesGroupByArgs['orderBy'] }
        : { orderBy?: VidesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VidesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVidesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vides model
   */
  readonly fields: VidesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vides.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VidesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vides model
   */ 
  interface VidesFieldRefs {
    readonly id: FieldRef<"Vides", 'String'>
    readonly videoUrl: FieldRef<"Vides", 'String'>
    readonly title: FieldRef<"Vides", 'String'>
    readonly description: FieldRef<"Vides", 'String'>
    readonly hyperLink: FieldRef<"Vides", 'String'>
    readonly price: FieldRef<"Vides", 'Float'>
    readonly createdAt: FieldRef<"Vides", 'DateTime'>
    readonly updatedAt: FieldRef<"Vides", 'DateTime'>
    readonly productId: FieldRef<"Vides", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vides findUnique
   */
  export type VidesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
    /**
     * Filter, which Vides to fetch.
     */
    where: VidesWhereUniqueInput
  }

  /**
   * Vides findUniqueOrThrow
   */
  export type VidesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
    /**
     * Filter, which Vides to fetch.
     */
    where: VidesWhereUniqueInput
  }

  /**
   * Vides findFirst
   */
  export type VidesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
    /**
     * Filter, which Vides to fetch.
     */
    where?: VidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vides to fetch.
     */
    orderBy?: VidesOrderByWithRelationInput | VidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vides.
     */
    cursor?: VidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vides.
     */
    distinct?: VidesScalarFieldEnum | VidesScalarFieldEnum[]
  }

  /**
   * Vides findFirstOrThrow
   */
  export type VidesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
    /**
     * Filter, which Vides to fetch.
     */
    where?: VidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vides to fetch.
     */
    orderBy?: VidesOrderByWithRelationInput | VidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vides.
     */
    cursor?: VidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vides.
     */
    distinct?: VidesScalarFieldEnum | VidesScalarFieldEnum[]
  }

  /**
   * Vides findMany
   */
  export type VidesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
    /**
     * Filter, which Vides to fetch.
     */
    where?: VidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vides to fetch.
     */
    orderBy?: VidesOrderByWithRelationInput | VidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vides.
     */
    cursor?: VidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vides.
     */
    skip?: number
    distinct?: VidesScalarFieldEnum | VidesScalarFieldEnum[]
  }

  /**
   * Vides create
   */
  export type VidesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
    /**
     * The data needed to create a Vides.
     */
    data: XOR<VidesCreateInput, VidesUncheckedCreateInput>
  }

  /**
   * Vides createMany
   */
  export type VidesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vides.
     */
    data: VidesCreateManyInput | VidesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vides update
   */
  export type VidesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
    /**
     * The data needed to update a Vides.
     */
    data: XOR<VidesUpdateInput, VidesUncheckedUpdateInput>
    /**
     * Choose, which Vides to update.
     */
    where: VidesWhereUniqueInput
  }

  /**
   * Vides updateMany
   */
  export type VidesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vides.
     */
    data: XOR<VidesUpdateManyMutationInput, VidesUncheckedUpdateManyInput>
    /**
     * Filter which Vides to update
     */
    where?: VidesWhereInput
    /**
     * Limit how many Vides to update.
     */
    limit?: number
  }

  /**
   * Vides upsert
   */
  export type VidesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
    /**
     * The filter to search for the Vides to update in case it exists.
     */
    where: VidesWhereUniqueInput
    /**
     * In case the Vides found by the `where` argument doesn't exist, create a new Vides with this data.
     */
    create: XOR<VidesCreateInput, VidesUncheckedCreateInput>
    /**
     * In case the Vides was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VidesUpdateInput, VidesUncheckedUpdateInput>
  }

  /**
   * Vides delete
   */
  export type VidesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
    /**
     * Filter which Vides to delete.
     */
    where: VidesWhereUniqueInput
  }

  /**
   * Vides deleteMany
   */
  export type VidesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vides to delete
     */
    where?: VidesWhereInput
    /**
     * Limit how many Vides to delete.
     */
    limit?: number
  }

  /**
   * Vides without action
   */
  export type VidesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vides
     */
    select?: VidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vides
     */
    omit?: VidesOmit<ExtArgs> | null
  }


  /**
   * Model Visitor
   */

  export type AggregateVisitor = {
    _count: VisitorCountAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  export type VisitorMinAggregateOutputType = {
    id: string | null
    ipAddress: string | null
    cookieId: string | null
    createdAt: Date | null
  }

  export type VisitorMaxAggregateOutputType = {
    id: string | null
    ipAddress: string | null
    cookieId: string | null
    createdAt: Date | null
  }

  export type VisitorCountAggregateOutputType = {
    id: number
    ipAddress: number
    cookieId: number
    createdAt: number
    _all: number
  }


  export type VisitorMinAggregateInputType = {
    id?: true
    ipAddress?: true
    cookieId?: true
    createdAt?: true
  }

  export type VisitorMaxAggregateInputType = {
    id?: true
    ipAddress?: true
    cookieId?: true
    createdAt?: true
  }

  export type VisitorCountAggregateInputType = {
    id?: true
    ipAddress?: true
    cookieId?: true
    createdAt?: true
    _all?: true
  }

  export type VisitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitor to aggregate.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Visitors
    **/
    _count?: true | VisitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitorMaxAggregateInputType
  }

  export type GetVisitorAggregateType<T extends VisitorAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitor[P]>
      : GetScalarType<T[P], AggregateVisitor[P]>
  }




  export type VisitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitorWhereInput
    orderBy?: VisitorOrderByWithAggregationInput | VisitorOrderByWithAggregationInput[]
    by: VisitorScalarFieldEnum[] | VisitorScalarFieldEnum
    having?: VisitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitorCountAggregateInputType | true
    _min?: VisitorMinAggregateInputType
    _max?: VisitorMaxAggregateInputType
  }

  export type VisitorGroupByOutputType = {
    id: string
    ipAddress: string
    cookieId: string | null
    createdAt: Date
    _count: VisitorCountAggregateOutputType | null
    _min: VisitorMinAggregateOutputType | null
    _max: VisitorMaxAggregateOutputType | null
  }

  type GetVisitorGroupByPayload<T extends VisitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitorGroupByOutputType[P]>
            : GetScalarType<T[P], VisitorGroupByOutputType[P]>
        }
      >
    >


  export type VisitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ipAddress?: boolean
    cookieId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["visitor"]>



  export type VisitorSelectScalar = {
    id?: boolean
    ipAddress?: boolean
    cookieId?: boolean
    createdAt?: boolean
  }

  export type VisitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ipAddress" | "cookieId" | "createdAt", ExtArgs["result"]["visitor"]>

  export type $VisitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Visitor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ipAddress: string
      cookieId: string | null
      createdAt: Date
    }, ExtArgs["result"]["visitor"]>
    composites: {}
  }

  type VisitorGetPayload<S extends boolean | null | undefined | VisitorDefaultArgs> = $Result.GetResult<Prisma.$VisitorPayload, S>

  type VisitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitorCountAggregateInputType | true
    }

  export interface VisitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Visitor'], meta: { name: 'Visitor' } }
    /**
     * Find zero or one Visitor that matches the filter.
     * @param {VisitorFindUniqueArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitorFindUniqueArgs>(args: SelectSubset<T, VisitorFindUniqueArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Visitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitorFindUniqueOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitorFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitorFindFirstArgs>(args?: SelectSubset<T, VisitorFindFirstArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Visitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindFirstOrThrowArgs} args - Arguments to find a Visitor
     * @example
     * // Get one Visitor
     * const visitor = await prisma.visitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitorFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Visitors
     * const visitors = await prisma.visitor.findMany()
     * 
     * // Get first 10 Visitors
     * const visitors = await prisma.visitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitorWithIdOnly = await prisma.visitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitorFindManyArgs>(args?: SelectSubset<T, VisitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Visitor.
     * @param {VisitorCreateArgs} args - Arguments to create a Visitor.
     * @example
     * // Create one Visitor
     * const Visitor = await prisma.visitor.create({
     *   data: {
     *     // ... data to create a Visitor
     *   }
     * })
     * 
     */
    create<T extends VisitorCreateArgs>(args: SelectSubset<T, VisitorCreateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Visitors.
     * @param {VisitorCreateManyArgs} args - Arguments to create many Visitors.
     * @example
     * // Create many Visitors
     * const visitor = await prisma.visitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitorCreateManyArgs>(args?: SelectSubset<T, VisitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Visitor.
     * @param {VisitorDeleteArgs} args - Arguments to delete one Visitor.
     * @example
     * // Delete one Visitor
     * const Visitor = await prisma.visitor.delete({
     *   where: {
     *     // ... filter to delete one Visitor
     *   }
     * })
     * 
     */
    delete<T extends VisitorDeleteArgs>(args: SelectSubset<T, VisitorDeleteArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Visitor.
     * @param {VisitorUpdateArgs} args - Arguments to update one Visitor.
     * @example
     * // Update one Visitor
     * const visitor = await prisma.visitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitorUpdateArgs>(args: SelectSubset<T, VisitorUpdateArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Visitors.
     * @param {VisitorDeleteManyArgs} args - Arguments to filter Visitors to delete.
     * @example
     * // Delete a few Visitors
     * const { count } = await prisma.visitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitorDeleteManyArgs>(args?: SelectSubset<T, VisitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Visitors
     * const visitor = await prisma.visitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitorUpdateManyArgs>(args: SelectSubset<T, VisitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Visitor.
     * @param {VisitorUpsertArgs} args - Arguments to update or create a Visitor.
     * @example
     * // Update or create a Visitor
     * const visitor = await prisma.visitor.upsert({
     *   create: {
     *     // ... data to create a Visitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Visitor we want to update
     *   }
     * })
     */
    upsert<T extends VisitorUpsertArgs>(args: SelectSubset<T, VisitorUpsertArgs<ExtArgs>>): Prisma__VisitorClient<$Result.GetResult<Prisma.$VisitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorCountArgs} args - Arguments to filter Visitors to count.
     * @example
     * // Count the number of Visitors
     * const count = await prisma.visitor.count({
     *   where: {
     *     // ... the filter for the Visitors we want to count
     *   }
     * })
    **/
    count<T extends VisitorCountArgs>(
      args?: Subset<T, VisitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitorAggregateArgs>(args: Subset<T, VisitorAggregateArgs>): Prisma.PrismaPromise<GetVisitorAggregateType<T>>

    /**
     * Group by Visitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitorGroupByArgs['orderBy'] }
        : { orderBy?: VisitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Visitor model
   */
  readonly fields: VisitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Visitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Visitor model
   */ 
  interface VisitorFieldRefs {
    readonly id: FieldRef<"Visitor", 'String'>
    readonly ipAddress: FieldRef<"Visitor", 'String'>
    readonly cookieId: FieldRef<"Visitor", 'String'>
    readonly createdAt: FieldRef<"Visitor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Visitor findUnique
   */
  export type VisitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findUniqueOrThrow
   */
  export type VisitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor findFirst
   */
  export type VisitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findFirstOrThrow
   */
  export type VisitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Filter, which Visitor to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Visitors.
     */
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor findMany
   */
  export type VisitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Filter, which Visitors to fetch.
     */
    where?: VisitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Visitors to fetch.
     */
    orderBy?: VisitorOrderByWithRelationInput | VisitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Visitors.
     */
    cursor?: VisitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Visitors.
     */
    skip?: number
    distinct?: VisitorScalarFieldEnum | VisitorScalarFieldEnum[]
  }

  /**
   * Visitor create
   */
  export type VisitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * The data needed to create a Visitor.
     */
    data: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
  }

  /**
   * Visitor createMany
   */
  export type VisitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Visitors.
     */
    data: VisitorCreateManyInput | VisitorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Visitor update
   */
  export type VisitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * The data needed to update a Visitor.
     */
    data: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
    /**
     * Choose, which Visitor to update.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor updateMany
   */
  export type VisitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Visitors.
     */
    data: XOR<VisitorUpdateManyMutationInput, VisitorUncheckedUpdateManyInput>
    /**
     * Filter which Visitors to update
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to update.
     */
    limit?: number
  }

  /**
   * Visitor upsert
   */
  export type VisitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * The filter to search for the Visitor to update in case it exists.
     */
    where: VisitorWhereUniqueInput
    /**
     * In case the Visitor found by the `where` argument doesn't exist, create a new Visitor with this data.
     */
    create: XOR<VisitorCreateInput, VisitorUncheckedCreateInput>
    /**
     * In case the Visitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitorUpdateInput, VisitorUncheckedUpdateInput>
  }

  /**
   * Visitor delete
   */
  export type VisitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
    /**
     * Filter which Visitor to delete.
     */
    where: VisitorWhereUniqueInput
  }

  /**
   * Visitor deleteMany
   */
  export type VisitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Visitors to delete
     */
    where?: VisitorWhereInput
    /**
     * Limit how many Visitors to delete.
     */
    limit?: number
  }

  /**
   * Visitor without action
   */
  export type VisitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Visitor
     */
    select?: VisitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Visitor
     */
    omit?: VisitorOmit<ExtArgs> | null
  }


  /**
   * Model WishlistItem
   */

  export type AggregateWishlistItem = {
    _count: WishlistItemCountAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  export type WishlistItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type WishlistItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type WishlistItemCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    createdAt: number
    _all: number
  }


  export type WishlistItemMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
  }

  export type WishlistItemMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
  }

  export type WishlistItemCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
    _all?: true
  }

  export type WishlistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItem to aggregate.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WishlistItems
    **/
    _count?: true | WishlistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistItemMaxAggregateInputType
  }

  export type GetWishlistItemAggregateType<T extends WishlistItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlistItem[P]>
      : GetScalarType<T[P], AggregateWishlistItem[P]>
  }




  export type WishlistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
    orderBy?: WishlistItemOrderByWithAggregationInput | WishlistItemOrderByWithAggregationInput[]
    by: WishlistItemScalarFieldEnum[] | WishlistItemScalarFieldEnum
    having?: WishlistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistItemCountAggregateInputType | true
    _min?: WishlistItemMinAggregateInputType
    _max?: WishlistItemMaxAggregateInputType
  }

  export type WishlistItemGroupByOutputType = {
    id: string
    userId: string
    productId: string
    createdAt: Date
    _count: WishlistItemCountAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  type GetWishlistItemGroupByPayload<T extends WishlistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WishlistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
        }
      >
    >


  export type WishlistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>



  export type WishlistItemSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
  }

  export type WishlistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "createdAt", ExtArgs["result"]["wishlistItem"]>
  export type WishlistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WishlistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WishlistItem"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      createdAt: Date
    }, ExtArgs["result"]["wishlistItem"]>
    composites: {}
  }

  type WishlistItemGetPayload<S extends boolean | null | undefined | WishlistItemDefaultArgs> = $Result.GetResult<Prisma.$WishlistItemPayload, S>

  type WishlistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WishlistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WishlistItemCountAggregateInputType | true
    }

  export interface WishlistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WishlistItem'], meta: { name: 'WishlistItem' } }
    /**
     * Find zero or one WishlistItem that matches the filter.
     * @param {WishlistItemFindUniqueArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WishlistItemFindUniqueArgs>(args: SelectSubset<T, WishlistItemFindUniqueArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WishlistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WishlistItemFindUniqueOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WishlistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WishlistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WishlistItemFindFirstArgs>(args?: SelectSubset<T, WishlistItemFindFirstArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WishlistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WishlistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WishlistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WishlistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany()
     * 
     * // Get first 10 WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WishlistItemFindManyArgs>(args?: SelectSubset<T, WishlistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WishlistItem.
     * @param {WishlistItemCreateArgs} args - Arguments to create a WishlistItem.
     * @example
     * // Create one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.create({
     *   data: {
     *     // ... data to create a WishlistItem
     *   }
     * })
     * 
     */
    create<T extends WishlistItemCreateArgs>(args: SelectSubset<T, WishlistItemCreateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WishlistItems.
     * @param {WishlistItemCreateManyArgs} args - Arguments to create many WishlistItems.
     * @example
     * // Create many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WishlistItemCreateManyArgs>(args?: SelectSubset<T, WishlistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WishlistItem.
     * @param {WishlistItemDeleteArgs} args - Arguments to delete one WishlistItem.
     * @example
     * // Delete one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.delete({
     *   where: {
     *     // ... filter to delete one WishlistItem
     *   }
     * })
     * 
     */
    delete<T extends WishlistItemDeleteArgs>(args: SelectSubset<T, WishlistItemDeleteArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WishlistItem.
     * @param {WishlistItemUpdateArgs} args - Arguments to update one WishlistItem.
     * @example
     * // Update one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WishlistItemUpdateArgs>(args: SelectSubset<T, WishlistItemUpdateArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WishlistItems.
     * @param {WishlistItemDeleteManyArgs} args - Arguments to filter WishlistItems to delete.
     * @example
     * // Delete a few WishlistItems
     * const { count } = await prisma.wishlistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WishlistItemDeleteManyArgs>(args?: SelectSubset<T, WishlistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WishlistItemUpdateManyArgs>(args: SelectSubset<T, WishlistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WishlistItem.
     * @param {WishlistItemUpsertArgs} args - Arguments to update or create a WishlistItem.
     * @example
     * // Update or create a WishlistItem
     * const wishlistItem = await prisma.wishlistItem.upsert({
     *   create: {
     *     // ... data to create a WishlistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishlistItem we want to update
     *   }
     * })
     */
    upsert<T extends WishlistItemUpsertArgs>(args: SelectSubset<T, WishlistItemUpsertArgs<ExtArgs>>): Prisma__WishlistItemClient<$Result.GetResult<Prisma.$WishlistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemCountArgs} args - Arguments to filter WishlistItems to count.
     * @example
     * // Count the number of WishlistItems
     * const count = await prisma.wishlistItem.count({
     *   where: {
     *     // ... the filter for the WishlistItems we want to count
     *   }
     * })
    **/
    count<T extends WishlistItemCountArgs>(
      args?: Subset<T, WishlistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistItemAggregateArgs>(args: Subset<T, WishlistItemAggregateArgs>): Prisma.PrismaPromise<GetWishlistItemAggregateType<T>>

    /**
     * Group by WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistItemGroupByArgs['orderBy'] }
        : { orderBy?: WishlistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WishlistItem model
   */
  readonly fields: WishlistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WishlistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WishlistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WishlistItem model
   */ 
  interface WishlistItemFieldRefs {
    readonly id: FieldRef<"WishlistItem", 'String'>
    readonly userId: FieldRef<"WishlistItem", 'String'>
    readonly productId: FieldRef<"WishlistItem", 'String'>
    readonly createdAt: FieldRef<"WishlistItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WishlistItem findUnique
   */
  export type WishlistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findUniqueOrThrow
   */
  export type WishlistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findFirst
   */
  export type WishlistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findFirstOrThrow
   */
  export type WishlistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem findMany
   */
  export type WishlistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItems to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: WishlistItemOrderByWithRelationInput | WishlistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    distinct?: WishlistItemScalarFieldEnum | WishlistItemScalarFieldEnum[]
  }

  /**
   * WishlistItem create
   */
  export type WishlistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WishlistItem.
     */
    data: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
  }

  /**
   * WishlistItem createMany
   */
  export type WishlistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WishlistItems.
     */
    data: WishlistItemCreateManyInput | WishlistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WishlistItem update
   */
  export type WishlistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WishlistItem.
     */
    data: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
    /**
     * Choose, which WishlistItem to update.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem updateMany
   */
  export type WishlistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to update.
     */
    limit?: number
  }

  /**
   * WishlistItem upsert
   */
  export type WishlistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WishlistItem to update in case it exists.
     */
    where: WishlistItemWhereUniqueInput
    /**
     * In case the WishlistItem found by the `where` argument doesn't exist, create a new WishlistItem with this data.
     */
    create: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
    /**
     * In case the WishlistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
  }

  /**
   * WishlistItem delete
   */
  export type WishlistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter which WishlistItem to delete.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem deleteMany
   */
  export type WishlistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItems to delete
     */
    where?: WishlistItemWhereInput
    /**
     * Limit how many WishlistItems to delete.
     */
    limit?: number
  }

  /**
   * WishlistItem without action
   */
  export type WishlistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WishlistItem
     */
    omit?: WishlistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WishlistItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnchorTextScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnchorTextScalarFieldEnum = (typeof AnchorTextScalarFieldEnum)[keyof typeof AnchorTextScalarFieldEnum]


  export const AnnouncementsScalarFieldEnum: {
    id: 'id',
    text: 'text'
  };

  export type AnnouncementsScalarFieldEnum = (typeof AnnouncementsScalarFieldEnum)[keyof typeof AnnouncementsScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const BestSellingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    hyperLink: 'hyperLink',
    price: 'price'
  };

  export type BestSellingScalarFieldEnum = (typeof BestSellingScalarFieldEnum)[keyof typeof BestSellingScalarFieldEnum]


  export const CallRequestScalarFieldEnum: {
    id: 'id',
    mobileNumber: 'mobileNumber',
    orderId: 'orderId',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CallRequestScalarFieldEnum = (typeof CallRequestScalarFieldEnum)[keyof typeof CallRequestScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    colorId: 'colorId',
    sizeId: 'sizeId',
    imageId: 'imageId'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const ContactUsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactUsScalarFieldEnum = (typeof ContactUsScalarFieldEnum)[keyof typeof ContactUsScalarFieldEnum]


  export const CustomerTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    productId: 'productId'
  };

  export type CustomerTypeScalarFieldEnum = (typeof CustomerTypeScalarFieldEnum)[keyof typeof CustomerTypeScalarFieldEnum]


  export const DeleteRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    userEmail: 'userEmail',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type DeleteRequestScalarFieldEnum = (typeof DeleteRequestScalarFieldEnum)[keyof typeof DeleteRequestScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    amount: 'amount',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId',
    maxPrice: 'maxPrice',
    minPrice: 'minPrice',
    isActive: 'isActive',
    isSpecial: 'isSpecial',
    orders: 'orders',
    userEmails: 'userEmails',
    isWebAvailable: 'isWebAvailable',
    isCODAvailable: 'isCODAvailable'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const DropMessageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    createdAt: 'createdAt'
  };

  export type DropMessageScalarFieldEnum = (typeof DropMessageScalarFieldEnum)[keyof typeof DropMessageScalarFieldEnum]


  export const ExclusiveCollectionScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    categoryHyperLink: 'categoryHyperLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    mrp: 'mrp',
    price: 'price'
  };

  export type ExclusiveCollectionScalarFieldEnum = (typeof ExclusiveCollectionScalarFieldEnum)[keyof typeof ExclusiveCollectionScalarFieldEnum]


  export const HeroSlidersScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    categoryHyperLink: 'categoryHyperLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HeroSlidersScalarFieldEnum = (typeof HeroSlidersScalarFieldEnum)[keyof typeof HeroSlidersScalarFieldEnum]


  export const ImageWeekScalarFieldEnum: {
    id: 'id',
    hyperLink: 'hyperLink',
    imageUrl: 'imageUrl'
  };

  export type ImageWeekScalarFieldEnum = (typeof ImageWeekScalarFieldEnum)[keyof typeof ImageWeekScalarFieldEnum]


  export const LogosScalarFieldEnum: {
    id: 'id',
    logoUrl: 'logoUrl',
    isActive: 'isActive',
    altText: 'altText'
  };

  export type LogosScalarFieldEnum = (typeof LogosScalarFieldEnum)[keyof typeof LogosScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    message: 'message',
    createdAt: 'createdAt',
    handledById: 'handledById'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NewArrivalsScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    mrp: 'mrp',
    price: 'price',
    title: 'title'
  };

  export type NewArrivalsScalarFieldEnum = (typeof NewArrivalsScalarFieldEnum)[keyof typeof NewArrivalsScalarFieldEnum]


  export const NewsletterScalarFieldEnum: {
    id: 'id',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsletterScalarFieldEnum = (typeof NewsletterScalarFieldEnum)[keyof typeof NewsletterScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    hyperLink: 'hyperLink',
    title: 'title'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const OrderDetailsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalPrice: 'totalPrice',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    discountId: 'discountId',
    orderId: 'orderId',
    paymentMethod: 'paymentMethod',
    notes: 'notes',
    trackingId: 'trackingId',
    addressId: 'addressId',
    finalPrice: 'finalPrice'
  };

  export type OrderDetailsScalarFieldEnum = (typeof OrderDetailsScalarFieldEnum)[keyof typeof OrderDetailsScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sizeId: 'sizeId',
    colorId: 'colorId',
    imageId: 'imageId',
    isReviewed: 'isReviewed'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const PaymentDetailsScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    bank: 'bank',
    currency: 'currency',
    method: 'method',
    order_id: 'order_id',
    payment_id: 'payment_id',
    upi: 'upi',
    wallet: 'wallet'
  };

  export type PaymentDetailsScalarFieldEnum = (typeof PaymentDetailsScalarFieldEnum)[keyof typeof PaymentDetailsScalarFieldEnum]


  export const PrivilegeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    label: 'label'
  };

  export type PrivilegeScalarFieldEnum = (typeof PrivilegeScalarFieldEnum)[keyof typeof PrivilegeScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    isReturnable: 'isReturnable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    thumbnailUrl: 'thumbnailUrl',
    isActive: 'isActive',
    description: 'description',
    summary: 'summary',
    customerTypeId: 'customerTypeId',
    userId: 'userId',
    estimatedDeliveryDay: 'estimatedDeliveryDay',
    styleId: 'styleId',
    title: 'title',
    returnPolicy: 'returnPolicy',
    views: 'views',
    displayPrice: 'displayPrice',
    tags: 'tags',
    longTailKeyword: 'longTailKeyword',
    affiliateId: 'affiliateId',
    isCODAvailable: 'isCODAvailable',
    ogImage: 'ogImage',
    sellerCode: 'sellerCode',
    sizeChartId: 'sizeChartId',
    fabricId: 'fabricId',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    isVisible: 'isVisible',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductColorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    slug: 'slug'
  };

  export type ProductColorScalarFieldEnum = (typeof ProductColorScalarFieldEnum)[keyof typeof ProductColorScalarFieldEnum]


  export const ProductFabricScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type ProductFabricScalarFieldEnum = (typeof ProductFabricScalarFieldEnum)[keyof typeof ProductFabricScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    imageUrl: 'imageUrl',
    colorId: 'colorId',
    altText: 'altText',
    caption: 'caption'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const ProductInventoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    mrp: 'mrp',
    price: 'price',
    sizeId: 'sizeId',
    stock: 'stock',
    minQuantity: 'minQuantity',
    discount: 'discount'
  };

  export type ProductInventoryScalarFieldEnum = (typeof ProductInventoryScalarFieldEnum)[keyof typeof ProductInventoryScalarFieldEnum]


  export const ProductReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    rating: 'rating',
    review: 'review',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    images: 'images'
  };

  export type ProductReviewScalarFieldEnum = (typeof ProductReviewScalarFieldEnum)[keyof typeof ProductReviewScalarFieldEnum]


  export const ProductSizeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type ProductSizeScalarFieldEnum = (typeof ProductSizeScalarFieldEnum)[keyof typeof ProductSizeScalarFieldEnum]


  export const ProductWeekScalarFieldEnum: {
    id: 'id',
    title: 'title',
    hyperLink: 'hyperLink',
    imageUrl: 'imageUrl'
  };

  export type ProductWeekScalarFieldEnum = (typeof ProductWeekScalarFieldEnum)[keyof typeof ProductWeekScalarFieldEnum]


  export const QuotesScalarFieldEnum: {
    id: 'id',
    text: 'text',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    categoryId: 'categoryId'
  };

  export type QuotesScalarFieldEnum = (typeof QuotesScalarFieldEnum)[keyof typeof QuotesScalarFieldEnum]


  export const ReturnRequestScalarFieldEnum: {
    id: 'id',
    orderItemId: 'orderItemId',
    reason: 'reason',
    status: 'status',
    requestedAt: 'requestedAt',
    resolvedAt: 'resolvedAt'
  };

  export type ReturnRequestScalarFieldEnum = (typeof ReturnRequestScalarFieldEnum)[keyof typeof ReturnRequestScalarFieldEnum]


  export const RewardsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    code: 'code',
    description: 'description'
  };

  export type RewardsScalarFieldEnum = (typeof RewardsScalarFieldEnum)[keyof typeof RewardsScalarFieldEnum]


  export const SearchQueryScalarFieldEnum: {
    id: 'id',
    query: 'query',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type SearchQueryScalarFieldEnum = (typeof SearchQueryScalarFieldEnum)[keyof typeof SearchQueryScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ShopByOccasionScalarFieldEnum: {
    id: 'id',
    occasionName: 'occasionName',
    categoryHyperLinks: 'categoryHyperLinks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopByOccasionScalarFieldEnum = (typeof ShopByOccasionScalarFieldEnum)[keyof typeof ShopByOccasionScalarFieldEnum]


  export const ShopByOccasionProductScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    shopByOccasionId: 'shopByOccasionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopByOccasionProductScalarFieldEnum = (typeof ShopByOccasionProductScalarFieldEnum)[keyof typeof ShopByOccasionProductScalarFieldEnum]


  export const ShopBySeasonScalarFieldEnum: {
    id: 'id',
    videoUrl: 'videoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopBySeasonScalarFieldEnum = (typeof ShopBySeasonScalarFieldEnum)[keyof typeof ShopBySeasonScalarFieldEnum]


  export const ShopBySeasonProductScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    seasonId: 'seasonId',
    hyperLink: 'hyperLink'
  };

  export type ShopBySeasonProductScalarFieldEnum = (typeof ShopBySeasonProductScalarFieldEnum)[keyof typeof ShopBySeasonProductScalarFieldEnum]


  export const ShowcasesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    categoryHyperLink: 'categoryHyperLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShowcasesScalarFieldEnum = (typeof ShowcasesScalarFieldEnum)[keyof typeof ShowcasesScalarFieldEnum]


  export const SizeChartScalarFieldEnum: {
    id: 'id',
    title: 'title',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type SizeChartScalarFieldEnum = (typeof SizeChartScalarFieldEnum)[keyof typeof SizeChartScalarFieldEnum]


  export const SocialLinksScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink'
  };

  export type SocialLinksScalarFieldEnum = (typeof SocialLinksScalarFieldEnum)[keyof typeof SocialLinksScalarFieldEnum]


  export const StaticMessagesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type StaticMessagesScalarFieldEnum = (typeof StaticMessagesScalarFieldEnum)[keyof typeof StaticMessagesScalarFieldEnum]


  export const SubCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    categoryId: 'categoryId',
    imageUrl: 'imageUrl',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription'
  };

  export type SubCategoryScalarFieldEnum = (typeof SubCategoryScalarFieldEnum)[keyof typeof SubCategoryScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subject: 'subject',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt',
    resolvedAt: 'resolvedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    tag: 'tag'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const TrendingScalarFieldEnum: {
    id: 'id',
    videoUrl: 'videoUrl',
    title: 'title',
    price: 'price',
    hyperLink: 'hyperLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    avatarUrl: 'avatarUrl'
  };

  export type TrendingScalarFieldEnum = (typeof TrendingScalarFieldEnum)[keyof typeof TrendingScalarFieldEnum]


  export const UpdateHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type UpdateHistoryScalarFieldEnum = (typeof UpdateHistoryScalarFieldEnum)[keyof typeof UpdateHistoryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isVerified: 'isVerified',
    role: 'role',
    firstName: 'firstName',
    lastName: 'lastName',
    status: 'status',
    profileUrl: 'profileUrl',
    mobileNumber: 'mobileNumber',
    whatsAppNumber: 'whatsAppNumber',
    isLoggedIn: 'isLoggedIn',
    isViewed: 'isViewed',
    is2FA: 'is2FA',
    assignedStaffId: 'assignedStaffId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserAddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    mobileNumber: 'mobileNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDefault: 'isDefault',
    fullName: 'fullName',
    altMobileNumber: 'altMobileNumber'
  };

  export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


  export const UserPrivilegeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    privilegeId: 'privilegeId',
    createdAt: 'createdAt'
  };

  export type UserPrivilegeScalarFieldEnum = (typeof UserPrivilegeScalarFieldEnum)[keyof typeof UserPrivilegeScalarFieldEnum]


  export const VidesScalarFieldEnum: {
    id: 'id',
    videoUrl: 'videoUrl',
    title: 'title',
    description: 'description',
    hyperLink: 'hyperLink',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type VidesScalarFieldEnum = (typeof VidesScalarFieldEnum)[keyof typeof VidesScalarFieldEnum]


  export const VisitorScalarFieldEnum: {
    id: 'id',
    ipAddress: 'ipAddress',
    cookieId: 'cookieId',
    createdAt: 'createdAt'
  };

  export type VisitorScalarFieldEnum = (typeof VisitorScalarFieldEnum)[keyof typeof VisitorScalarFieldEnum]


  export const WishlistItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    createdAt: 'createdAt'
  };

  export type WishlistItemScalarFieldEnum = (typeof WishlistItemScalarFieldEnum)[keyof typeof WishlistItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const AnchorTextOrderByRelevanceFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    data: 'data'
  };

  export type AnchorTextOrderByRelevanceFieldEnum = (typeof AnchorTextOrderByRelevanceFieldEnum)[keyof typeof AnchorTextOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AnnouncementsOrderByRelevanceFieldEnum: {
    id: 'id',
    text: 'text'
  };

  export type AnnouncementsOrderByRelevanceFieldEnum = (typeof AnnouncementsOrderByRelevanceFieldEnum)[keyof typeof AnnouncementsOrderByRelevanceFieldEnum]


  export const AuditLogOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    description: 'description'
  };

  export type AuditLogOrderByRelevanceFieldEnum = (typeof AuditLogOrderByRelevanceFieldEnum)[keyof typeof AuditLogOrderByRelevanceFieldEnum]


  export const BestSellingOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    hyperLink: 'hyperLink',
    price: 'price'
  };

  export type BestSellingOrderByRelevanceFieldEnum = (typeof BestSellingOrderByRelevanceFieldEnum)[keyof typeof BestSellingOrderByRelevanceFieldEnum]


  export const CallRequestOrderByRelevanceFieldEnum: {
    id: 'id',
    mobileNumber: 'mobileNumber',
    orderId: 'orderId'
  };

  export type CallRequestOrderByRelevanceFieldEnum = (typeof CallRequestOrderByRelevanceFieldEnum)[keyof typeof CallRequestOrderByRelevanceFieldEnum]


  export const CartItemOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    colorId: 'colorId',
    sizeId: 'sizeId',
    imageId: 'imageId'
  };

  export type CartItemOrderByRelevanceFieldEnum = (typeof CartItemOrderByRelevanceFieldEnum)[keyof typeof CartItemOrderByRelevanceFieldEnum]


  export const ContactUsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    message: 'message'
  };

  export type ContactUsOrderByRelevanceFieldEnum = (typeof ContactUsOrderByRelevanceFieldEnum)[keyof typeof ContactUsOrderByRelevanceFieldEnum]


  export const CustomerTypeOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    productId: 'productId'
  };

  export type CustomerTypeOrderByRelevanceFieldEnum = (typeof CustomerTypeOrderByRelevanceFieldEnum)[keyof typeof CustomerTypeOrderByRelevanceFieldEnum]


  export const DeleteRequestOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    userEmail: 'userEmail',
    reason: 'reason'
  };

  export type DeleteRequestOrderByRelevanceFieldEnum = (typeof DeleteRequestOrderByRelevanceFieldEnum)[keyof typeof DeleteRequestOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const DiscountOrderByRelevanceFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    productId: 'productId'
  };

  export type DiscountOrderByRelevanceFieldEnum = (typeof DiscountOrderByRelevanceFieldEnum)[keyof typeof DiscountOrderByRelevanceFieldEnum]


  export const DropMessageOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type DropMessageOrderByRelevanceFieldEnum = (typeof DropMessageOrderByRelevanceFieldEnum)[keyof typeof DropMessageOrderByRelevanceFieldEnum]


  export const ExclusiveCollectionOrderByRelevanceFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    categoryHyperLink: 'categoryHyperLink'
  };

  export type ExclusiveCollectionOrderByRelevanceFieldEnum = (typeof ExclusiveCollectionOrderByRelevanceFieldEnum)[keyof typeof ExclusiveCollectionOrderByRelevanceFieldEnum]


  export const HeroSlidersOrderByRelevanceFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    categoryHyperLink: 'categoryHyperLink'
  };

  export type HeroSlidersOrderByRelevanceFieldEnum = (typeof HeroSlidersOrderByRelevanceFieldEnum)[keyof typeof HeroSlidersOrderByRelevanceFieldEnum]


  export const ImageWeekOrderByRelevanceFieldEnum: {
    id: 'id',
    hyperLink: 'hyperLink',
    imageUrl: 'imageUrl'
  };

  export type ImageWeekOrderByRelevanceFieldEnum = (typeof ImageWeekOrderByRelevanceFieldEnum)[keyof typeof ImageWeekOrderByRelevanceFieldEnum]


  export const LogosOrderByRelevanceFieldEnum: {
    id: 'id',
    logoUrl: 'logoUrl',
    altText: 'altText'
  };

  export type LogosOrderByRelevanceFieldEnum = (typeof LogosOrderByRelevanceFieldEnum)[keyof typeof LogosOrderByRelevanceFieldEnum]


  export const MessageOrderByRelevanceFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    message: 'message',
    handledById: 'handledById'
  };

  export type MessageOrderByRelevanceFieldEnum = (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum]


  export const NewArrivalsOrderByRelevanceFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    description: 'description',
    title: 'title'
  };

  export type NewArrivalsOrderByRelevanceFieldEnum = (typeof NewArrivalsOrderByRelevanceFieldEnum)[keyof typeof NewArrivalsOrderByRelevanceFieldEnum]


  export const NewsletterOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email'
  };

  export type NewsletterOrderByRelevanceFieldEnum = (typeof NewsletterOrderByRelevanceFieldEnum)[keyof typeof NewsletterOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    hyperLink: 'hyperLink',
    title: 'title'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const OrderDetailsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    discountId: 'discountId',
    orderId: 'orderId',
    notes: 'notes',
    trackingId: 'trackingId',
    addressId: 'addressId'
  };

  export type OrderDetailsOrderByRelevanceFieldEnum = (typeof OrderDetailsOrderByRelevanceFieldEnum)[keyof typeof OrderDetailsOrderByRelevanceFieldEnum]


  export const OrderItemOrderByRelevanceFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    sizeId: 'sizeId',
    colorId: 'colorId',
    imageId: 'imageId'
  };

  export type OrderItemOrderByRelevanceFieldEnum = (typeof OrderItemOrderByRelevanceFieldEnum)[keyof typeof OrderItemOrderByRelevanceFieldEnum]


  export const OtpOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code'
  };

  export type OtpOrderByRelevanceFieldEnum = (typeof OtpOrderByRelevanceFieldEnum)[keyof typeof OtpOrderByRelevanceFieldEnum]


  export const PaymentDetailsOrderByRelevanceFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    bank: 'bank',
    currency: 'currency',
    method: 'method',
    order_id: 'order_id',
    payment_id: 'payment_id',
    upi: 'upi',
    wallet: 'wallet'
  };

  export type PaymentDetailsOrderByRelevanceFieldEnum = (typeof PaymentDetailsOrderByRelevanceFieldEnum)[keyof typeof PaymentDetailsOrderByRelevanceFieldEnum]


  export const PrivilegeOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    label: 'label'
  };

  export type PrivilegeOrderByRelevanceFieldEnum = (typeof PrivilegeOrderByRelevanceFieldEnum)[keyof typeof PrivilegeOrderByRelevanceFieldEnum]


  export const ProductOrderByRelevanceFieldEnum: {
    id: 'id',
    slug: 'slug',
    thumbnailUrl: 'thumbnailUrl',
    description: 'description',
    summary: 'summary',
    customerTypeId: 'customerTypeId',
    userId: 'userId',
    styleId: 'styleId',
    title: 'title',
    returnPolicy: 'returnPolicy',
    longTailKeyword: 'longTailKeyword',
    affiliateId: 'affiliateId',
    ogImage: 'ogImage',
    sellerCode: 'sellerCode',
    sizeChartId: 'sizeChartId',
    fabricId: 'fabricId',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription'
  };

  export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]


  export const ProductCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription'
  };

  export type ProductCategoryOrderByRelevanceFieldEnum = (typeof ProductCategoryOrderByRelevanceFieldEnum)[keyof typeof ProductCategoryOrderByRelevanceFieldEnum]


  export const ProductColorOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    slug: 'slug'
  };

  export type ProductColorOrderByRelevanceFieldEnum = (typeof ProductColorOrderByRelevanceFieldEnum)[keyof typeof ProductColorOrderByRelevanceFieldEnum]


  export const ProductFabricOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type ProductFabricOrderByRelevanceFieldEnum = (typeof ProductFabricOrderByRelevanceFieldEnum)[keyof typeof ProductFabricOrderByRelevanceFieldEnum]


  export const ProductImageOrderByRelevanceFieldEnum: {
    id: 'id',
    productId: 'productId',
    imageUrl: 'imageUrl',
    colorId: 'colorId',
    altText: 'altText',
    caption: 'caption'
  };

  export type ProductImageOrderByRelevanceFieldEnum = (typeof ProductImageOrderByRelevanceFieldEnum)[keyof typeof ProductImageOrderByRelevanceFieldEnum]


  export const ProductInventoryOrderByRelevanceFieldEnum: {
    id: 'id',
    productId: 'productId',
    sizeId: 'sizeId'
  };

  export type ProductInventoryOrderByRelevanceFieldEnum = (typeof ProductInventoryOrderByRelevanceFieldEnum)[keyof typeof ProductInventoryOrderByRelevanceFieldEnum]


  export const ProductReviewOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    review: 'review'
  };

  export type ProductReviewOrderByRelevanceFieldEnum = (typeof ProductReviewOrderByRelevanceFieldEnum)[keyof typeof ProductReviewOrderByRelevanceFieldEnum]


  export const ProductSizeOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug'
  };

  export type ProductSizeOrderByRelevanceFieldEnum = (typeof ProductSizeOrderByRelevanceFieldEnum)[keyof typeof ProductSizeOrderByRelevanceFieldEnum]


  export const ProductWeekOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    hyperLink: 'hyperLink',
    imageUrl: 'imageUrl'
  };

  export type ProductWeekOrderByRelevanceFieldEnum = (typeof ProductWeekOrderByRelevanceFieldEnum)[keyof typeof ProductWeekOrderByRelevanceFieldEnum]


  export const QuotesOrderByRelevanceFieldEnum: {
    id: 'id',
    text: 'text',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    categoryId: 'categoryId'
  };

  export type QuotesOrderByRelevanceFieldEnum = (typeof QuotesOrderByRelevanceFieldEnum)[keyof typeof QuotesOrderByRelevanceFieldEnum]


  export const ReturnRequestOrderByRelevanceFieldEnum: {
    id: 'id',
    orderItemId: 'orderItemId',
    reason: 'reason'
  };

  export type ReturnRequestOrderByRelevanceFieldEnum = (typeof ReturnRequestOrderByRelevanceFieldEnum)[keyof typeof ReturnRequestOrderByRelevanceFieldEnum]


  export const RewardsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    code: 'code',
    description: 'description'
  };

  export type RewardsOrderByRelevanceFieldEnum = (typeof RewardsOrderByRelevanceFieldEnum)[keyof typeof RewardsOrderByRelevanceFieldEnum]


  export const SearchQueryOrderByRelevanceFieldEnum: {
    id: 'id',
    query: 'query',
    userId: 'userId'
  };

  export type SearchQueryOrderByRelevanceFieldEnum = (typeof SearchQueryOrderByRelevanceFieldEnum)[keyof typeof SearchQueryOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const ShopByOccasionOrderByRelevanceFieldEnum: {
    id: 'id',
    occasionName: 'occasionName',
    categoryHyperLinks: 'categoryHyperLinks'
  };

  export type ShopByOccasionOrderByRelevanceFieldEnum = (typeof ShopByOccasionOrderByRelevanceFieldEnum)[keyof typeof ShopByOccasionOrderByRelevanceFieldEnum]


  export const ShopByOccasionProductOrderByRelevanceFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    shopByOccasionId: 'shopByOccasionId'
  };

  export type ShopByOccasionProductOrderByRelevanceFieldEnum = (typeof ShopByOccasionProductOrderByRelevanceFieldEnum)[keyof typeof ShopByOccasionProductOrderByRelevanceFieldEnum]


  export const ShopBySeasonOrderByRelevanceFieldEnum: {
    id: 'id',
    videoUrl: 'videoUrl'
  };

  export type ShopBySeasonOrderByRelevanceFieldEnum = (typeof ShopBySeasonOrderByRelevanceFieldEnum)[keyof typeof ShopBySeasonOrderByRelevanceFieldEnum]


  export const ShopBySeasonProductOrderByRelevanceFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    description: 'description',
    seasonId: 'seasonId',
    hyperLink: 'hyperLink'
  };

  export type ShopBySeasonProductOrderByRelevanceFieldEnum = (typeof ShopBySeasonProductOrderByRelevanceFieldEnum)[keyof typeof ShopBySeasonProductOrderByRelevanceFieldEnum]


  export const ShowcasesOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink',
    categoryHyperLink: 'categoryHyperLink'
  };

  export type ShowcasesOrderByRelevanceFieldEnum = (typeof ShowcasesOrderByRelevanceFieldEnum)[keyof typeof ShowcasesOrderByRelevanceFieldEnum]


  export const SizeChartOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    imageUrl: 'imageUrl',
    productId: 'productId'
  };

  export type SizeChartOrderByRelevanceFieldEnum = (typeof SizeChartOrderByRelevanceFieldEnum)[keyof typeof SizeChartOrderByRelevanceFieldEnum]


  export const SocialLinksOrderByRelevanceFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    hyperLink: 'hyperLink'
  };

  export type SocialLinksOrderByRelevanceFieldEnum = (typeof SocialLinksOrderByRelevanceFieldEnum)[keyof typeof SocialLinksOrderByRelevanceFieldEnum]


  export const StaticMessagesOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message'
  };

  export type StaticMessagesOrderByRelevanceFieldEnum = (typeof StaticMessagesOrderByRelevanceFieldEnum)[keyof typeof StaticMessagesOrderByRelevanceFieldEnum]


  export const SubCategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    categoryId: 'categoryId',
    imageUrl: 'imageUrl',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription'
  };

  export type SubCategoryOrderByRelevanceFieldEnum = (typeof SubCategoryOrderByRelevanceFieldEnum)[keyof typeof SubCategoryOrderByRelevanceFieldEnum]


  export const SupportTicketOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    subject: 'subject',
    message: 'message'
  };

  export type SupportTicketOrderByRelevanceFieldEnum = (typeof SupportTicketOrderByRelevanceFieldEnum)[keyof typeof SupportTicketOrderByRelevanceFieldEnum]


  export const TagsOrderByRelevanceFieldEnum: {
    id: 'id',
    tag: 'tag'
  };

  export type TagsOrderByRelevanceFieldEnum = (typeof TagsOrderByRelevanceFieldEnum)[keyof typeof TagsOrderByRelevanceFieldEnum]


  export const TrendingOrderByRelevanceFieldEnum: {
    id: 'id',
    videoUrl: 'videoUrl',
    title: 'title',
    price: 'price',
    hyperLink: 'hyperLink',
    avatarUrl: 'avatarUrl'
  };

  export type TrendingOrderByRelevanceFieldEnum = (typeof TrendingOrderByRelevanceFieldEnum)[keyof typeof TrendingOrderByRelevanceFieldEnum]


  export const UpdateHistoryOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description'
  };

  export type UpdateHistoryOrderByRelevanceFieldEnum = (typeof UpdateHistoryOrderByRelevanceFieldEnum)[keyof typeof UpdateHistoryOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    profileUrl: 'profileUrl',
    mobileNumber: 'mobileNumber',
    whatsAppNumber: 'whatsAppNumber',
    assignedStaffId: 'assignedStaffId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const UserAddressOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    mobileNumber: 'mobileNumber',
    fullName: 'fullName',
    altMobileNumber: 'altMobileNumber'
  };

  export type UserAddressOrderByRelevanceFieldEnum = (typeof UserAddressOrderByRelevanceFieldEnum)[keyof typeof UserAddressOrderByRelevanceFieldEnum]


  export const UserPrivilegeOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    privilegeId: 'privilegeId'
  };

  export type UserPrivilegeOrderByRelevanceFieldEnum = (typeof UserPrivilegeOrderByRelevanceFieldEnum)[keyof typeof UserPrivilegeOrderByRelevanceFieldEnum]


  export const VidesOrderByRelevanceFieldEnum: {
    id: 'id',
    videoUrl: 'videoUrl',
    title: 'title',
    description: 'description',
    hyperLink: 'hyperLink',
    productId: 'productId'
  };

  export type VidesOrderByRelevanceFieldEnum = (typeof VidesOrderByRelevanceFieldEnum)[keyof typeof VidesOrderByRelevanceFieldEnum]


  export const VisitorOrderByRelevanceFieldEnum: {
    id: 'id',
    ipAddress: 'ipAddress',
    cookieId: 'cookieId'
  };

  export type VisitorOrderByRelevanceFieldEnum = (typeof VisitorOrderByRelevanceFieldEnum)[keyof typeof VisitorOrderByRelevanceFieldEnum]


  export const WishlistItemOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId'
  };

  export type WishlistItemOrderByRelevanceFieldEnum = (typeof WishlistItemOrderByRelevanceFieldEnum)[keyof typeof WishlistItemOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DeleteRequest_status'
   */
  export type EnumDeleteRequest_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeleteRequest_status'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Discount_type'
   */
  export type EnumDiscount_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Discount_type'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'OrderDetails_status'
   */
  export type EnumOrderDetails_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderDetails_status'>
    


  /**
   * Reference to a field of type 'OrderDetails_paymentMethod'
   */
  export type EnumOrderDetails_paymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderDetails_paymentMethod'>
    


  /**
   * Reference to a field of type 'ReturnRequest_status'
   */
  export type EnumReturnRequest_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnRequest_status'>
    


  /**
   * Reference to a field of type 'StaticMessages_status'
   */
  export type EnumStaticMessages_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaticMessages_status'>
    


  /**
   * Reference to a field of type 'SupportTicket_status'
   */
  export type EnumSupportTicket_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicket_status'>
    


  /**
   * Reference to a field of type 'User_role'
   */
  export type EnumUser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'User_role'>
    


  /**
   * Reference to a field of type 'User_status'
   */
  export type EnumUser_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'User_status'>
    
  /**
   * Deep Input Types
   */


  export type AnchorTextWhereInput = {
    AND?: AnchorTextWhereInput | AnchorTextWhereInput[]
    OR?: AnchorTextWhereInput[]
    NOT?: AnchorTextWhereInput | AnchorTextWhereInput[]
    id?: StringFilter<"AnchorText"> | string
    categoryId?: StringFilter<"AnchorText"> | string
    data?: StringFilter<"AnchorText"> | string
    createdAt?: DateTimeFilter<"AnchorText"> | Date | string
    updatedAt?: DateTimeFilter<"AnchorText"> | Date | string
    ProductCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }

  export type AnchorTextOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ProductCategory?: ProductCategoryOrderByWithRelationInput
    _relevance?: AnchorTextOrderByRelevanceInput
  }

  export type AnchorTextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    categoryId?: string
    AND?: AnchorTextWhereInput | AnchorTextWhereInput[]
    OR?: AnchorTextWhereInput[]
    NOT?: AnchorTextWhereInput | AnchorTextWhereInput[]
    data?: StringFilter<"AnchorText"> | string
    createdAt?: DateTimeFilter<"AnchorText"> | Date | string
    updatedAt?: DateTimeFilter<"AnchorText"> | Date | string
    ProductCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }, "id" | "categoryId">

  export type AnchorTextOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnchorTextCountOrderByAggregateInput
    _max?: AnchorTextMaxOrderByAggregateInput
    _min?: AnchorTextMinOrderByAggregateInput
  }

  export type AnchorTextScalarWhereWithAggregatesInput = {
    AND?: AnchorTextScalarWhereWithAggregatesInput | AnchorTextScalarWhereWithAggregatesInput[]
    OR?: AnchorTextScalarWhereWithAggregatesInput[]
    NOT?: AnchorTextScalarWhereWithAggregatesInput | AnchorTextScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnchorText"> | string
    categoryId?: StringWithAggregatesFilter<"AnchorText"> | string
    data?: StringWithAggregatesFilter<"AnchorText"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AnchorText"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnchorText"> | Date | string
  }

  export type AnnouncementsWhereInput = {
    AND?: AnnouncementsWhereInput | AnnouncementsWhereInput[]
    OR?: AnnouncementsWhereInput[]
    NOT?: AnnouncementsWhereInput | AnnouncementsWhereInput[]
    id?: StringFilter<"Announcements"> | string
    text?: StringNullableFilter<"Announcements"> | string | null
  }

  export type AnnouncementsOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrderInput | SortOrder
    _relevance?: AnnouncementsOrderByRelevanceInput
  }

  export type AnnouncementsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementsWhereInput | AnnouncementsWhereInput[]
    OR?: AnnouncementsWhereInput[]
    NOT?: AnnouncementsWhereInput | AnnouncementsWhereInput[]
    text?: StringNullableFilter<"Announcements"> | string | null
  }, "id">

  export type AnnouncementsOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrderInput | SortOrder
    _count?: AnnouncementsCountOrderByAggregateInput
    _max?: AnnouncementsMaxOrderByAggregateInput
    _min?: AnnouncementsMinOrderByAggregateInput
  }

  export type AnnouncementsScalarWhereWithAggregatesInput = {
    AND?: AnnouncementsScalarWhereWithAggregatesInput | AnnouncementsScalarWhereWithAggregatesInput[]
    OR?: AnnouncementsScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementsScalarWhereWithAggregatesInput | AnnouncementsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcements"> | string
    text?: StringNullableWithAggregatesFilter<"Announcements"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    description?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: AuditLogOrderByRelevanceInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    description?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    description?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type BestSellingWhereInput = {
    AND?: BestSellingWhereInput | BestSellingWhereInput[]
    OR?: BestSellingWhereInput[]
    NOT?: BestSellingWhereInput | BestSellingWhereInput[]
    id?: StringFilter<"BestSelling"> | string
    title?: StringFilter<"BestSelling"> | string
    hyperLink?: StringFilter<"BestSelling"> | string
    price?: StringFilter<"BestSelling"> | string
  }

  export type BestSellingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrder
    _relevance?: BestSellingOrderByRelevanceInput
  }

  export type BestSellingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BestSellingWhereInput | BestSellingWhereInput[]
    OR?: BestSellingWhereInput[]
    NOT?: BestSellingWhereInput | BestSellingWhereInput[]
    title?: StringFilter<"BestSelling"> | string
    hyperLink?: StringFilter<"BestSelling"> | string
    price?: StringFilter<"BestSelling"> | string
  }, "id">

  export type BestSellingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrder
    _count?: BestSellingCountOrderByAggregateInput
    _max?: BestSellingMaxOrderByAggregateInput
    _min?: BestSellingMinOrderByAggregateInput
  }

  export type BestSellingScalarWhereWithAggregatesInput = {
    AND?: BestSellingScalarWhereWithAggregatesInput | BestSellingScalarWhereWithAggregatesInput[]
    OR?: BestSellingScalarWhereWithAggregatesInput[]
    NOT?: BestSellingScalarWhereWithAggregatesInput | BestSellingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BestSelling"> | string
    title?: StringWithAggregatesFilter<"BestSelling"> | string
    hyperLink?: StringWithAggregatesFilter<"BestSelling"> | string
    price?: StringWithAggregatesFilter<"BestSelling"> | string
  }

  export type CallRequestWhereInput = {
    AND?: CallRequestWhereInput | CallRequestWhereInput[]
    OR?: CallRequestWhereInput[]
    NOT?: CallRequestWhereInput | CallRequestWhereInput[]
    id?: StringFilter<"CallRequest"> | string
    mobileNumber?: StringFilter<"CallRequest"> | string
    orderId?: StringNullableFilter<"CallRequest"> | string | null
    isRead?: BoolFilter<"CallRequest"> | boolean
    createdAt?: DateTimeFilter<"CallRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CallRequest"> | Date | string
  }

  export type CallRequestOrderByWithRelationInput = {
    id?: SortOrder
    mobileNumber?: SortOrder
    orderId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CallRequestOrderByRelevanceInput
  }

  export type CallRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CallRequestWhereInput | CallRequestWhereInput[]
    OR?: CallRequestWhereInput[]
    NOT?: CallRequestWhereInput | CallRequestWhereInput[]
    mobileNumber?: StringFilter<"CallRequest"> | string
    orderId?: StringNullableFilter<"CallRequest"> | string | null
    isRead?: BoolFilter<"CallRequest"> | boolean
    createdAt?: DateTimeFilter<"CallRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CallRequest"> | Date | string
  }, "id">

  export type CallRequestOrderByWithAggregationInput = {
    id?: SortOrder
    mobileNumber?: SortOrder
    orderId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CallRequestCountOrderByAggregateInput
    _max?: CallRequestMaxOrderByAggregateInput
    _min?: CallRequestMinOrderByAggregateInput
  }

  export type CallRequestScalarWhereWithAggregatesInput = {
    AND?: CallRequestScalarWhereWithAggregatesInput | CallRequestScalarWhereWithAggregatesInput[]
    OR?: CallRequestScalarWhereWithAggregatesInput[]
    NOT?: CallRequestScalarWhereWithAggregatesInput | CallRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallRequest"> | string
    mobileNumber?: StringWithAggregatesFilter<"CallRequest"> | string
    orderId?: StringNullableWithAggregatesFilter<"CallRequest"> | string | null
    isRead?: BoolWithAggregatesFilter<"CallRequest"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CallRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CallRequest"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    userId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    colorId?: StringNullableFilter<"CartItem"> | string | null
    sizeId?: StringNullableFilter<"CartItem"> | string | null
    imageId?: StringNullableFilter<"CartItem"> | string | null
    ProductColor?: XOR<ProductColorNullableScalarRelationFilter, ProductColorWhereInput> | null
    ProductImage?: XOR<ProductImageNullableScalarRelationFilter, ProductImageWhereInput> | null
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    colorId?: SortOrderInput | SortOrder
    sizeId?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    ProductColor?: ProductColorOrderByWithRelationInput
    ProductImage?: ProductImageOrderByWithRelationInput
    Product?: ProductOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: CartItemOrderByRelevanceInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    userId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    colorId?: StringNullableFilter<"CartItem"> | string | null
    sizeId?: StringNullableFilter<"CartItem"> | string | null
    imageId?: StringNullableFilter<"CartItem"> | string | null
    ProductColor?: XOR<ProductColorNullableScalarRelationFilter, ProductColorWhereInput> | null
    ProductImage?: XOR<ProductImageNullableScalarRelationFilter, ProductImageWhereInput> | null
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    colorId?: SortOrderInput | SortOrder
    sizeId?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    userId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringWithAggregatesFilter<"CartItem"> | string
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    colorId?: StringNullableWithAggregatesFilter<"CartItem"> | string | null
    sizeId?: StringNullableWithAggregatesFilter<"CartItem"> | string | null
    imageId?: StringNullableWithAggregatesFilter<"CartItem"> | string | null
  }

  export type ContactUsWhereInput = {
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    id?: StringFilter<"ContactUs"> | string
    name?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    message?: StringFilter<"ContactUs"> | string
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeFilter<"ContactUs"> | Date | string
  }

  export type ContactUsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ContactUsOrderByRelevanceInput
  }

  export type ContactUsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactUsWhereInput | ContactUsWhereInput[]
    OR?: ContactUsWhereInput[]
    NOT?: ContactUsWhereInput | ContactUsWhereInput[]
    name?: StringFilter<"ContactUs"> | string
    email?: StringFilter<"ContactUs"> | string
    message?: StringFilter<"ContactUs"> | string
    createdAt?: DateTimeFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeFilter<"ContactUs"> | Date | string
  }, "id">

  export type ContactUsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactUsCountOrderByAggregateInput
    _max?: ContactUsMaxOrderByAggregateInput
    _min?: ContactUsMinOrderByAggregateInput
  }

  export type ContactUsScalarWhereWithAggregatesInput = {
    AND?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    OR?: ContactUsScalarWhereWithAggregatesInput[]
    NOT?: ContactUsScalarWhereWithAggregatesInput | ContactUsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactUs"> | string
    name?: StringWithAggregatesFilter<"ContactUs"> | string
    email?: StringWithAggregatesFilter<"ContactUs"> | string
    message?: StringWithAggregatesFilter<"ContactUs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactUs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactUs"> | Date | string
  }

  export type CustomerTypeWhereInput = {
    AND?: CustomerTypeWhereInput | CustomerTypeWhereInput[]
    OR?: CustomerTypeWhereInput[]
    NOT?: CustomerTypeWhereInput | CustomerTypeWhereInput[]
    id?: StringFilter<"CustomerType"> | string
    name?: StringFilter<"CustomerType"> | string
    slug?: StringFilter<"CustomerType"> | string
    productId?: StringNullableFilter<"CustomerType"> | string | null
    Product?: ProductListRelationFilter
  }

  export type CustomerTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByRelationAggregateInput
    _relevance?: CustomerTypeOrderByRelevanceInput
  }

  export type CustomerTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CustomerTypeWhereInput | CustomerTypeWhereInput[]
    OR?: CustomerTypeWhereInput[]
    NOT?: CustomerTypeWhereInput | CustomerTypeWhereInput[]
    name?: StringFilter<"CustomerType"> | string
    productId?: StringNullableFilter<"CustomerType"> | string | null
    Product?: ProductListRelationFilter
  }, "id" | "slug">

  export type CustomerTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: CustomerTypeCountOrderByAggregateInput
    _max?: CustomerTypeMaxOrderByAggregateInput
    _min?: CustomerTypeMinOrderByAggregateInput
  }

  export type CustomerTypeScalarWhereWithAggregatesInput = {
    AND?: CustomerTypeScalarWhereWithAggregatesInput | CustomerTypeScalarWhereWithAggregatesInput[]
    OR?: CustomerTypeScalarWhereWithAggregatesInput[]
    NOT?: CustomerTypeScalarWhereWithAggregatesInput | CustomerTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerType"> | string
    name?: StringWithAggregatesFilter<"CustomerType"> | string
    slug?: StringWithAggregatesFilter<"CustomerType"> | string
    productId?: StringNullableWithAggregatesFilter<"CustomerType"> | string | null
  }

  export type DeleteRequestWhereInput = {
    AND?: DeleteRequestWhereInput | DeleteRequestWhereInput[]
    OR?: DeleteRequestWhereInput[]
    NOT?: DeleteRequestWhereInput | DeleteRequestWhereInput[]
    id?: StringFilter<"DeleteRequest"> | string
    userId?: StringNullableFilter<"DeleteRequest"> | string | null
    userName?: StringNullableFilter<"DeleteRequest"> | string | null
    userEmail?: StringNullableFilter<"DeleteRequest"> | string | null
    reason?: StringNullableFilter<"DeleteRequest"> | string | null
    status?: EnumDeleteRequest_statusFilter<"DeleteRequest"> | $Enums.DeleteRequest_status
    createdAt?: DateTimeFilter<"DeleteRequest"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DeleteRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: DeleteRequestOrderByRelevanceInput
  }

  export type DeleteRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeleteRequestWhereInput | DeleteRequestWhereInput[]
    OR?: DeleteRequestWhereInput[]
    NOT?: DeleteRequestWhereInput | DeleteRequestWhereInput[]
    userId?: StringNullableFilter<"DeleteRequest"> | string | null
    userName?: StringNullableFilter<"DeleteRequest"> | string | null
    userEmail?: StringNullableFilter<"DeleteRequest"> | string | null
    reason?: StringNullableFilter<"DeleteRequest"> | string | null
    status?: EnumDeleteRequest_statusFilter<"DeleteRequest"> | $Enums.DeleteRequest_status
    createdAt?: DateTimeFilter<"DeleteRequest"> | Date | string
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DeleteRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: DeleteRequestCountOrderByAggregateInput
    _max?: DeleteRequestMaxOrderByAggregateInput
    _min?: DeleteRequestMinOrderByAggregateInput
  }

  export type DeleteRequestScalarWhereWithAggregatesInput = {
    AND?: DeleteRequestScalarWhereWithAggregatesInput | DeleteRequestScalarWhereWithAggregatesInput[]
    OR?: DeleteRequestScalarWhereWithAggregatesInput[]
    NOT?: DeleteRequestScalarWhereWithAggregatesInput | DeleteRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeleteRequest"> | string
    userId?: StringNullableWithAggregatesFilter<"DeleteRequest"> | string | null
    userName?: StringNullableWithAggregatesFilter<"DeleteRequest"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"DeleteRequest"> | string | null
    reason?: StringNullableWithAggregatesFilter<"DeleteRequest"> | string | null
    status?: EnumDeleteRequest_statusWithAggregatesFilter<"DeleteRequest"> | $Enums.DeleteRequest_status
    createdAt?: DateTimeWithAggregatesFilter<"DeleteRequest"> | Date | string
  }

  export type DiscountWhereInput = {
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    id?: StringFilter<"Discount"> | string
    code?: StringFilter<"Discount"> | string
    description?: StringNullableFilter<"Discount"> | string | null
    amount?: FloatFilter<"Discount"> | number
    type?: EnumDiscount_typeFilter<"Discount"> | $Enums.Discount_type
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    productId?: StringNullableFilter<"Discount"> | string | null
    maxPrice?: FloatNullableFilter<"Discount"> | number | null
    minPrice?: FloatNullableFilter<"Discount"> | number | null
    isActive?: BoolFilter<"Discount"> | boolean
    isSpecial?: BoolFilter<"Discount"> | boolean
    orders?: IntNullableFilter<"Discount"> | number | null
    userEmails?: JsonFilter<"Discount">
    isWebAvailable?: BoolFilter<"Discount"> | boolean
    isCODAvailable?: BoolFilter<"Discount"> | boolean
    Product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    OrderDetails?: OrderDetailsListRelationFilter
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    minPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    orders?: SortOrderInput | SortOrder
    userEmails?: SortOrder
    isWebAvailable?: SortOrder
    isCODAvailable?: SortOrder
    Product?: ProductOrderByWithRelationInput
    OrderDetails?: OrderDetailsOrderByRelationAggregateInput
    _relevance?: DiscountOrderByRelevanceInput
  }

  export type DiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    description?: StringNullableFilter<"Discount"> | string | null
    amount?: FloatFilter<"Discount"> | number
    type?: EnumDiscount_typeFilter<"Discount"> | $Enums.Discount_type
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    productId?: StringNullableFilter<"Discount"> | string | null
    maxPrice?: FloatNullableFilter<"Discount"> | number | null
    minPrice?: FloatNullableFilter<"Discount"> | number | null
    isActive?: BoolFilter<"Discount"> | boolean
    isSpecial?: BoolFilter<"Discount"> | boolean
    orders?: IntNullableFilter<"Discount"> | number | null
    userEmails?: JsonFilter<"Discount">
    isWebAvailable?: BoolFilter<"Discount"> | boolean
    isCODAvailable?: BoolFilter<"Discount"> | boolean
    Product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    OrderDetails?: OrderDetailsListRelationFilter
  }, "id" | "code">

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    minPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    orders?: SortOrderInput | SortOrder
    userEmails?: SortOrder
    isWebAvailable?: SortOrder
    isCODAvailable?: SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _avg?: DiscountAvgOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
    _sum?: DiscountSumOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    OR?: DiscountScalarWhereWithAggregatesInput[]
    NOT?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discount"> | string
    code?: StringWithAggregatesFilter<"Discount"> | string
    description?: StringNullableWithAggregatesFilter<"Discount"> | string | null
    amount?: FloatWithAggregatesFilter<"Discount"> | number
    type?: EnumDiscount_typeWithAggregatesFilter<"Discount"> | $Enums.Discount_type
    createdAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    productId?: StringNullableWithAggregatesFilter<"Discount"> | string | null
    maxPrice?: FloatNullableWithAggregatesFilter<"Discount"> | number | null
    minPrice?: FloatNullableWithAggregatesFilter<"Discount"> | number | null
    isActive?: BoolWithAggregatesFilter<"Discount"> | boolean
    isSpecial?: BoolWithAggregatesFilter<"Discount"> | boolean
    orders?: IntNullableWithAggregatesFilter<"Discount"> | number | null
    userEmails?: JsonWithAggregatesFilter<"Discount">
    isWebAvailable?: BoolWithAggregatesFilter<"Discount"> | boolean
    isCODAvailable?: BoolWithAggregatesFilter<"Discount"> | boolean
  }

  export type DropMessageWhereInput = {
    AND?: DropMessageWhereInput | DropMessageWhereInput[]
    OR?: DropMessageWhereInput[]
    NOT?: DropMessageWhereInput | DropMessageWhereInput[]
    id?: StringFilter<"DropMessage"> | string
    userId?: StringFilter<"DropMessage"> | string
    startedAt?: DateTimeNullableFilter<"DropMessage"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"DropMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"DropMessage"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DropMessageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: DropMessageOrderByRelevanceInput
  }

  export type DropMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DropMessageWhereInput | DropMessageWhereInput[]
    OR?: DropMessageWhereInput[]
    NOT?: DropMessageWhereInput | DropMessageWhereInput[]
    userId?: StringFilter<"DropMessage"> | string
    startedAt?: DateTimeNullableFilter<"DropMessage"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"DropMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"DropMessage"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DropMessageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DropMessageCountOrderByAggregateInput
    _max?: DropMessageMaxOrderByAggregateInput
    _min?: DropMessageMinOrderByAggregateInput
  }

  export type DropMessageScalarWhereWithAggregatesInput = {
    AND?: DropMessageScalarWhereWithAggregatesInput | DropMessageScalarWhereWithAggregatesInput[]
    OR?: DropMessageScalarWhereWithAggregatesInput[]
    NOT?: DropMessageScalarWhereWithAggregatesInput | DropMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DropMessage"> | string
    userId?: StringWithAggregatesFilter<"DropMessage"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"DropMessage"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"DropMessage"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DropMessage"> | Date | string
  }

  export type ExclusiveCollectionWhereInput = {
    AND?: ExclusiveCollectionWhereInput | ExclusiveCollectionWhereInput[]
    OR?: ExclusiveCollectionWhereInput[]
    NOT?: ExclusiveCollectionWhereInput | ExclusiveCollectionWhereInput[]
    id?: StringFilter<"ExclusiveCollection"> | string
    imageUrl?: StringNullableFilter<"ExclusiveCollection"> | string | null
    hyperLink?: StringNullableFilter<"ExclusiveCollection"> | string | null
    categoryHyperLink?: StringNullableFilter<"ExclusiveCollection"> | string | null
    createdAt?: DateTimeFilter<"ExclusiveCollection"> | Date | string
    updatedAt?: DateTimeFilter<"ExclusiveCollection"> | Date | string
    mrp?: FloatNullableFilter<"ExclusiveCollection"> | number | null
    price?: FloatNullableFilter<"ExclusiveCollection"> | number | null
  }

  export type ExclusiveCollectionOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    categoryHyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mrp?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    _relevance?: ExclusiveCollectionOrderByRelevanceInput
  }

  export type ExclusiveCollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExclusiveCollectionWhereInput | ExclusiveCollectionWhereInput[]
    OR?: ExclusiveCollectionWhereInput[]
    NOT?: ExclusiveCollectionWhereInput | ExclusiveCollectionWhereInput[]
    imageUrl?: StringNullableFilter<"ExclusiveCollection"> | string | null
    hyperLink?: StringNullableFilter<"ExclusiveCollection"> | string | null
    categoryHyperLink?: StringNullableFilter<"ExclusiveCollection"> | string | null
    createdAt?: DateTimeFilter<"ExclusiveCollection"> | Date | string
    updatedAt?: DateTimeFilter<"ExclusiveCollection"> | Date | string
    mrp?: FloatNullableFilter<"ExclusiveCollection"> | number | null
    price?: FloatNullableFilter<"ExclusiveCollection"> | number | null
  }, "id">

  export type ExclusiveCollectionOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    categoryHyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mrp?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    _count?: ExclusiveCollectionCountOrderByAggregateInput
    _avg?: ExclusiveCollectionAvgOrderByAggregateInput
    _max?: ExclusiveCollectionMaxOrderByAggregateInput
    _min?: ExclusiveCollectionMinOrderByAggregateInput
    _sum?: ExclusiveCollectionSumOrderByAggregateInput
  }

  export type ExclusiveCollectionScalarWhereWithAggregatesInput = {
    AND?: ExclusiveCollectionScalarWhereWithAggregatesInput | ExclusiveCollectionScalarWhereWithAggregatesInput[]
    OR?: ExclusiveCollectionScalarWhereWithAggregatesInput[]
    NOT?: ExclusiveCollectionScalarWhereWithAggregatesInput | ExclusiveCollectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExclusiveCollection"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"ExclusiveCollection"> | string | null
    hyperLink?: StringNullableWithAggregatesFilter<"ExclusiveCollection"> | string | null
    categoryHyperLink?: StringNullableWithAggregatesFilter<"ExclusiveCollection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExclusiveCollection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExclusiveCollection"> | Date | string
    mrp?: FloatNullableWithAggregatesFilter<"ExclusiveCollection"> | number | null
    price?: FloatNullableWithAggregatesFilter<"ExclusiveCollection"> | number | null
  }

  export type HeroSlidersWhereInput = {
    AND?: HeroSlidersWhereInput | HeroSlidersWhereInput[]
    OR?: HeroSlidersWhereInput[]
    NOT?: HeroSlidersWhereInput | HeroSlidersWhereInput[]
    id?: StringFilter<"HeroSliders"> | string
    imageUrl?: StringFilter<"HeroSliders"> | string
    hyperLink?: StringFilter<"HeroSliders"> | string
    categoryHyperLink?: StringNullableFilter<"HeroSliders"> | string | null
    createdAt?: DateTimeFilter<"HeroSliders"> | Date | string
    updatedAt?: DateTimeFilter<"HeroSliders"> | Date | string
  }

  export type HeroSlidersOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: HeroSlidersOrderByRelevanceInput
  }

  export type HeroSlidersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HeroSlidersWhereInput | HeroSlidersWhereInput[]
    OR?: HeroSlidersWhereInput[]
    NOT?: HeroSlidersWhereInput | HeroSlidersWhereInput[]
    imageUrl?: StringFilter<"HeroSliders"> | string
    hyperLink?: StringFilter<"HeroSliders"> | string
    categoryHyperLink?: StringNullableFilter<"HeroSliders"> | string | null
    createdAt?: DateTimeFilter<"HeroSliders"> | Date | string
    updatedAt?: DateTimeFilter<"HeroSliders"> | Date | string
  }, "id">

  export type HeroSlidersOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HeroSlidersCountOrderByAggregateInput
    _max?: HeroSlidersMaxOrderByAggregateInput
    _min?: HeroSlidersMinOrderByAggregateInput
  }

  export type HeroSlidersScalarWhereWithAggregatesInput = {
    AND?: HeroSlidersScalarWhereWithAggregatesInput | HeroSlidersScalarWhereWithAggregatesInput[]
    OR?: HeroSlidersScalarWhereWithAggregatesInput[]
    NOT?: HeroSlidersScalarWhereWithAggregatesInput | HeroSlidersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HeroSliders"> | string
    imageUrl?: StringWithAggregatesFilter<"HeroSliders"> | string
    hyperLink?: StringWithAggregatesFilter<"HeroSliders"> | string
    categoryHyperLink?: StringNullableWithAggregatesFilter<"HeroSliders"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HeroSliders"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HeroSliders"> | Date | string
  }

  export type ImageWeekWhereInput = {
    AND?: ImageWeekWhereInput | ImageWeekWhereInput[]
    OR?: ImageWeekWhereInput[]
    NOT?: ImageWeekWhereInput | ImageWeekWhereInput[]
    id?: StringFilter<"ImageWeek"> | string
    hyperLink?: StringNullableFilter<"ImageWeek"> | string | null
    imageUrl?: StringNullableFilter<"ImageWeek"> | string | null
  }

  export type ImageWeekOrderByWithRelationInput = {
    id?: SortOrder
    hyperLink?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _relevance?: ImageWeekOrderByRelevanceInput
  }

  export type ImageWeekWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImageWeekWhereInput | ImageWeekWhereInput[]
    OR?: ImageWeekWhereInput[]
    NOT?: ImageWeekWhereInput | ImageWeekWhereInput[]
    hyperLink?: StringNullableFilter<"ImageWeek"> | string | null
    imageUrl?: StringNullableFilter<"ImageWeek"> | string | null
  }, "id">

  export type ImageWeekOrderByWithAggregationInput = {
    id?: SortOrder
    hyperLink?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _count?: ImageWeekCountOrderByAggregateInput
    _max?: ImageWeekMaxOrderByAggregateInput
    _min?: ImageWeekMinOrderByAggregateInput
  }

  export type ImageWeekScalarWhereWithAggregatesInput = {
    AND?: ImageWeekScalarWhereWithAggregatesInput | ImageWeekScalarWhereWithAggregatesInput[]
    OR?: ImageWeekScalarWhereWithAggregatesInput[]
    NOT?: ImageWeekScalarWhereWithAggregatesInput | ImageWeekScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImageWeek"> | string
    hyperLink?: StringNullableWithAggregatesFilter<"ImageWeek"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"ImageWeek"> | string | null
  }

  export type LogosWhereInput = {
    AND?: LogosWhereInput | LogosWhereInput[]
    OR?: LogosWhereInput[]
    NOT?: LogosWhereInput | LogosWhereInput[]
    id?: StringFilter<"Logos"> | string
    logoUrl?: StringFilter<"Logos"> | string
    isActive?: BoolFilter<"Logos"> | boolean
    altText?: StringNullableFilter<"Logos"> | string | null
  }

  export type LogosOrderByWithRelationInput = {
    id?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    altText?: SortOrderInput | SortOrder
    _relevance?: LogosOrderByRelevanceInput
  }

  export type LogosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogosWhereInput | LogosWhereInput[]
    OR?: LogosWhereInput[]
    NOT?: LogosWhereInput | LogosWhereInput[]
    logoUrl?: StringFilter<"Logos"> | string
    isActive?: BoolFilter<"Logos"> | boolean
    altText?: StringNullableFilter<"Logos"> | string | null
  }, "id">

  export type LogosOrderByWithAggregationInput = {
    id?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    altText?: SortOrderInput | SortOrder
    _count?: LogosCountOrderByAggregateInput
    _max?: LogosMaxOrderByAggregateInput
    _min?: LogosMinOrderByAggregateInput
  }

  export type LogosScalarWhereWithAggregatesInput = {
    AND?: LogosScalarWhereWithAggregatesInput | LogosScalarWhereWithAggregatesInput[]
    OR?: LogosScalarWhereWithAggregatesInput[]
    NOT?: LogosScalarWhereWithAggregatesInput | LogosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Logos"> | string
    logoUrl?: StringWithAggregatesFilter<"Logos"> | string
    isActive?: BoolWithAggregatesFilter<"Logos"> | boolean
    altText?: StringNullableWithAggregatesFilter<"Logos"> | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    message?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    handledById?: StringNullableFilter<"Message"> | string | null
    User_Message_handledByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    User_Message_receiverIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    User_Message_senderIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    handledById?: SortOrderInput | SortOrder
    User_Message_handledByIdToUser?: UserOrderByWithRelationInput
    User_Message_receiverIdToUser?: UserOrderByWithRelationInput
    User_Message_senderIdToUser?: UserOrderByWithRelationInput
    _relevance?: MessageOrderByRelevanceInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    message?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    handledById?: StringNullableFilter<"Message"> | string | null
    User_Message_handledByIdToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    User_Message_receiverIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    User_Message_senderIdToUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    handledById?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
    message?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    handledById?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type NewArrivalsWhereInput = {
    AND?: NewArrivalsWhereInput | NewArrivalsWhereInput[]
    OR?: NewArrivalsWhereInput[]
    NOT?: NewArrivalsWhereInput | NewArrivalsWhereInput[]
    id?: StringFilter<"NewArrivals"> | string
    imageUrl?: StringNullableFilter<"NewArrivals"> | string | null
    hyperLink?: StringNullableFilter<"NewArrivals"> | string | null
    createdAt?: DateTimeFilter<"NewArrivals"> | Date | string
    updatedAt?: DateTimeFilter<"NewArrivals"> | Date | string
    description?: StringNullableFilter<"NewArrivals"> | string | null
    mrp?: FloatNullableFilter<"NewArrivals"> | number | null
    price?: FloatNullableFilter<"NewArrivals"> | number | null
    title?: StringNullableFilter<"NewArrivals"> | string | null
  }

  export type NewArrivalsOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    mrp?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    _relevance?: NewArrivalsOrderByRelevanceInput
  }

  export type NewArrivalsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewArrivalsWhereInput | NewArrivalsWhereInput[]
    OR?: NewArrivalsWhereInput[]
    NOT?: NewArrivalsWhereInput | NewArrivalsWhereInput[]
    imageUrl?: StringNullableFilter<"NewArrivals"> | string | null
    hyperLink?: StringNullableFilter<"NewArrivals"> | string | null
    createdAt?: DateTimeFilter<"NewArrivals"> | Date | string
    updatedAt?: DateTimeFilter<"NewArrivals"> | Date | string
    description?: StringNullableFilter<"NewArrivals"> | string | null
    mrp?: FloatNullableFilter<"NewArrivals"> | number | null
    price?: FloatNullableFilter<"NewArrivals"> | number | null
    title?: StringNullableFilter<"NewArrivals"> | string | null
  }, "id">

  export type NewArrivalsOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    mrp?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    _count?: NewArrivalsCountOrderByAggregateInput
    _avg?: NewArrivalsAvgOrderByAggregateInput
    _max?: NewArrivalsMaxOrderByAggregateInput
    _min?: NewArrivalsMinOrderByAggregateInput
    _sum?: NewArrivalsSumOrderByAggregateInput
  }

  export type NewArrivalsScalarWhereWithAggregatesInput = {
    AND?: NewArrivalsScalarWhereWithAggregatesInput | NewArrivalsScalarWhereWithAggregatesInput[]
    OR?: NewArrivalsScalarWhereWithAggregatesInput[]
    NOT?: NewArrivalsScalarWhereWithAggregatesInput | NewArrivalsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewArrivals"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"NewArrivals"> | string | null
    hyperLink?: StringNullableWithAggregatesFilter<"NewArrivals"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NewArrivals"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NewArrivals"> | Date | string
    description?: StringNullableWithAggregatesFilter<"NewArrivals"> | string | null
    mrp?: FloatNullableWithAggregatesFilter<"NewArrivals"> | number | null
    price?: FloatNullableWithAggregatesFilter<"NewArrivals"> | number | null
    title?: StringNullableWithAggregatesFilter<"NewArrivals"> | string | null
  }

  export type NewsletterWhereInput = {
    AND?: NewsletterWhereInput | NewsletterWhereInput[]
    OR?: NewsletterWhereInput[]
    NOT?: NewsletterWhereInput | NewsletterWhereInput[]
    id?: StringFilter<"Newsletter"> | string
    email?: StringFilter<"Newsletter"> | string
    createdAt?: DateTimeFilter<"Newsletter"> | Date | string
    updatedAt?: DateTimeFilter<"Newsletter"> | Date | string
  }

  export type NewsletterOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: NewsletterOrderByRelevanceInput
  }

  export type NewsletterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NewsletterWhereInput | NewsletterWhereInput[]
    OR?: NewsletterWhereInput[]
    NOT?: NewsletterWhereInput | NewsletterWhereInput[]
    email?: StringFilter<"Newsletter"> | string
    createdAt?: DateTimeFilter<"Newsletter"> | Date | string
    updatedAt?: DateTimeFilter<"Newsletter"> | Date | string
  }, "id">

  export type NewsletterOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsletterCountOrderByAggregateInput
    _max?: NewsletterMaxOrderByAggregateInput
    _min?: NewsletterMinOrderByAggregateInput
  }

  export type NewsletterScalarWhereWithAggregatesInput = {
    AND?: NewsletterScalarWhereWithAggregatesInput | NewsletterScalarWhereWithAggregatesInput[]
    OR?: NewsletterScalarWhereWithAggregatesInput[]
    NOT?: NewsletterScalarWhereWithAggregatesInput | NewsletterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Newsletter"> | string
    email?: StringWithAggregatesFilter<"Newsletter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Newsletter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Newsletter"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    hyperLink?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    hyperLink?: SortOrderInput | SortOrder
    title?: SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    hyperLink?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    hyperLink?: SortOrderInput | SortOrder
    title?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    hyperLink?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type OrderDetailsWhereInput = {
    AND?: OrderDetailsWhereInput | OrderDetailsWhereInput[]
    OR?: OrderDetailsWhereInput[]
    NOT?: OrderDetailsWhereInput | OrderDetailsWhereInput[]
    id?: StringFilter<"OrderDetails"> | string
    userId?: StringFilter<"OrderDetails"> | string
    totalPrice?: FloatFilter<"OrderDetails"> | number
    status?: EnumOrderDetails_statusFilter<"OrderDetails"> | $Enums.OrderDetails_status
    createdAt?: DateTimeFilter<"OrderDetails"> | Date | string
    updatedAt?: DateTimeFilter<"OrderDetails"> | Date | string
    discountId?: StringNullableFilter<"OrderDetails"> | string | null
    orderId?: StringFilter<"OrderDetails"> | string
    paymentMethod?: EnumOrderDetails_paymentMethodNullableFilter<"OrderDetails"> | $Enums.OrderDetails_paymentMethod | null
    notes?: StringNullableFilter<"OrderDetails"> | string | null
    trackingId?: StringNullableFilter<"OrderDetails"> | string | null
    addressId?: StringNullableFilter<"OrderDetails"> | string | null
    finalPrice?: FloatNullableFilter<"OrderDetails"> | number | null
    UserAddress?: XOR<UserAddressNullableScalarRelationFilter, UserAddressWhereInput> | null
    Discount?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    OrderItem?: OrderItemListRelationFilter
    PaymentDetails?: PaymentDetailsListRelationFilter
  }

  export type OrderDetailsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discountId?: SortOrderInput | SortOrder
    orderId?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    trackingId?: SortOrderInput | SortOrder
    addressId?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    UserAddress?: UserAddressOrderByWithRelationInput
    Discount?: DiscountOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    OrderItem?: OrderItemOrderByRelationAggregateInput
    PaymentDetails?: PaymentDetailsOrderByRelationAggregateInput
    _relevance?: OrderDetailsOrderByRelevanceInput
  }

  export type OrderDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: OrderDetailsWhereInput | OrderDetailsWhereInput[]
    OR?: OrderDetailsWhereInput[]
    NOT?: OrderDetailsWhereInput | OrderDetailsWhereInput[]
    userId?: StringFilter<"OrderDetails"> | string
    totalPrice?: FloatFilter<"OrderDetails"> | number
    status?: EnumOrderDetails_statusFilter<"OrderDetails"> | $Enums.OrderDetails_status
    createdAt?: DateTimeFilter<"OrderDetails"> | Date | string
    updatedAt?: DateTimeFilter<"OrderDetails"> | Date | string
    discountId?: StringNullableFilter<"OrderDetails"> | string | null
    paymentMethod?: EnumOrderDetails_paymentMethodNullableFilter<"OrderDetails"> | $Enums.OrderDetails_paymentMethod | null
    notes?: StringNullableFilter<"OrderDetails"> | string | null
    trackingId?: StringNullableFilter<"OrderDetails"> | string | null
    addressId?: StringNullableFilter<"OrderDetails"> | string | null
    finalPrice?: FloatNullableFilter<"OrderDetails"> | number | null
    UserAddress?: XOR<UserAddressNullableScalarRelationFilter, UserAddressWhereInput> | null
    Discount?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    OrderItem?: OrderItemListRelationFilter
    PaymentDetails?: PaymentDetailsListRelationFilter
  }, "id" | "orderId">

  export type OrderDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discountId?: SortOrderInput | SortOrder
    orderId?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    trackingId?: SortOrderInput | SortOrder
    addressId?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    _count?: OrderDetailsCountOrderByAggregateInput
    _avg?: OrderDetailsAvgOrderByAggregateInput
    _max?: OrderDetailsMaxOrderByAggregateInput
    _min?: OrderDetailsMinOrderByAggregateInput
    _sum?: OrderDetailsSumOrderByAggregateInput
  }

  export type OrderDetailsScalarWhereWithAggregatesInput = {
    AND?: OrderDetailsScalarWhereWithAggregatesInput | OrderDetailsScalarWhereWithAggregatesInput[]
    OR?: OrderDetailsScalarWhereWithAggregatesInput[]
    NOT?: OrderDetailsScalarWhereWithAggregatesInput | OrderDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderDetails"> | string
    userId?: StringWithAggregatesFilter<"OrderDetails"> | string
    totalPrice?: FloatWithAggregatesFilter<"OrderDetails"> | number
    status?: EnumOrderDetails_statusWithAggregatesFilter<"OrderDetails"> | $Enums.OrderDetails_status
    createdAt?: DateTimeWithAggregatesFilter<"OrderDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderDetails"> | Date | string
    discountId?: StringNullableWithAggregatesFilter<"OrderDetails"> | string | null
    orderId?: StringWithAggregatesFilter<"OrderDetails"> | string
    paymentMethod?: EnumOrderDetails_paymentMethodNullableWithAggregatesFilter<"OrderDetails"> | $Enums.OrderDetails_paymentMethod | null
    notes?: StringNullableWithAggregatesFilter<"OrderDetails"> | string | null
    trackingId?: StringNullableWithAggregatesFilter<"OrderDetails"> | string | null
    addressId?: StringNullableWithAggregatesFilter<"OrderDetails"> | string | null
    finalPrice?: FloatNullableWithAggregatesFilter<"OrderDetails"> | number | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    sizeId?: StringNullableFilter<"OrderItem"> | string | null
    colorId?: StringNullableFilter<"OrderItem"> | string | null
    imageId?: StringNullableFilter<"OrderItem"> | string | null
    isReviewed?: BoolFilter<"OrderItem"> | boolean
    ProductColor?: XOR<ProductColorNullableScalarRelationFilter, ProductColorWhereInput> | null
    ProductImage?: XOR<ProductImageNullableScalarRelationFilter, ProductImageWhereInput> | null
    OrderDetails?: XOR<OrderDetailsScalarRelationFilter, OrderDetailsWhereInput>
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    ProductSize?: XOR<ProductSizeNullableScalarRelationFilter, ProductSizeWhereInput> | null
    ReturnRequest?: ReturnRequestListRelationFilter
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sizeId?: SortOrderInput | SortOrder
    colorId?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    isReviewed?: SortOrder
    ProductColor?: ProductColorOrderByWithRelationInput
    ProductImage?: ProductImageOrderByWithRelationInput
    OrderDetails?: OrderDetailsOrderByWithRelationInput
    Product?: ProductOrderByWithRelationInput
    ProductSize?: ProductSizeOrderByWithRelationInput
    ReturnRequest?: ReturnRequestOrderByRelationAggregateInput
    _relevance?: OrderItemOrderByRelevanceInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    sizeId?: StringNullableFilter<"OrderItem"> | string | null
    colorId?: StringNullableFilter<"OrderItem"> | string | null
    imageId?: StringNullableFilter<"OrderItem"> | string | null
    isReviewed?: BoolFilter<"OrderItem"> | boolean
    ProductColor?: XOR<ProductColorNullableScalarRelationFilter, ProductColorWhereInput> | null
    ProductImage?: XOR<ProductImageNullableScalarRelationFilter, ProductImageWhereInput> | null
    OrderDetails?: XOR<OrderDetailsScalarRelationFilter, OrderDetailsWhereInput>
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    ProductSize?: XOR<ProductSizeNullableScalarRelationFilter, ProductSizeWhereInput> | null
    ReturnRequest?: ReturnRequestListRelationFilter
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sizeId?: SortOrderInput | SortOrder
    colorId?: SortOrderInput | SortOrder
    imageId?: SortOrderInput | SortOrder
    isReviewed?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: FloatWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    sizeId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    colorId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    imageId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    isReviewed?: BoolWithAggregatesFilter<"OrderItem"> | boolean
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: StringFilter<"Otp"> | string
    userId?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: OtpOrderByRelevanceInput
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    userId?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Otp"> | string
    userId?: StringWithAggregatesFilter<"Otp"> | string
    code?: StringWithAggregatesFilter<"Otp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
  }

  export type PaymentDetailsWhereInput = {
    AND?: PaymentDetailsWhereInput | PaymentDetailsWhereInput[]
    OR?: PaymentDetailsWhereInput[]
    NOT?: PaymentDetailsWhereInput | PaymentDetailsWhereInput[]
    id?: StringFilter<"PaymentDetails"> | string
    orderId?: StringFilter<"PaymentDetails"> | string
    amount?: FloatFilter<"PaymentDetails"> | number
    createdAt?: DateTimeFilter<"PaymentDetails"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentDetails"> | Date | string
    bank?: StringNullableFilter<"PaymentDetails"> | string | null
    currency?: StringFilter<"PaymentDetails"> | string
    method?: StringFilter<"PaymentDetails"> | string
    order_id?: StringFilter<"PaymentDetails"> | string
    payment_id?: StringFilter<"PaymentDetails"> | string
    upi?: StringNullableFilter<"PaymentDetails"> | string | null
    wallet?: StringNullableFilter<"PaymentDetails"> | string | null
    OrderDetails?: XOR<OrderDetailsScalarRelationFilter, OrderDetailsWhereInput>
  }

  export type PaymentDetailsOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bank?: SortOrderInput | SortOrder
    currency?: SortOrder
    method?: SortOrder
    order_id?: SortOrder
    payment_id?: SortOrder
    upi?: SortOrderInput | SortOrder
    wallet?: SortOrderInput | SortOrder
    OrderDetails?: OrderDetailsOrderByWithRelationInput
    _relevance?: PaymentDetailsOrderByRelevanceInput
  }

  export type PaymentDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentDetailsWhereInput | PaymentDetailsWhereInput[]
    OR?: PaymentDetailsWhereInput[]
    NOT?: PaymentDetailsWhereInput | PaymentDetailsWhereInput[]
    orderId?: StringFilter<"PaymentDetails"> | string
    amount?: FloatFilter<"PaymentDetails"> | number
    createdAt?: DateTimeFilter<"PaymentDetails"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentDetails"> | Date | string
    bank?: StringNullableFilter<"PaymentDetails"> | string | null
    currency?: StringFilter<"PaymentDetails"> | string
    method?: StringFilter<"PaymentDetails"> | string
    order_id?: StringFilter<"PaymentDetails"> | string
    payment_id?: StringFilter<"PaymentDetails"> | string
    upi?: StringNullableFilter<"PaymentDetails"> | string | null
    wallet?: StringNullableFilter<"PaymentDetails"> | string | null
    OrderDetails?: XOR<OrderDetailsScalarRelationFilter, OrderDetailsWhereInput>
  }, "id">

  export type PaymentDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bank?: SortOrderInput | SortOrder
    currency?: SortOrder
    method?: SortOrder
    order_id?: SortOrder
    payment_id?: SortOrder
    upi?: SortOrderInput | SortOrder
    wallet?: SortOrderInput | SortOrder
    _count?: PaymentDetailsCountOrderByAggregateInput
    _avg?: PaymentDetailsAvgOrderByAggregateInput
    _max?: PaymentDetailsMaxOrderByAggregateInput
    _min?: PaymentDetailsMinOrderByAggregateInput
    _sum?: PaymentDetailsSumOrderByAggregateInput
  }

  export type PaymentDetailsScalarWhereWithAggregatesInput = {
    AND?: PaymentDetailsScalarWhereWithAggregatesInput | PaymentDetailsScalarWhereWithAggregatesInput[]
    OR?: PaymentDetailsScalarWhereWithAggregatesInput[]
    NOT?: PaymentDetailsScalarWhereWithAggregatesInput | PaymentDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentDetails"> | string
    orderId?: StringWithAggregatesFilter<"PaymentDetails"> | string
    amount?: FloatWithAggregatesFilter<"PaymentDetails"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PaymentDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentDetails"> | Date | string
    bank?: StringNullableWithAggregatesFilter<"PaymentDetails"> | string | null
    currency?: StringWithAggregatesFilter<"PaymentDetails"> | string
    method?: StringWithAggregatesFilter<"PaymentDetails"> | string
    order_id?: StringWithAggregatesFilter<"PaymentDetails"> | string
    payment_id?: StringWithAggregatesFilter<"PaymentDetails"> | string
    upi?: StringNullableWithAggregatesFilter<"PaymentDetails"> | string | null
    wallet?: StringNullableWithAggregatesFilter<"PaymentDetails"> | string | null
  }

  export type PrivilegeWhereInput = {
    AND?: PrivilegeWhereInput | PrivilegeWhereInput[]
    OR?: PrivilegeWhereInput[]
    NOT?: PrivilegeWhereInput | PrivilegeWhereInput[]
    id?: StringFilter<"Privilege"> | string
    name?: StringFilter<"Privilege"> | string
    label?: StringNullableFilter<"Privilege"> | string | null
    UserPrivilege?: UserPrivilegeListRelationFilter
  }

  export type PrivilegeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    UserPrivilege?: UserPrivilegeOrderByRelationAggregateInput
    _relevance?: PrivilegeOrderByRelevanceInput
  }

  export type PrivilegeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PrivilegeWhereInput | PrivilegeWhereInput[]
    OR?: PrivilegeWhereInput[]
    NOT?: PrivilegeWhereInput | PrivilegeWhereInput[]
    label?: StringNullableFilter<"Privilege"> | string | null
    UserPrivilege?: UserPrivilegeListRelationFilter
  }, "id" | "name">

  export type PrivilegeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    _count?: PrivilegeCountOrderByAggregateInput
    _max?: PrivilegeMaxOrderByAggregateInput
    _min?: PrivilegeMinOrderByAggregateInput
  }

  export type PrivilegeScalarWhereWithAggregatesInput = {
    AND?: PrivilegeScalarWhereWithAggregatesInput | PrivilegeScalarWhereWithAggregatesInput[]
    OR?: PrivilegeScalarWhereWithAggregatesInput[]
    NOT?: PrivilegeScalarWhereWithAggregatesInput | PrivilegeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Privilege"> | string
    name?: StringWithAggregatesFilter<"Privilege"> | string
    label?: StringNullableWithAggregatesFilter<"Privilege"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    isReturnable?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    thumbnailUrl?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    description?: StringNullableFilter<"Product"> | string | null
    summary?: StringNullableFilter<"Product"> | string | null
    customerTypeId?: StringNullableFilter<"Product"> | string | null
    userId?: StringFilter<"Product"> | string
    estimatedDeliveryDay?: IntNullableFilter<"Product"> | number | null
    styleId?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    returnPolicy?: StringNullableFilter<"Product"> | string | null
    views?: IntFilter<"Product"> | number
    displayPrice?: FloatFilter<"Product"> | number
    tags?: JsonFilter<"Product">
    longTailKeyword?: StringNullableFilter<"Product"> | string | null
    affiliateId?: StringFilter<"Product"> | string
    isCODAvailable?: BoolFilter<"Product"> | boolean
    ogImage?: StringNullableFilter<"Product"> | string | null
    sellerCode?: StringNullableFilter<"Product"> | string | null
    sizeChartId?: StringNullableFilter<"Product"> | string | null
    fabricId?: StringNullableFilter<"Product"> | string | null
    seoTitle?: StringNullableFilter<"Product"> | string | null
    seoDescription?: StringNullableFilter<"Product"> | string | null
    CartItem?: CartItemListRelationFilter
    Discount?: DiscountListRelationFilter
    OrderItem?: OrderItemListRelationFilter
    CustomerType?: XOR<CustomerTypeNullableScalarRelationFilter, CustomerTypeWhereInput> | null
    ProductFabric?: XOR<ProductFabricNullableScalarRelationFilter, ProductFabricWhereInput> | null
    SizeChart?: XOR<SizeChartNullableScalarRelationFilter, SizeChartWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ProductImage?: ProductImageListRelationFilter
    ProductInventory?: ProductInventoryListRelationFilter
    ProductReview?: ProductReviewListRelationFilter
    WishlistItem?: WishlistItemListRelationFilter
    ProductCategory?: ProductCategoryListRelationFilter
    Product_A?: ProductListRelationFilter
    Product_B?: ProductListRelationFilter
    SubCategory?: SubCategoryListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    isReturnable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailUrl?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    customerTypeId?: SortOrderInput | SortOrder
    userId?: SortOrder
    estimatedDeliveryDay?: SortOrderInput | SortOrder
    styleId?: SortOrder
    title?: SortOrder
    returnPolicy?: SortOrderInput | SortOrder
    views?: SortOrder
    displayPrice?: SortOrder
    tags?: SortOrder
    longTailKeyword?: SortOrderInput | SortOrder
    affiliateId?: SortOrder
    isCODAvailable?: SortOrder
    ogImage?: SortOrderInput | SortOrder
    sellerCode?: SortOrderInput | SortOrder
    sizeChartId?: SortOrderInput | SortOrder
    fabricId?: SortOrderInput | SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    CartItem?: CartItemOrderByRelationAggregateInput
    Discount?: DiscountOrderByRelationAggregateInput
    OrderItem?: OrderItemOrderByRelationAggregateInput
    CustomerType?: CustomerTypeOrderByWithRelationInput
    ProductFabric?: ProductFabricOrderByWithRelationInput
    SizeChart?: SizeChartOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    ProductImage?: ProductImageOrderByRelationAggregateInput
    ProductInventory?: ProductInventoryOrderByRelationAggregateInput
    ProductReview?: ProductReviewOrderByRelationAggregateInput
    WishlistItem?: WishlistItemOrderByRelationAggregateInput
    ProductCategory?: ProductCategoryOrderByRelationAggregateInput
    Product_A?: ProductOrderByRelationAggregateInput
    Product_B?: ProductOrderByRelationAggregateInput
    SubCategory?: SubCategoryOrderByRelationAggregateInput
    _relevance?: ProductOrderByRelevanceInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    styleId?: string
    affiliateId?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    isReturnable?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    thumbnailUrl?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    description?: StringNullableFilter<"Product"> | string | null
    summary?: StringNullableFilter<"Product"> | string | null
    customerTypeId?: StringNullableFilter<"Product"> | string | null
    userId?: StringFilter<"Product"> | string
    estimatedDeliveryDay?: IntNullableFilter<"Product"> | number | null
    title?: StringFilter<"Product"> | string
    returnPolicy?: StringNullableFilter<"Product"> | string | null
    views?: IntFilter<"Product"> | number
    displayPrice?: FloatFilter<"Product"> | number
    tags?: JsonFilter<"Product">
    longTailKeyword?: StringNullableFilter<"Product"> | string | null
    isCODAvailable?: BoolFilter<"Product"> | boolean
    ogImage?: StringNullableFilter<"Product"> | string | null
    sellerCode?: StringNullableFilter<"Product"> | string | null
    sizeChartId?: StringNullableFilter<"Product"> | string | null
    fabricId?: StringNullableFilter<"Product"> | string | null
    seoTitle?: StringNullableFilter<"Product"> | string | null
    seoDescription?: StringNullableFilter<"Product"> | string | null
    CartItem?: CartItemListRelationFilter
    Discount?: DiscountListRelationFilter
    OrderItem?: OrderItemListRelationFilter
    CustomerType?: XOR<CustomerTypeNullableScalarRelationFilter, CustomerTypeWhereInput> | null
    ProductFabric?: XOR<ProductFabricNullableScalarRelationFilter, ProductFabricWhereInput> | null
    SizeChart?: XOR<SizeChartNullableScalarRelationFilter, SizeChartWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ProductImage?: ProductImageListRelationFilter
    ProductInventory?: ProductInventoryListRelationFilter
    ProductReview?: ProductReviewListRelationFilter
    WishlistItem?: WishlistItemListRelationFilter
    ProductCategory?: ProductCategoryListRelationFilter
    Product_A?: ProductListRelationFilter
    Product_B?: ProductListRelationFilter
    SubCategory?: SubCategoryListRelationFilter
  }, "id" | "slug" | "styleId" | "affiliateId">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    isReturnable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailUrl?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    customerTypeId?: SortOrderInput | SortOrder
    userId?: SortOrder
    estimatedDeliveryDay?: SortOrderInput | SortOrder
    styleId?: SortOrder
    title?: SortOrder
    returnPolicy?: SortOrderInput | SortOrder
    views?: SortOrder
    displayPrice?: SortOrder
    tags?: SortOrder
    longTailKeyword?: SortOrderInput | SortOrder
    affiliateId?: SortOrder
    isCODAvailable?: SortOrder
    ogImage?: SortOrderInput | SortOrder
    sellerCode?: SortOrderInput | SortOrder
    sizeChartId?: SortOrderInput | SortOrder
    fabricId?: SortOrderInput | SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    slug?: StringWithAggregatesFilter<"Product"> | string
    isReturnable?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    thumbnailUrl?: StringWithAggregatesFilter<"Product"> | string
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    summary?: StringNullableWithAggregatesFilter<"Product"> | string | null
    customerTypeId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    userId?: StringWithAggregatesFilter<"Product"> | string
    estimatedDeliveryDay?: IntNullableWithAggregatesFilter<"Product"> | number | null
    styleId?: StringWithAggregatesFilter<"Product"> | string
    title?: StringWithAggregatesFilter<"Product"> | string
    returnPolicy?: StringNullableWithAggregatesFilter<"Product"> | string | null
    views?: IntWithAggregatesFilter<"Product"> | number
    displayPrice?: FloatWithAggregatesFilter<"Product"> | number
    tags?: JsonWithAggregatesFilter<"Product">
    longTailKeyword?: StringNullableWithAggregatesFilter<"Product"> | string | null
    affiliateId?: StringWithAggregatesFilter<"Product"> | string
    isCODAvailable?: BoolWithAggregatesFilter<"Product"> | boolean
    ogImage?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sellerCode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sizeChartId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    fabricId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    seoTitle?: StringNullableWithAggregatesFilter<"Product"> | string | null
    seoDescription?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    slug?: StringFilter<"ProductCategory"> | string
    isVisible?: BoolFilter<"ProductCategory"> | boolean
    seoTitle?: StringNullableFilter<"ProductCategory"> | string | null
    seoDescription?: StringNullableFilter<"ProductCategory"> | string | null
    AnchorText?: XOR<AnchorTextNullableScalarRelationFilter, AnchorTextWhereInput> | null
    Quotes?: QuotesListRelationFilter
    SubCategory?: SubCategoryListRelationFilter
    Product?: ProductListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isVisible?: SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    AnchorText?: AnchorTextOrderByWithRelationInput
    Quotes?: QuotesOrderByRelationAggregateInput
    SubCategory?: SubCategoryOrderByRelationAggregateInput
    Product?: ProductOrderByRelationAggregateInput
    _relevance?: ProductCategoryOrderByRelevanceInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    name_slug?: ProductCategoryNameSlugCompoundUniqueInput
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    name?: StringFilter<"ProductCategory"> | string
    isVisible?: BoolFilter<"ProductCategory"> | boolean
    seoTitle?: StringNullableFilter<"ProductCategory"> | string | null
    seoDescription?: StringNullableFilter<"ProductCategory"> | string | null
    AnchorText?: XOR<AnchorTextNullableScalarRelationFilter, AnchorTextWhereInput> | null
    Quotes?: QuotesListRelationFilter
    SubCategory?: SubCategoryListRelationFilter
    Product?: ProductListRelationFilter
  }, "id" | "slug" | "name_slug">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isVisible?: SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    slug?: StringWithAggregatesFilter<"ProductCategory"> | string
    isVisible?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    seoTitle?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    seoDescription?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
  }

  export type ProductColorWhereInput = {
    AND?: ProductColorWhereInput | ProductColorWhereInput[]
    OR?: ProductColorWhereInput[]
    NOT?: ProductColorWhereInput | ProductColorWhereInput[]
    id?: StringFilter<"ProductColor"> | string
    name?: StringFilter<"ProductColor"> | string
    code?: StringFilter<"ProductColor"> | string
    slug?: StringFilter<"ProductColor"> | string
    CartItem?: CartItemListRelationFilter
    OrderItem?: OrderItemListRelationFilter
    ProductImage?: ProductImageListRelationFilter
  }

  export type ProductColorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    slug?: SortOrder
    CartItem?: CartItemOrderByRelationAggregateInput
    OrderItem?: OrderItemOrderByRelationAggregateInput
    ProductImage?: ProductImageOrderByRelationAggregateInput
    _relevance?: ProductColorOrderByRelevanceInput
  }

  export type ProductColorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProductColorWhereInput | ProductColorWhereInput[]
    OR?: ProductColorWhereInput[]
    NOT?: ProductColorWhereInput | ProductColorWhereInput[]
    name?: StringFilter<"ProductColor"> | string
    code?: StringFilter<"ProductColor"> | string
    CartItem?: CartItemListRelationFilter
    OrderItem?: OrderItemListRelationFilter
    ProductImage?: ProductImageListRelationFilter
  }, "id" | "slug">

  export type ProductColorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    slug?: SortOrder
    _count?: ProductColorCountOrderByAggregateInput
    _max?: ProductColorMaxOrderByAggregateInput
    _min?: ProductColorMinOrderByAggregateInput
  }

  export type ProductColorScalarWhereWithAggregatesInput = {
    AND?: ProductColorScalarWhereWithAggregatesInput | ProductColorScalarWhereWithAggregatesInput[]
    OR?: ProductColorScalarWhereWithAggregatesInput[]
    NOT?: ProductColorScalarWhereWithAggregatesInput | ProductColorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductColor"> | string
    name?: StringWithAggregatesFilter<"ProductColor"> | string
    code?: StringWithAggregatesFilter<"ProductColor"> | string
    slug?: StringWithAggregatesFilter<"ProductColor"> | string
  }

  export type ProductFabricWhereInput = {
    AND?: ProductFabricWhereInput | ProductFabricWhereInput[]
    OR?: ProductFabricWhereInput[]
    NOT?: ProductFabricWhereInput | ProductFabricWhereInput[]
    id?: StringFilter<"ProductFabric"> | string
    name?: StringFilter<"ProductFabric"> | string
    slug?: StringFilter<"ProductFabric"> | string
    Product?: ProductListRelationFilter
  }

  export type ProductFabricOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    Product?: ProductOrderByRelationAggregateInput
    _relevance?: ProductFabricOrderByRelevanceInput
  }

  export type ProductFabricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProductFabricWhereInput | ProductFabricWhereInput[]
    OR?: ProductFabricWhereInput[]
    NOT?: ProductFabricWhereInput | ProductFabricWhereInput[]
    name?: StringFilter<"ProductFabric"> | string
    Product?: ProductListRelationFilter
  }, "id" | "slug">

  export type ProductFabricOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: ProductFabricCountOrderByAggregateInput
    _max?: ProductFabricMaxOrderByAggregateInput
    _min?: ProductFabricMinOrderByAggregateInput
  }

  export type ProductFabricScalarWhereWithAggregatesInput = {
    AND?: ProductFabricScalarWhereWithAggregatesInput | ProductFabricScalarWhereWithAggregatesInput[]
    OR?: ProductFabricScalarWhereWithAggregatesInput[]
    NOT?: ProductFabricScalarWhereWithAggregatesInput | ProductFabricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductFabric"> | string
    name?: StringWithAggregatesFilter<"ProductFabric"> | string
    slug?: StringWithAggregatesFilter<"ProductFabric"> | string
  }

  export type ProductImageWhereInput = {
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    id?: StringFilter<"ProductImage"> | string
    productId?: StringFilter<"ProductImage"> | string
    imageUrl?: StringFilter<"ProductImage"> | string
    colorId?: StringNullableFilter<"ProductImage"> | string | null
    altText?: StringNullableFilter<"ProductImage"> | string | null
    caption?: StringNullableFilter<"ProductImage"> | string | null
    CartItem?: CartItemListRelationFilter
    OrderItem?: OrderItemListRelationFilter
    ProductColor?: XOR<ProductColorNullableScalarRelationFilter, ProductColorWhereInput> | null
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    colorId?: SortOrderInput | SortOrder
    altText?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    CartItem?: CartItemOrderByRelationAggregateInput
    OrderItem?: OrderItemOrderByRelationAggregateInput
    ProductColor?: ProductColorOrderByWithRelationInput
    Product?: ProductOrderByWithRelationInput
    _relevance?: ProductImageOrderByRelevanceInput
  }

  export type ProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    productId?: StringFilter<"ProductImage"> | string
    imageUrl?: StringFilter<"ProductImage"> | string
    colorId?: StringNullableFilter<"ProductImage"> | string | null
    altText?: StringNullableFilter<"ProductImage"> | string | null
    caption?: StringNullableFilter<"ProductImage"> | string | null
    CartItem?: CartItemListRelationFilter
    OrderItem?: OrderItemListRelationFilter
    ProductColor?: XOR<ProductColorNullableScalarRelationFilter, ProductColorWhereInput> | null
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    colorId?: SortOrderInput | SortOrder
    altText?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    OR?: ProductImageScalarWhereWithAggregatesInput[]
    NOT?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductImage"> | string
    productId?: StringWithAggregatesFilter<"ProductImage"> | string
    imageUrl?: StringWithAggregatesFilter<"ProductImage"> | string
    colorId?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    altText?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    caption?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
  }

  export type ProductInventoryWhereInput = {
    AND?: ProductInventoryWhereInput | ProductInventoryWhereInput[]
    OR?: ProductInventoryWhereInput[]
    NOT?: ProductInventoryWhereInput | ProductInventoryWhereInput[]
    id?: StringFilter<"ProductInventory"> | string
    productId?: StringFilter<"ProductInventory"> | string
    mrp?: IntFilter<"ProductInventory"> | number
    price?: IntFilter<"ProductInventory"> | number
    sizeId?: StringNullableFilter<"ProductInventory"> | string | null
    stock?: IntFilter<"ProductInventory"> | number
    minQuantity?: IntFilter<"ProductInventory"> | number
    discount?: FloatNullableFilter<"ProductInventory"> | number | null
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    ProductSize?: XOR<ProductSizeNullableScalarRelationFilter, ProductSizeWhereInput> | null
  }

  export type ProductInventoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
    sizeId?: SortOrderInput | SortOrder
    stock?: SortOrder
    minQuantity?: SortOrder
    discount?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
    ProductSize?: ProductSizeOrderByWithRelationInput
    _relevance?: ProductInventoryOrderByRelevanceInput
  }

  export type ProductInventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_sizeId?: ProductInventoryProductIdSizeIdCompoundUniqueInput
    AND?: ProductInventoryWhereInput | ProductInventoryWhereInput[]
    OR?: ProductInventoryWhereInput[]
    NOT?: ProductInventoryWhereInput | ProductInventoryWhereInput[]
    productId?: StringFilter<"ProductInventory"> | string
    mrp?: IntFilter<"ProductInventory"> | number
    price?: IntFilter<"ProductInventory"> | number
    sizeId?: StringNullableFilter<"ProductInventory"> | string | null
    stock?: IntFilter<"ProductInventory"> | number
    minQuantity?: IntFilter<"ProductInventory"> | number
    discount?: FloatNullableFilter<"ProductInventory"> | number | null
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    ProductSize?: XOR<ProductSizeNullableScalarRelationFilter, ProductSizeWhereInput> | null
  }, "id" | "productId_sizeId">

  export type ProductInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
    sizeId?: SortOrderInput | SortOrder
    stock?: SortOrder
    minQuantity?: SortOrder
    discount?: SortOrderInput | SortOrder
    _count?: ProductInventoryCountOrderByAggregateInput
    _avg?: ProductInventoryAvgOrderByAggregateInput
    _max?: ProductInventoryMaxOrderByAggregateInput
    _min?: ProductInventoryMinOrderByAggregateInput
    _sum?: ProductInventorySumOrderByAggregateInput
  }

  export type ProductInventoryScalarWhereWithAggregatesInput = {
    AND?: ProductInventoryScalarWhereWithAggregatesInput | ProductInventoryScalarWhereWithAggregatesInput[]
    OR?: ProductInventoryScalarWhereWithAggregatesInput[]
    NOT?: ProductInventoryScalarWhereWithAggregatesInput | ProductInventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductInventory"> | string
    productId?: StringWithAggregatesFilter<"ProductInventory"> | string
    mrp?: IntWithAggregatesFilter<"ProductInventory"> | number
    price?: IntWithAggregatesFilter<"ProductInventory"> | number
    sizeId?: StringNullableWithAggregatesFilter<"ProductInventory"> | string | null
    stock?: IntWithAggregatesFilter<"ProductInventory"> | number
    minQuantity?: IntWithAggregatesFilter<"ProductInventory"> | number
    discount?: FloatNullableWithAggregatesFilter<"ProductInventory"> | number | null
  }

  export type ProductReviewWhereInput = {
    AND?: ProductReviewWhereInput | ProductReviewWhereInput[]
    OR?: ProductReviewWhereInput[]
    NOT?: ProductReviewWhereInput | ProductReviewWhereInput[]
    id?: StringFilter<"ProductReview"> | string
    userId?: StringFilter<"ProductReview"> | string
    productId?: StringFilter<"ProductReview"> | string
    rating?: IntFilter<"ProductReview"> | number
    review?: StringNullableFilter<"ProductReview"> | string | null
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string
    updatedAt?: DateTimeFilter<"ProductReview"> | Date | string
    images?: JsonFilter<"ProductReview">
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProductReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: SortOrder
    Product?: ProductOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: ProductReviewOrderByRelevanceInput
  }

  export type ProductReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductReviewWhereInput | ProductReviewWhereInput[]
    OR?: ProductReviewWhereInput[]
    NOT?: ProductReviewWhereInput | ProductReviewWhereInput[]
    userId?: StringFilter<"ProductReview"> | string
    productId?: StringFilter<"ProductReview"> | string
    rating?: IntFilter<"ProductReview"> | number
    review?: StringNullableFilter<"ProductReview"> | string | null
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string
    updatedAt?: DateTimeFilter<"ProductReview"> | Date | string
    images?: JsonFilter<"ProductReview">
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProductReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: SortOrder
    _count?: ProductReviewCountOrderByAggregateInput
    _avg?: ProductReviewAvgOrderByAggregateInput
    _max?: ProductReviewMaxOrderByAggregateInput
    _min?: ProductReviewMinOrderByAggregateInput
    _sum?: ProductReviewSumOrderByAggregateInput
  }

  export type ProductReviewScalarWhereWithAggregatesInput = {
    AND?: ProductReviewScalarWhereWithAggregatesInput | ProductReviewScalarWhereWithAggregatesInput[]
    OR?: ProductReviewScalarWhereWithAggregatesInput[]
    NOT?: ProductReviewScalarWhereWithAggregatesInput | ProductReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductReview"> | string
    userId?: StringWithAggregatesFilter<"ProductReview"> | string
    productId?: StringWithAggregatesFilter<"ProductReview"> | string
    rating?: IntWithAggregatesFilter<"ProductReview"> | number
    review?: StringNullableWithAggregatesFilter<"ProductReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductReview"> | Date | string
    images?: JsonWithAggregatesFilter<"ProductReview">
  }

  export type ProductSizeWhereInput = {
    AND?: ProductSizeWhereInput | ProductSizeWhereInput[]
    OR?: ProductSizeWhereInput[]
    NOT?: ProductSizeWhereInput | ProductSizeWhereInput[]
    id?: StringFilter<"ProductSize"> | string
    name?: StringFilter<"ProductSize"> | string
    slug?: StringFilter<"ProductSize"> | string
    OrderItem?: OrderItemListRelationFilter
    ProductInventory?: ProductInventoryListRelationFilter
  }

  export type ProductSizeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    OrderItem?: OrderItemOrderByRelationAggregateInput
    ProductInventory?: ProductInventoryOrderByRelationAggregateInput
    _relevance?: ProductSizeOrderByRelevanceInput
  }

  export type ProductSizeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProductSizeWhereInput | ProductSizeWhereInput[]
    OR?: ProductSizeWhereInput[]
    NOT?: ProductSizeWhereInput | ProductSizeWhereInput[]
    name?: StringFilter<"ProductSize"> | string
    OrderItem?: OrderItemListRelationFilter
    ProductInventory?: ProductInventoryListRelationFilter
  }, "id" | "slug">

  export type ProductSizeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    _count?: ProductSizeCountOrderByAggregateInput
    _max?: ProductSizeMaxOrderByAggregateInput
    _min?: ProductSizeMinOrderByAggregateInput
  }

  export type ProductSizeScalarWhereWithAggregatesInput = {
    AND?: ProductSizeScalarWhereWithAggregatesInput | ProductSizeScalarWhereWithAggregatesInput[]
    OR?: ProductSizeScalarWhereWithAggregatesInput[]
    NOT?: ProductSizeScalarWhereWithAggregatesInput | ProductSizeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductSize"> | string
    name?: StringWithAggregatesFilter<"ProductSize"> | string
    slug?: StringWithAggregatesFilter<"ProductSize"> | string
  }

  export type ProductWeekWhereInput = {
    AND?: ProductWeekWhereInput | ProductWeekWhereInput[]
    OR?: ProductWeekWhereInput[]
    NOT?: ProductWeekWhereInput | ProductWeekWhereInput[]
    id?: StringFilter<"ProductWeek"> | string
    title?: StringNullableFilter<"ProductWeek"> | string | null
    hyperLink?: StringNullableFilter<"ProductWeek"> | string | null
    imageUrl?: StringNullableFilter<"ProductWeek"> | string | null
  }

  export type ProductWeekOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _relevance?: ProductWeekOrderByRelevanceInput
  }

  export type ProductWeekWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWeekWhereInput | ProductWeekWhereInput[]
    OR?: ProductWeekWhereInput[]
    NOT?: ProductWeekWhereInput | ProductWeekWhereInput[]
    title?: StringNullableFilter<"ProductWeek"> | string | null
    hyperLink?: StringNullableFilter<"ProductWeek"> | string | null
    imageUrl?: StringNullableFilter<"ProductWeek"> | string | null
  }, "id">

  export type ProductWeekOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _count?: ProductWeekCountOrderByAggregateInput
    _max?: ProductWeekMaxOrderByAggregateInput
    _min?: ProductWeekMinOrderByAggregateInput
  }

  export type ProductWeekScalarWhereWithAggregatesInput = {
    AND?: ProductWeekScalarWhereWithAggregatesInput | ProductWeekScalarWhereWithAggregatesInput[]
    OR?: ProductWeekScalarWhereWithAggregatesInput[]
    NOT?: ProductWeekScalarWhereWithAggregatesInput | ProductWeekScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductWeek"> | string
    title?: StringNullableWithAggregatesFilter<"ProductWeek"> | string | null
    hyperLink?: StringNullableWithAggregatesFilter<"ProductWeek"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"ProductWeek"> | string | null
  }

  export type QuotesWhereInput = {
    AND?: QuotesWhereInput | QuotesWhereInput[]
    OR?: QuotesWhereInput[]
    NOT?: QuotesWhereInput | QuotesWhereInput[]
    id?: StringFilter<"Quotes"> | string
    text?: StringNullableFilter<"Quotes"> | string | null
    imageUrl?: StringNullableFilter<"Quotes"> | string | null
    hyperLink?: StringNullableFilter<"Quotes"> | string | null
    categoryId?: StringFilter<"Quotes"> | string
    ProductCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }

  export type QuotesOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    ProductCategory?: ProductCategoryOrderByWithRelationInput
    _relevance?: QuotesOrderByRelevanceInput
  }

  export type QuotesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuotesWhereInput | QuotesWhereInput[]
    OR?: QuotesWhereInput[]
    NOT?: QuotesWhereInput | QuotesWhereInput[]
    text?: StringNullableFilter<"Quotes"> | string | null
    imageUrl?: StringNullableFilter<"Quotes"> | string | null
    hyperLink?: StringNullableFilter<"Quotes"> | string | null
    categoryId?: StringFilter<"Quotes"> | string
    ProductCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
  }, "id">

  export type QuotesOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    _count?: QuotesCountOrderByAggregateInput
    _max?: QuotesMaxOrderByAggregateInput
    _min?: QuotesMinOrderByAggregateInput
  }

  export type QuotesScalarWhereWithAggregatesInput = {
    AND?: QuotesScalarWhereWithAggregatesInput | QuotesScalarWhereWithAggregatesInput[]
    OR?: QuotesScalarWhereWithAggregatesInput[]
    NOT?: QuotesScalarWhereWithAggregatesInput | QuotesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quotes"> | string
    text?: StringNullableWithAggregatesFilter<"Quotes"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Quotes"> | string | null
    hyperLink?: StringNullableWithAggregatesFilter<"Quotes"> | string | null
    categoryId?: StringWithAggregatesFilter<"Quotes"> | string
  }

  export type ReturnRequestWhereInput = {
    AND?: ReturnRequestWhereInput | ReturnRequestWhereInput[]
    OR?: ReturnRequestWhereInput[]
    NOT?: ReturnRequestWhereInput | ReturnRequestWhereInput[]
    id?: StringFilter<"ReturnRequest"> | string
    orderItemId?: StringFilter<"ReturnRequest"> | string
    reason?: StringFilter<"ReturnRequest"> | string
    status?: EnumReturnRequest_statusFilter<"ReturnRequest"> | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null
    OrderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
  }

  export type ReturnRequestOrderByWithRelationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    OrderItem?: OrderItemOrderByWithRelationInput
    _relevance?: ReturnRequestOrderByRelevanceInput
  }

  export type ReturnRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReturnRequestWhereInput | ReturnRequestWhereInput[]
    OR?: ReturnRequestWhereInput[]
    NOT?: ReturnRequestWhereInput | ReturnRequestWhereInput[]
    orderItemId?: StringFilter<"ReturnRequest"> | string
    reason?: StringFilter<"ReturnRequest"> | string
    status?: EnumReturnRequest_statusFilter<"ReturnRequest"> | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null
    OrderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
  }, "id">

  export type ReturnRequestOrderByWithAggregationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: ReturnRequestCountOrderByAggregateInput
    _max?: ReturnRequestMaxOrderByAggregateInput
    _min?: ReturnRequestMinOrderByAggregateInput
  }

  export type ReturnRequestScalarWhereWithAggregatesInput = {
    AND?: ReturnRequestScalarWhereWithAggregatesInput | ReturnRequestScalarWhereWithAggregatesInput[]
    OR?: ReturnRequestScalarWhereWithAggregatesInput[]
    NOT?: ReturnRequestScalarWhereWithAggregatesInput | ReturnRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReturnRequest"> | string
    orderItemId?: StringWithAggregatesFilter<"ReturnRequest"> | string
    reason?: StringWithAggregatesFilter<"ReturnRequest"> | string
    status?: EnumReturnRequest_statusWithAggregatesFilter<"ReturnRequest"> | $Enums.ReturnRequest_status
    requestedAt?: DateTimeWithAggregatesFilter<"ReturnRequest"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"ReturnRequest"> | Date | string | null
  }

  export type RewardsWhereInput = {
    AND?: RewardsWhereInput | RewardsWhereInput[]
    OR?: RewardsWhereInput[]
    NOT?: RewardsWhereInput | RewardsWhereInput[]
    id?: StringFilter<"Rewards"> | string
    userId?: StringFilter<"Rewards"> | string
    title?: StringNullableFilter<"Rewards"> | string | null
    code?: StringNullableFilter<"Rewards"> | string | null
    description?: StringNullableFilter<"Rewards"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RewardsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: RewardsOrderByRelevanceInput
  }

  export type RewardsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RewardsWhereInput | RewardsWhereInput[]
    OR?: RewardsWhereInput[]
    NOT?: RewardsWhereInput | RewardsWhereInput[]
    userId?: StringFilter<"Rewards"> | string
    title?: StringNullableFilter<"Rewards"> | string | null
    code?: StringNullableFilter<"Rewards"> | string | null
    description?: StringNullableFilter<"Rewards"> | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RewardsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RewardsCountOrderByAggregateInput
    _max?: RewardsMaxOrderByAggregateInput
    _min?: RewardsMinOrderByAggregateInput
  }

  export type RewardsScalarWhereWithAggregatesInput = {
    AND?: RewardsScalarWhereWithAggregatesInput | RewardsScalarWhereWithAggregatesInput[]
    OR?: RewardsScalarWhereWithAggregatesInput[]
    NOT?: RewardsScalarWhereWithAggregatesInput | RewardsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rewards"> | string
    userId?: StringWithAggregatesFilter<"Rewards"> | string
    title?: StringNullableWithAggregatesFilter<"Rewards"> | string | null
    code?: StringNullableWithAggregatesFilter<"Rewards"> | string | null
    description?: StringNullableWithAggregatesFilter<"Rewards"> | string | null
  }

  export type SearchQueryWhereInput = {
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    id?: StringFilter<"SearchQuery"> | string
    query?: StringFilter<"SearchQuery"> | string
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
    userId?: StringFilter<"SearchQuery"> | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SearchQueryOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: SearchQueryOrderByRelevanceInput
  }

  export type SearchQueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchQueryWhereInput | SearchQueryWhereInput[]
    OR?: SearchQueryWhereInput[]
    NOT?: SearchQueryWhereInput | SearchQueryWhereInput[]
    query?: StringFilter<"SearchQuery"> | string
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
    userId?: StringFilter<"SearchQuery"> | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SearchQueryOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: SearchQueryCountOrderByAggregateInput
    _max?: SearchQueryMaxOrderByAggregateInput
    _min?: SearchQueryMinOrderByAggregateInput
  }

  export type SearchQueryScalarWhereWithAggregatesInput = {
    AND?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    OR?: SearchQueryScalarWhereWithAggregatesInput[]
    NOT?: SearchQueryScalarWhereWithAggregatesInput | SearchQueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchQuery"> | string
    query?: StringWithAggregatesFilter<"SearchQuery"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SearchQuery"> | Date | string
    userId?: StringWithAggregatesFilter<"SearchQuery"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
  }

  export type ShopByOccasionWhereInput = {
    AND?: ShopByOccasionWhereInput | ShopByOccasionWhereInput[]
    OR?: ShopByOccasionWhereInput[]
    NOT?: ShopByOccasionWhereInput | ShopByOccasionWhereInput[]
    id?: StringFilter<"ShopByOccasion"> | string
    occasionName?: StringNullableFilter<"ShopByOccasion"> | string | null
    categoryHyperLinks?: StringNullableFilter<"ShopByOccasion"> | string | null
    createdAt?: DateTimeFilter<"ShopByOccasion"> | Date | string
    updatedAt?: DateTimeFilter<"ShopByOccasion"> | Date | string
    ShopByOccasionProduct?: ShopByOccasionProductListRelationFilter
  }

  export type ShopByOccasionOrderByWithRelationInput = {
    id?: SortOrder
    occasionName?: SortOrderInput | SortOrder
    categoryHyperLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ShopByOccasionProduct?: ShopByOccasionProductOrderByRelationAggregateInput
    _relevance?: ShopByOccasionOrderByRelevanceInput
  }

  export type ShopByOccasionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopByOccasionWhereInput | ShopByOccasionWhereInput[]
    OR?: ShopByOccasionWhereInput[]
    NOT?: ShopByOccasionWhereInput | ShopByOccasionWhereInput[]
    occasionName?: StringNullableFilter<"ShopByOccasion"> | string | null
    categoryHyperLinks?: StringNullableFilter<"ShopByOccasion"> | string | null
    createdAt?: DateTimeFilter<"ShopByOccasion"> | Date | string
    updatedAt?: DateTimeFilter<"ShopByOccasion"> | Date | string
    ShopByOccasionProduct?: ShopByOccasionProductListRelationFilter
  }, "id">

  export type ShopByOccasionOrderByWithAggregationInput = {
    id?: SortOrder
    occasionName?: SortOrderInput | SortOrder
    categoryHyperLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopByOccasionCountOrderByAggregateInput
    _max?: ShopByOccasionMaxOrderByAggregateInput
    _min?: ShopByOccasionMinOrderByAggregateInput
  }

  export type ShopByOccasionScalarWhereWithAggregatesInput = {
    AND?: ShopByOccasionScalarWhereWithAggregatesInput | ShopByOccasionScalarWhereWithAggregatesInput[]
    OR?: ShopByOccasionScalarWhereWithAggregatesInput[]
    NOT?: ShopByOccasionScalarWhereWithAggregatesInput | ShopByOccasionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopByOccasion"> | string
    occasionName?: StringNullableWithAggregatesFilter<"ShopByOccasion"> | string | null
    categoryHyperLinks?: StringNullableWithAggregatesFilter<"ShopByOccasion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShopByOccasion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopByOccasion"> | Date | string
  }

  export type ShopByOccasionProductWhereInput = {
    AND?: ShopByOccasionProductWhereInput | ShopByOccasionProductWhereInput[]
    OR?: ShopByOccasionProductWhereInput[]
    NOT?: ShopByOccasionProductWhereInput | ShopByOccasionProductWhereInput[]
    id?: StringFilter<"ShopByOccasionProduct"> | string
    imageUrl?: StringFilter<"ShopByOccasionProduct"> | string
    hyperLink?: StringFilter<"ShopByOccasionProduct"> | string
    shopByOccasionId?: StringNullableFilter<"ShopByOccasionProduct"> | string | null
    createdAt?: DateTimeFilter<"ShopByOccasionProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ShopByOccasionProduct"> | Date | string
    ShopByOccasion?: XOR<ShopByOccasionNullableScalarRelationFilter, ShopByOccasionWhereInput> | null
  }

  export type ShopByOccasionProductOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    shopByOccasionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ShopByOccasion?: ShopByOccasionOrderByWithRelationInput
    _relevance?: ShopByOccasionProductOrderByRelevanceInput
  }

  export type ShopByOccasionProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopByOccasionProductWhereInput | ShopByOccasionProductWhereInput[]
    OR?: ShopByOccasionProductWhereInput[]
    NOT?: ShopByOccasionProductWhereInput | ShopByOccasionProductWhereInput[]
    imageUrl?: StringFilter<"ShopByOccasionProduct"> | string
    hyperLink?: StringFilter<"ShopByOccasionProduct"> | string
    shopByOccasionId?: StringNullableFilter<"ShopByOccasionProduct"> | string | null
    createdAt?: DateTimeFilter<"ShopByOccasionProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ShopByOccasionProduct"> | Date | string
    ShopByOccasion?: XOR<ShopByOccasionNullableScalarRelationFilter, ShopByOccasionWhereInput> | null
  }, "id">

  export type ShopByOccasionProductOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    shopByOccasionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopByOccasionProductCountOrderByAggregateInput
    _max?: ShopByOccasionProductMaxOrderByAggregateInput
    _min?: ShopByOccasionProductMinOrderByAggregateInput
  }

  export type ShopByOccasionProductScalarWhereWithAggregatesInput = {
    AND?: ShopByOccasionProductScalarWhereWithAggregatesInput | ShopByOccasionProductScalarWhereWithAggregatesInput[]
    OR?: ShopByOccasionProductScalarWhereWithAggregatesInput[]
    NOT?: ShopByOccasionProductScalarWhereWithAggregatesInput | ShopByOccasionProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopByOccasionProduct"> | string
    imageUrl?: StringWithAggregatesFilter<"ShopByOccasionProduct"> | string
    hyperLink?: StringWithAggregatesFilter<"ShopByOccasionProduct"> | string
    shopByOccasionId?: StringNullableWithAggregatesFilter<"ShopByOccasionProduct"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShopByOccasionProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopByOccasionProduct"> | Date | string
  }

  export type ShopBySeasonWhereInput = {
    AND?: ShopBySeasonWhereInput | ShopBySeasonWhereInput[]
    OR?: ShopBySeasonWhereInput[]
    NOT?: ShopBySeasonWhereInput | ShopBySeasonWhereInput[]
    id?: StringFilter<"ShopBySeason"> | string
    videoUrl?: StringNullableFilter<"ShopBySeason"> | string | null
    createdAt?: DateTimeFilter<"ShopBySeason"> | Date | string
    updatedAt?: DateTimeFilter<"ShopBySeason"> | Date | string
    ShopBySeasonProduct?: ShopBySeasonProductListRelationFilter
  }

  export type ShopBySeasonOrderByWithRelationInput = {
    id?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ShopBySeasonProduct?: ShopBySeasonProductOrderByRelationAggregateInput
    _relevance?: ShopBySeasonOrderByRelevanceInput
  }

  export type ShopBySeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopBySeasonWhereInput | ShopBySeasonWhereInput[]
    OR?: ShopBySeasonWhereInput[]
    NOT?: ShopBySeasonWhereInput | ShopBySeasonWhereInput[]
    videoUrl?: StringNullableFilter<"ShopBySeason"> | string | null
    createdAt?: DateTimeFilter<"ShopBySeason"> | Date | string
    updatedAt?: DateTimeFilter<"ShopBySeason"> | Date | string
    ShopBySeasonProduct?: ShopBySeasonProductListRelationFilter
  }, "id">

  export type ShopBySeasonOrderByWithAggregationInput = {
    id?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShopBySeasonCountOrderByAggregateInput
    _max?: ShopBySeasonMaxOrderByAggregateInput
    _min?: ShopBySeasonMinOrderByAggregateInput
  }

  export type ShopBySeasonScalarWhereWithAggregatesInput = {
    AND?: ShopBySeasonScalarWhereWithAggregatesInput | ShopBySeasonScalarWhereWithAggregatesInput[]
    OR?: ShopBySeasonScalarWhereWithAggregatesInput[]
    NOT?: ShopBySeasonScalarWhereWithAggregatesInput | ShopBySeasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopBySeason"> | string
    videoUrl?: StringNullableWithAggregatesFilter<"ShopBySeason"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShopBySeason"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopBySeason"> | Date | string
  }

  export type ShopBySeasonProductWhereInput = {
    AND?: ShopBySeasonProductWhereInput | ShopBySeasonProductWhereInput[]
    OR?: ShopBySeasonProductWhereInput[]
    NOT?: ShopBySeasonProductWhereInput | ShopBySeasonProductWhereInput[]
    id?: StringFilter<"ShopBySeasonProduct"> | string
    imageUrl?: StringFilter<"ShopBySeasonProduct"> | string
    description?: StringNullableFilter<"ShopBySeasonProduct"> | string | null
    createdAt?: DateTimeFilter<"ShopBySeasonProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ShopBySeasonProduct"> | Date | string
    seasonId?: StringFilter<"ShopBySeasonProduct"> | string
    hyperLink?: StringFilter<"ShopBySeasonProduct"> | string
    ShopBySeason?: XOR<ShopBySeasonScalarRelationFilter, ShopBySeasonWhereInput>
  }

  export type ShopBySeasonProductOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    hyperLink?: SortOrder
    ShopBySeason?: ShopBySeasonOrderByWithRelationInput
    _relevance?: ShopBySeasonProductOrderByRelevanceInput
  }

  export type ShopBySeasonProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopBySeasonProductWhereInput | ShopBySeasonProductWhereInput[]
    OR?: ShopBySeasonProductWhereInput[]
    NOT?: ShopBySeasonProductWhereInput | ShopBySeasonProductWhereInput[]
    imageUrl?: StringFilter<"ShopBySeasonProduct"> | string
    description?: StringNullableFilter<"ShopBySeasonProduct"> | string | null
    createdAt?: DateTimeFilter<"ShopBySeasonProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ShopBySeasonProduct"> | Date | string
    seasonId?: StringFilter<"ShopBySeasonProduct"> | string
    hyperLink?: StringFilter<"ShopBySeasonProduct"> | string
    ShopBySeason?: XOR<ShopBySeasonScalarRelationFilter, ShopBySeasonWhereInput>
  }, "id">

  export type ShopBySeasonProductOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    hyperLink?: SortOrder
    _count?: ShopBySeasonProductCountOrderByAggregateInput
    _max?: ShopBySeasonProductMaxOrderByAggregateInput
    _min?: ShopBySeasonProductMinOrderByAggregateInput
  }

  export type ShopBySeasonProductScalarWhereWithAggregatesInput = {
    AND?: ShopBySeasonProductScalarWhereWithAggregatesInput | ShopBySeasonProductScalarWhereWithAggregatesInput[]
    OR?: ShopBySeasonProductScalarWhereWithAggregatesInput[]
    NOT?: ShopBySeasonProductScalarWhereWithAggregatesInput | ShopBySeasonProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShopBySeasonProduct"> | string
    imageUrl?: StringWithAggregatesFilter<"ShopBySeasonProduct"> | string
    description?: StringNullableWithAggregatesFilter<"ShopBySeasonProduct"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShopBySeasonProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShopBySeasonProduct"> | Date | string
    seasonId?: StringWithAggregatesFilter<"ShopBySeasonProduct"> | string
    hyperLink?: StringWithAggregatesFilter<"ShopBySeasonProduct"> | string
  }

  export type ShowcasesWhereInput = {
    AND?: ShowcasesWhereInput | ShowcasesWhereInput[]
    OR?: ShowcasesWhereInput[]
    NOT?: ShowcasesWhereInput | ShowcasesWhereInput[]
    id?: StringFilter<"Showcases"> | string
    title?: StringFilter<"Showcases"> | string
    imageUrl?: StringFilter<"Showcases"> | string
    hyperLink?: StringFilter<"Showcases"> | string
    categoryHyperLink?: StringNullableFilter<"Showcases"> | string | null
    createdAt?: DateTimeFilter<"Showcases"> | Date | string
    updatedAt?: DateTimeFilter<"Showcases"> | Date | string
  }

  export type ShowcasesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ShowcasesOrderByRelevanceInput
  }

  export type ShowcasesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShowcasesWhereInput | ShowcasesWhereInput[]
    OR?: ShowcasesWhereInput[]
    NOT?: ShowcasesWhereInput | ShowcasesWhereInput[]
    title?: StringFilter<"Showcases"> | string
    imageUrl?: StringFilter<"Showcases"> | string
    hyperLink?: StringFilter<"Showcases"> | string
    categoryHyperLink?: StringNullableFilter<"Showcases"> | string | null
    createdAt?: DateTimeFilter<"Showcases"> | Date | string
    updatedAt?: DateTimeFilter<"Showcases"> | Date | string
  }, "id">

  export type ShowcasesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShowcasesCountOrderByAggregateInput
    _max?: ShowcasesMaxOrderByAggregateInput
    _min?: ShowcasesMinOrderByAggregateInput
  }

  export type ShowcasesScalarWhereWithAggregatesInput = {
    AND?: ShowcasesScalarWhereWithAggregatesInput | ShowcasesScalarWhereWithAggregatesInput[]
    OR?: ShowcasesScalarWhereWithAggregatesInput[]
    NOT?: ShowcasesScalarWhereWithAggregatesInput | ShowcasesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Showcases"> | string
    title?: StringWithAggregatesFilter<"Showcases"> | string
    imageUrl?: StringWithAggregatesFilter<"Showcases"> | string
    hyperLink?: StringWithAggregatesFilter<"Showcases"> | string
    categoryHyperLink?: StringNullableWithAggregatesFilter<"Showcases"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Showcases"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Showcases"> | Date | string
  }

  export type SizeChartWhereInput = {
    AND?: SizeChartWhereInput | SizeChartWhereInput[]
    OR?: SizeChartWhereInput[]
    NOT?: SizeChartWhereInput | SizeChartWhereInput[]
    id?: StringFilter<"SizeChart"> | string
    title?: StringNullableFilter<"SizeChart"> | string | null
    imageUrl?: StringFilter<"SizeChart"> | string
    createdAt?: DateTimeFilter<"SizeChart"> | Date | string
    updatedAt?: DateTimeFilter<"SizeChart"> | Date | string
    productId?: StringNullableFilter<"SizeChart"> | string | null
    Product?: ProductListRelationFilter
  }

  export type SizeChartOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    Product?: ProductOrderByRelationAggregateInput
    _relevance?: SizeChartOrderByRelevanceInput
  }

  export type SizeChartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SizeChartWhereInput | SizeChartWhereInput[]
    OR?: SizeChartWhereInput[]
    NOT?: SizeChartWhereInput | SizeChartWhereInput[]
    title?: StringNullableFilter<"SizeChart"> | string | null
    imageUrl?: StringFilter<"SizeChart"> | string
    createdAt?: DateTimeFilter<"SizeChart"> | Date | string
    updatedAt?: DateTimeFilter<"SizeChart"> | Date | string
    productId?: StringNullableFilter<"SizeChart"> | string | null
    Product?: ProductListRelationFilter
  }, "id">

  export type SizeChartOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: SizeChartCountOrderByAggregateInput
    _max?: SizeChartMaxOrderByAggregateInput
    _min?: SizeChartMinOrderByAggregateInput
  }

  export type SizeChartScalarWhereWithAggregatesInput = {
    AND?: SizeChartScalarWhereWithAggregatesInput | SizeChartScalarWhereWithAggregatesInput[]
    OR?: SizeChartScalarWhereWithAggregatesInput[]
    NOT?: SizeChartScalarWhereWithAggregatesInput | SizeChartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SizeChart"> | string
    title?: StringNullableWithAggregatesFilter<"SizeChart"> | string | null
    imageUrl?: StringWithAggregatesFilter<"SizeChart"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SizeChart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SizeChart"> | Date | string
    productId?: StringNullableWithAggregatesFilter<"SizeChart"> | string | null
  }

  export type SocialLinksWhereInput = {
    AND?: SocialLinksWhereInput | SocialLinksWhereInput[]
    OR?: SocialLinksWhereInput[]
    NOT?: SocialLinksWhereInput | SocialLinksWhereInput[]
    id?: StringFilter<"SocialLinks"> | string
    imageUrl?: StringNullableFilter<"SocialLinks"> | string | null
    hyperLink?: StringNullableFilter<"SocialLinks"> | string | null
  }

  export type SocialLinksOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    _relevance?: SocialLinksOrderByRelevanceInput
  }

  export type SocialLinksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialLinksWhereInput | SocialLinksWhereInput[]
    OR?: SocialLinksWhereInput[]
    NOT?: SocialLinksWhereInput | SocialLinksWhereInput[]
    imageUrl?: StringNullableFilter<"SocialLinks"> | string | null
    hyperLink?: StringNullableFilter<"SocialLinks"> | string | null
  }, "id">

  export type SocialLinksOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    _count?: SocialLinksCountOrderByAggregateInput
    _max?: SocialLinksMaxOrderByAggregateInput
    _min?: SocialLinksMinOrderByAggregateInput
  }

  export type SocialLinksScalarWhereWithAggregatesInput = {
    AND?: SocialLinksScalarWhereWithAggregatesInput | SocialLinksScalarWhereWithAggregatesInput[]
    OR?: SocialLinksScalarWhereWithAggregatesInput[]
    NOT?: SocialLinksScalarWhereWithAggregatesInput | SocialLinksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialLinks"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"SocialLinks"> | string | null
    hyperLink?: StringNullableWithAggregatesFilter<"SocialLinks"> | string | null
  }

  export type StaticMessagesWhereInput = {
    AND?: StaticMessagesWhereInput | StaticMessagesWhereInput[]
    OR?: StaticMessagesWhereInput[]
    NOT?: StaticMessagesWhereInput | StaticMessagesWhereInput[]
    id?: StringFilter<"StaticMessages"> | string
    userId?: StringFilter<"StaticMessages"> | string
    status?: EnumStaticMessages_statusFilter<"StaticMessages"> | $Enums.StaticMessages_status
    message?: StringFilter<"StaticMessages"> | string
    createdAt?: DateTimeFilter<"StaticMessages"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StaticMessagesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: StaticMessagesOrderByRelevanceInput
  }

  export type StaticMessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StaticMessagesWhereInput | StaticMessagesWhereInput[]
    OR?: StaticMessagesWhereInput[]
    NOT?: StaticMessagesWhereInput | StaticMessagesWhereInput[]
    userId?: StringFilter<"StaticMessages"> | string
    status?: EnumStaticMessages_statusFilter<"StaticMessages"> | $Enums.StaticMessages_status
    message?: StringFilter<"StaticMessages"> | string
    createdAt?: DateTimeFilter<"StaticMessages"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type StaticMessagesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: StaticMessagesCountOrderByAggregateInput
    _max?: StaticMessagesMaxOrderByAggregateInput
    _min?: StaticMessagesMinOrderByAggregateInput
  }

  export type StaticMessagesScalarWhereWithAggregatesInput = {
    AND?: StaticMessagesScalarWhereWithAggregatesInput | StaticMessagesScalarWhereWithAggregatesInput[]
    OR?: StaticMessagesScalarWhereWithAggregatesInput[]
    NOT?: StaticMessagesScalarWhereWithAggregatesInput | StaticMessagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaticMessages"> | string
    userId?: StringWithAggregatesFilter<"StaticMessages"> | string
    status?: EnumStaticMessages_statusWithAggregatesFilter<"StaticMessages"> | $Enums.StaticMessages_status
    message?: StringWithAggregatesFilter<"StaticMessages"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StaticMessages"> | Date | string
  }

  export type SubCategoryWhereInput = {
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    id?: StringFilter<"SubCategory"> | string
    name?: StringFilter<"SubCategory"> | string
    slug?: StringFilter<"SubCategory"> | string
    categoryId?: StringFilter<"SubCategory"> | string
    imageUrl?: StringNullableFilter<"SubCategory"> | string | null
    seoTitle?: StringNullableFilter<"SubCategory"> | string | null
    seoDescription?: StringNullableFilter<"SubCategory"> | string | null
    ProductCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    Product?: ProductListRelationFilter
  }

  export type SubCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    ProductCategory?: ProductCategoryOrderByWithRelationInput
    Product?: ProductOrderByRelationAggregateInput
    _relevance?: SubCategoryOrderByRelevanceInput
  }

  export type SubCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    name?: StringFilter<"SubCategory"> | string
    slug?: StringFilter<"SubCategory"> | string
    categoryId?: StringFilter<"SubCategory"> | string
    imageUrl?: StringNullableFilter<"SubCategory"> | string | null
    seoTitle?: StringNullableFilter<"SubCategory"> | string | null
    seoDescription?: StringNullableFilter<"SubCategory"> | string | null
    ProductCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    Product?: ProductListRelationFilter
  }, "id">

  export type SubCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    _count?: SubCategoryCountOrderByAggregateInput
    _max?: SubCategoryMaxOrderByAggregateInput
    _min?: SubCategoryMinOrderByAggregateInput
  }

  export type SubCategoryScalarWhereWithAggregatesInput = {
    AND?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    OR?: SubCategoryScalarWhereWithAggregatesInput[]
    NOT?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubCategory"> | string
    name?: StringWithAggregatesFilter<"SubCategory"> | string
    slug?: StringWithAggregatesFilter<"SubCategory"> | string
    categoryId?: StringWithAggregatesFilter<"SubCategory"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"SubCategory"> | string | null
    seoTitle?: StringNullableWithAggregatesFilter<"SubCategory"> | string | null
    seoDescription?: StringNullableWithAggregatesFilter<"SubCategory"> | string | null
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    status?: EnumSupportTicket_statusFilter<"SupportTicket"> | $Enums.SupportTicket_status
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: SupportTicketOrderByRelevanceInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    userId?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    status?: EnumSupportTicket_statusFilter<"SupportTicket"> | $Enums.SupportTicket_status
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    userId?: StringWithAggregatesFilter<"SupportTicket"> | string
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    message?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: EnumSupportTicket_statusWithAggregatesFilter<"SupportTicket"> | $Enums.SupportTicket_status
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
  }

  export type TagsWhereInput = {
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    id?: StringFilter<"Tags"> | string
    tag?: StringFilter<"Tags"> | string
  }

  export type TagsOrderByWithRelationInput = {
    id?: SortOrder
    tag?: SortOrder
    _relevance?: TagsOrderByRelevanceInput
  }

  export type TagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag?: string
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
  }, "id" | "tag">

  export type TagsOrderByWithAggregationInput = {
    id?: SortOrder
    tag?: SortOrder
    _count?: TagsCountOrderByAggregateInput
    _max?: TagsMaxOrderByAggregateInput
    _min?: TagsMinOrderByAggregateInput
  }

  export type TagsScalarWhereWithAggregatesInput = {
    AND?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    OR?: TagsScalarWhereWithAggregatesInput[]
    NOT?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tags"> | string
    tag?: StringWithAggregatesFilter<"Tags"> | string
  }

  export type TrendingWhereInput = {
    AND?: TrendingWhereInput | TrendingWhereInput[]
    OR?: TrendingWhereInput[]
    NOT?: TrendingWhereInput | TrendingWhereInput[]
    id?: StringFilter<"Trending"> | string
    videoUrl?: StringNullableFilter<"Trending"> | string | null
    title?: StringNullableFilter<"Trending"> | string | null
    price?: StringNullableFilter<"Trending"> | string | null
    hyperLink?: StringNullableFilter<"Trending"> | string | null
    createdAt?: DateTimeFilter<"Trending"> | Date | string
    updatedAt?: DateTimeFilter<"Trending"> | Date | string
    avatarUrl?: StringNullableFilter<"Trending"> | string | null
  }

  export type TrendingOrderByWithRelationInput = {
    id?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    _relevance?: TrendingOrderByRelevanceInput
  }

  export type TrendingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrendingWhereInput | TrendingWhereInput[]
    OR?: TrendingWhereInput[]
    NOT?: TrendingWhereInput | TrendingWhereInput[]
    videoUrl?: StringNullableFilter<"Trending"> | string | null
    title?: StringNullableFilter<"Trending"> | string | null
    price?: StringNullableFilter<"Trending"> | string | null
    hyperLink?: StringNullableFilter<"Trending"> | string | null
    createdAt?: DateTimeFilter<"Trending"> | Date | string
    updatedAt?: DateTimeFilter<"Trending"> | Date | string
    avatarUrl?: StringNullableFilter<"Trending"> | string | null
  }, "id">

  export type TrendingOrderByWithAggregationInput = {
    id?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    hyperLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    _count?: TrendingCountOrderByAggregateInput
    _max?: TrendingMaxOrderByAggregateInput
    _min?: TrendingMinOrderByAggregateInput
  }

  export type TrendingScalarWhereWithAggregatesInput = {
    AND?: TrendingScalarWhereWithAggregatesInput | TrendingScalarWhereWithAggregatesInput[]
    OR?: TrendingScalarWhereWithAggregatesInput[]
    NOT?: TrendingScalarWhereWithAggregatesInput | TrendingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trending"> | string
    videoUrl?: StringNullableWithAggregatesFilter<"Trending"> | string | null
    title?: StringNullableWithAggregatesFilter<"Trending"> | string | null
    price?: StringNullableWithAggregatesFilter<"Trending"> | string | null
    hyperLink?: StringNullableWithAggregatesFilter<"Trending"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Trending"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trending"> | Date | string
    avatarUrl?: StringNullableWithAggregatesFilter<"Trending"> | string | null
  }

  export type UpdateHistoryWhereInput = {
    AND?: UpdateHistoryWhereInput | UpdateHistoryWhereInput[]
    OR?: UpdateHistoryWhereInput[]
    NOT?: UpdateHistoryWhereInput | UpdateHistoryWhereInput[]
    id?: StringFilter<"UpdateHistory"> | string
    userId?: StringFilter<"UpdateHistory"> | string
    title?: StringFilter<"UpdateHistory"> | string
    description?: StringFilter<"UpdateHistory"> | string
    createdAt?: DateTimeFilter<"UpdateHistory"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UpdateHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    _relevance?: UpdateHistoryOrderByRelevanceInput
  }

  export type UpdateHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UpdateHistoryWhereInput | UpdateHistoryWhereInput[]
    OR?: UpdateHistoryWhereInput[]
    NOT?: UpdateHistoryWhereInput | UpdateHistoryWhereInput[]
    userId?: StringFilter<"UpdateHistory"> | string
    title?: StringFilter<"UpdateHistory"> | string
    description?: StringFilter<"UpdateHistory"> | string
    createdAt?: DateTimeFilter<"UpdateHistory"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UpdateHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: UpdateHistoryCountOrderByAggregateInput
    _max?: UpdateHistoryMaxOrderByAggregateInput
    _min?: UpdateHistoryMinOrderByAggregateInput
  }

  export type UpdateHistoryScalarWhereWithAggregatesInput = {
    AND?: UpdateHistoryScalarWhereWithAggregatesInput | UpdateHistoryScalarWhereWithAggregatesInput[]
    OR?: UpdateHistoryScalarWhereWithAggregatesInput[]
    NOT?: UpdateHistoryScalarWhereWithAggregatesInput | UpdateHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UpdateHistory"> | string
    userId?: StringWithAggregatesFilter<"UpdateHistory"> | string
    title?: StringWithAggregatesFilter<"UpdateHistory"> | string
    description?: StringWithAggregatesFilter<"UpdateHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UpdateHistory"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isVerified?: BoolFilter<"User"> | boolean
    role?: EnumUser_roleFilter<"User"> | $Enums.User_role
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    status?: EnumUser_statusFilter<"User"> | $Enums.User_status
    profileUrl?: StringNullableFilter<"User"> | string | null
    mobileNumber?: StringNullableFilter<"User"> | string | null
    whatsAppNumber?: StringNullableFilter<"User"> | string | null
    isLoggedIn?: BoolFilter<"User"> | boolean
    isViewed?: BoolFilter<"User"> | boolean
    is2FA?: BoolFilter<"User"> | boolean
    assignedStaffId?: StringNullableFilter<"User"> | string | null
    AuditLog?: AuditLogListRelationFilter
    CartItem?: CartItemListRelationFilter
    DeleteRequest?: DeleteRequestListRelationFilter
    DropMessage?: DropMessageListRelationFilter
    Message_Message_handledByIdToUser?: MessageListRelationFilter
    Message_Message_receiverIdToUser?: MessageListRelationFilter
    Message_Message_senderIdToUser?: MessageListRelationFilter
    Notification?: NotificationListRelationFilter
    OrderDetails?: OrderDetailsListRelationFilter
    Otp?: OtpListRelationFilter
    Product?: ProductListRelationFilter
    ProductReview?: ProductReviewListRelationFilter
    Rewards?: RewardsListRelationFilter
    SearchQuery?: SearchQueryListRelationFilter
    Session?: SessionListRelationFilter
    StaticMessages?: StaticMessagesListRelationFilter
    SupportTicket?: SupportTicketListRelationFilter
    UpdateHistory?: UpdateHistoryListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    other_User?: UserListRelationFilter
    UserAddress?: UserAddressListRelationFilter
    UserPrivilege?: UserPrivilegeListRelationFilter
    WishlistItem?: WishlistItemListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    status?: SortOrder
    profileUrl?: SortOrderInput | SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    whatsAppNumber?: SortOrderInput | SortOrder
    isLoggedIn?: SortOrder
    isViewed?: SortOrder
    is2FA?: SortOrder
    assignedStaffId?: SortOrderInput | SortOrder
    AuditLog?: AuditLogOrderByRelationAggregateInput
    CartItem?: CartItemOrderByRelationAggregateInput
    DeleteRequest?: DeleteRequestOrderByRelationAggregateInput
    DropMessage?: DropMessageOrderByRelationAggregateInput
    Message_Message_handledByIdToUser?: MessageOrderByRelationAggregateInput
    Message_Message_receiverIdToUser?: MessageOrderByRelationAggregateInput
    Message_Message_senderIdToUser?: MessageOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    OrderDetails?: OrderDetailsOrderByRelationAggregateInput
    Otp?: OtpOrderByRelationAggregateInput
    Product?: ProductOrderByRelationAggregateInput
    ProductReview?: ProductReviewOrderByRelationAggregateInput
    Rewards?: RewardsOrderByRelationAggregateInput
    SearchQuery?: SearchQueryOrderByRelationAggregateInput
    Session?: SessionOrderByRelationAggregateInput
    StaticMessages?: StaticMessagesOrderByRelationAggregateInput
    SupportTicket?: SupportTicketOrderByRelationAggregateInput
    UpdateHistory?: UpdateHistoryOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
    other_User?: UserOrderByRelationAggregateInput
    UserAddress?: UserAddressOrderByRelationAggregateInput
    UserPrivilege?: UserPrivilegeOrderByRelationAggregateInput
    WishlistItem?: WishlistItemOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isVerified?: BoolFilter<"User"> | boolean
    role?: EnumUser_roleFilter<"User"> | $Enums.User_role
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    status?: EnumUser_statusFilter<"User"> | $Enums.User_status
    profileUrl?: StringNullableFilter<"User"> | string | null
    mobileNumber?: StringNullableFilter<"User"> | string | null
    whatsAppNumber?: StringNullableFilter<"User"> | string | null
    isLoggedIn?: BoolFilter<"User"> | boolean
    isViewed?: BoolFilter<"User"> | boolean
    is2FA?: BoolFilter<"User"> | boolean
    assignedStaffId?: StringNullableFilter<"User"> | string | null
    AuditLog?: AuditLogListRelationFilter
    CartItem?: CartItemListRelationFilter
    DeleteRequest?: DeleteRequestListRelationFilter
    DropMessage?: DropMessageListRelationFilter
    Message_Message_handledByIdToUser?: MessageListRelationFilter
    Message_Message_receiverIdToUser?: MessageListRelationFilter
    Message_Message_senderIdToUser?: MessageListRelationFilter
    Notification?: NotificationListRelationFilter
    OrderDetails?: OrderDetailsListRelationFilter
    Otp?: OtpListRelationFilter
    Product?: ProductListRelationFilter
    ProductReview?: ProductReviewListRelationFilter
    Rewards?: RewardsListRelationFilter
    SearchQuery?: SearchQueryListRelationFilter
    Session?: SessionListRelationFilter
    StaticMessages?: StaticMessagesListRelationFilter
    SupportTicket?: SupportTicketListRelationFilter
    UpdateHistory?: UpdateHistoryListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    other_User?: UserListRelationFilter
    UserAddress?: UserAddressListRelationFilter
    UserPrivilege?: UserPrivilegeListRelationFilter
    WishlistItem?: WishlistItemListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    status?: SortOrder
    profileUrl?: SortOrderInput | SortOrder
    mobileNumber?: SortOrderInput | SortOrder
    whatsAppNumber?: SortOrderInput | SortOrder
    isLoggedIn?: SortOrder
    isViewed?: SortOrder
    is2FA?: SortOrder
    assignedStaffId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUser_roleWithAggregatesFilter<"User"> | $Enums.User_role
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: EnumUser_statusWithAggregatesFilter<"User"> | $Enums.User_status
    profileUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    mobileNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    whatsAppNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    isLoggedIn?: BoolWithAggregatesFilter<"User"> | boolean
    isViewed?: BoolWithAggregatesFilter<"User"> | boolean
    is2FA?: BoolWithAggregatesFilter<"User"> | boolean
    assignedStaffId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserAddressWhereInput = {
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    id?: StringFilter<"UserAddress"> | string
    userId?: StringFilter<"UserAddress"> | string
    addressLine1?: StringFilter<"UserAddress"> | string
    addressLine2?: StringNullableFilter<"UserAddress"> | string | null
    city?: StringFilter<"UserAddress"> | string
    state?: StringFilter<"UserAddress"> | string
    zipCode?: StringFilter<"UserAddress"> | string
    country?: StringFilter<"UserAddress"> | string
    mobileNumber?: StringFilter<"UserAddress"> | string
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    isDefault?: BoolFilter<"UserAddress"> | boolean
    fullName?: StringNullableFilter<"UserAddress"> | string | null
    altMobileNumber?: StringNullableFilter<"UserAddress"> | string | null
    OrderDetails?: OrderDetailsListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    mobileNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDefault?: SortOrder
    fullName?: SortOrderInput | SortOrder
    altMobileNumber?: SortOrderInput | SortOrder
    OrderDetails?: OrderDetailsOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
    _relevance?: UserAddressOrderByRelevanceInput
  }

  export type UserAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserAddressWhereInput | UserAddressWhereInput[]
    OR?: UserAddressWhereInput[]
    NOT?: UserAddressWhereInput | UserAddressWhereInput[]
    userId?: StringFilter<"UserAddress"> | string
    addressLine1?: StringFilter<"UserAddress"> | string
    addressLine2?: StringNullableFilter<"UserAddress"> | string | null
    city?: StringFilter<"UserAddress"> | string
    state?: StringFilter<"UserAddress"> | string
    zipCode?: StringFilter<"UserAddress"> | string
    country?: StringFilter<"UserAddress"> | string
    mobileNumber?: StringFilter<"UserAddress"> | string
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    isDefault?: BoolFilter<"UserAddress"> | boolean
    fullName?: StringNullableFilter<"UserAddress"> | string | null
    altMobileNumber?: StringNullableFilter<"UserAddress"> | string | null
    OrderDetails?: OrderDetailsListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserAddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    mobileNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDefault?: SortOrder
    fullName?: SortOrderInput | SortOrder
    altMobileNumber?: SortOrderInput | SortOrder
    _count?: UserAddressCountOrderByAggregateInput
    _max?: UserAddressMaxOrderByAggregateInput
    _min?: UserAddressMinOrderByAggregateInput
  }

  export type UserAddressScalarWhereWithAggregatesInput = {
    AND?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    OR?: UserAddressScalarWhereWithAggregatesInput[]
    NOT?: UserAddressScalarWhereWithAggregatesInput | UserAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAddress"> | string
    userId?: StringWithAggregatesFilter<"UserAddress"> | string
    addressLine1?: StringWithAggregatesFilter<"UserAddress"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"UserAddress"> | string | null
    city?: StringWithAggregatesFilter<"UserAddress"> | string
    state?: StringWithAggregatesFilter<"UserAddress"> | string
    zipCode?: StringWithAggregatesFilter<"UserAddress"> | string
    country?: StringWithAggregatesFilter<"UserAddress"> | string
    mobileNumber?: StringWithAggregatesFilter<"UserAddress"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAddress"> | Date | string
    isDefault?: BoolWithAggregatesFilter<"UserAddress"> | boolean
    fullName?: StringNullableWithAggregatesFilter<"UserAddress"> | string | null
    altMobileNumber?: StringNullableWithAggregatesFilter<"UserAddress"> | string | null
  }

  export type UserPrivilegeWhereInput = {
    AND?: UserPrivilegeWhereInput | UserPrivilegeWhereInput[]
    OR?: UserPrivilegeWhereInput[]
    NOT?: UserPrivilegeWhereInput | UserPrivilegeWhereInput[]
    id?: StringFilter<"UserPrivilege"> | string
    userId?: StringFilter<"UserPrivilege"> | string
    privilegeId?: StringFilter<"UserPrivilege"> | string
    createdAt?: DateTimeFilter<"UserPrivilege"> | Date | string
    Privilege?: XOR<PrivilegeScalarRelationFilter, PrivilegeWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPrivilegeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    privilegeId?: SortOrder
    createdAt?: SortOrder
    Privilege?: PrivilegeOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: UserPrivilegeOrderByRelevanceInput
  }

  export type UserPrivilegeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPrivilegeWhereInput | UserPrivilegeWhereInput[]
    OR?: UserPrivilegeWhereInput[]
    NOT?: UserPrivilegeWhereInput | UserPrivilegeWhereInput[]
    userId?: StringFilter<"UserPrivilege"> | string
    privilegeId?: StringFilter<"UserPrivilege"> | string
    createdAt?: DateTimeFilter<"UserPrivilege"> | Date | string
    Privilege?: XOR<PrivilegeScalarRelationFilter, PrivilegeWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserPrivilegeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    privilegeId?: SortOrder
    createdAt?: SortOrder
    _count?: UserPrivilegeCountOrderByAggregateInput
    _max?: UserPrivilegeMaxOrderByAggregateInput
    _min?: UserPrivilegeMinOrderByAggregateInput
  }

  export type UserPrivilegeScalarWhereWithAggregatesInput = {
    AND?: UserPrivilegeScalarWhereWithAggregatesInput | UserPrivilegeScalarWhereWithAggregatesInput[]
    OR?: UserPrivilegeScalarWhereWithAggregatesInput[]
    NOT?: UserPrivilegeScalarWhereWithAggregatesInput | UserPrivilegeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPrivilege"> | string
    userId?: StringWithAggregatesFilter<"UserPrivilege"> | string
    privilegeId?: StringWithAggregatesFilter<"UserPrivilege"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserPrivilege"> | Date | string
  }

  export type VidesWhereInput = {
    AND?: VidesWhereInput | VidesWhereInput[]
    OR?: VidesWhereInput[]
    NOT?: VidesWhereInput | VidesWhereInput[]
    id?: StringFilter<"Vides"> | string
    videoUrl?: StringFilter<"Vides"> | string
    title?: StringFilter<"Vides"> | string
    description?: StringFilter<"Vides"> | string
    hyperLink?: StringFilter<"Vides"> | string
    price?: FloatNullableFilter<"Vides"> | number | null
    createdAt?: DateTimeFilter<"Vides"> | Date | string
    updatedAt?: DateTimeFilter<"Vides"> | Date | string
    productId?: StringNullableFilter<"Vides"> | string | null
  }

  export type VidesOrderByWithRelationInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _relevance?: VidesOrderByRelevanceInput
  }

  export type VidesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VidesWhereInput | VidesWhereInput[]
    OR?: VidesWhereInput[]
    NOT?: VidesWhereInput | VidesWhereInput[]
    videoUrl?: StringFilter<"Vides"> | string
    title?: StringFilter<"Vides"> | string
    description?: StringFilter<"Vides"> | string
    hyperLink?: StringFilter<"Vides"> | string
    price?: FloatNullableFilter<"Vides"> | number | null
    createdAt?: DateTimeFilter<"Vides"> | Date | string
    updatedAt?: DateTimeFilter<"Vides"> | Date | string
    productId?: StringNullableFilter<"Vides"> | string | null
  }, "id">

  export type VidesOrderByWithAggregationInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: VidesCountOrderByAggregateInput
    _avg?: VidesAvgOrderByAggregateInput
    _max?: VidesMaxOrderByAggregateInput
    _min?: VidesMinOrderByAggregateInput
    _sum?: VidesSumOrderByAggregateInput
  }

  export type VidesScalarWhereWithAggregatesInput = {
    AND?: VidesScalarWhereWithAggregatesInput | VidesScalarWhereWithAggregatesInput[]
    OR?: VidesScalarWhereWithAggregatesInput[]
    NOT?: VidesScalarWhereWithAggregatesInput | VidesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vides"> | string
    videoUrl?: StringWithAggregatesFilter<"Vides"> | string
    title?: StringWithAggregatesFilter<"Vides"> | string
    description?: StringWithAggregatesFilter<"Vides"> | string
    hyperLink?: StringWithAggregatesFilter<"Vides"> | string
    price?: FloatNullableWithAggregatesFilter<"Vides"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Vides"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vides"> | Date | string
    productId?: StringNullableWithAggregatesFilter<"Vides"> | string | null
  }

  export type VisitorWhereInput = {
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    id?: StringFilter<"Visitor"> | string
    ipAddress?: StringFilter<"Visitor"> | string
    cookieId?: StringNullableFilter<"Visitor"> | string | null
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
  }

  export type VisitorOrderByWithRelationInput = {
    id?: SortOrder
    ipAddress?: SortOrder
    cookieId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: VisitorOrderByRelevanceInput
  }

  export type VisitorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ipAddress?: string
    cookieId?: string
    AND?: VisitorWhereInput | VisitorWhereInput[]
    OR?: VisitorWhereInput[]
    NOT?: VisitorWhereInput | VisitorWhereInput[]
    createdAt?: DateTimeFilter<"Visitor"> | Date | string
  }, "id" | "ipAddress" | "cookieId">

  export type VisitorOrderByWithAggregationInput = {
    id?: SortOrder
    ipAddress?: SortOrder
    cookieId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VisitorCountOrderByAggregateInput
    _max?: VisitorMaxOrderByAggregateInput
    _min?: VisitorMinOrderByAggregateInput
  }

  export type VisitorScalarWhereWithAggregatesInput = {
    AND?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    OR?: VisitorScalarWhereWithAggregatesInput[]
    NOT?: VisitorScalarWhereWithAggregatesInput | VisitorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Visitor"> | string
    ipAddress?: StringWithAggregatesFilter<"Visitor"> | string
    cookieId?: StringNullableWithAggregatesFilter<"Visitor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Visitor"> | Date | string
  }

  export type WishlistItemWhereInput = {
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    id?: StringFilter<"WishlistItem"> | string
    userId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WishlistItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    Product?: ProductOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    _relevance?: WishlistItemOrderByRelevanceInput
  }

  export type WishlistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WishlistItemWhereInput | WishlistItemWhereInput[]
    OR?: WishlistItemWhereInput[]
    NOT?: WishlistItemWhereInput | WishlistItemWhereInput[]
    userId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
    Product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type WishlistItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    _count?: WishlistItemCountOrderByAggregateInput
    _max?: WishlistItemMaxOrderByAggregateInput
    _min?: WishlistItemMinOrderByAggregateInput
  }

  export type WishlistItemScalarWhereWithAggregatesInput = {
    AND?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    OR?: WishlistItemScalarWhereWithAggregatesInput[]
    NOT?: WishlistItemScalarWhereWithAggregatesInput | WishlistItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WishlistItem"> | string
    userId?: StringWithAggregatesFilter<"WishlistItem"> | string
    productId?: StringWithAggregatesFilter<"WishlistItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WishlistItem"> | Date | string
  }

  export type AnchorTextCreateInput = {
    id: string
    data: string
    createdAt?: Date | string
    updatedAt: Date | string
    ProductCategory: ProductCategoryCreateNestedOneWithoutAnchorTextInput
  }

  export type AnchorTextUncheckedCreateInput = {
    id: string
    categoryId: string
    data: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AnchorTextUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutAnchorTextNestedInput
  }

  export type AnchorTextUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnchorTextCreateManyInput = {
    id: string
    categoryId: string
    data: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AnchorTextUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnchorTextUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementsCreateInput = {
    id: string
    text?: string | null
  }

  export type AnnouncementsUncheckedCreateInput = {
    id: string
    text?: string | null
  }

  export type AnnouncementsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnouncementsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnouncementsCreateManyInput = {
    id: string
    text?: string | null
  }

  export type AnnouncementsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnouncementsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    id: string
    action: string
    description?: string | null
    createdAt?: Date | string
    User?: UserCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateInput = {
    id: string
    userId?: string | null
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id: string
    userId?: string | null
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BestSellingCreateInput = {
    id: string
    title: string
    hyperLink: string
    price: string
  }

  export type BestSellingUncheckedCreateInput = {
    id: string
    title: string
    hyperLink: string
    price: string
  }

  export type BestSellingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
  }

  export type BestSellingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
  }

  export type BestSellingCreateManyInput = {
    id: string
    title: string
    hyperLink: string
    price: string
  }

  export type BestSellingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
  }

  export type BestSellingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
  }

  export type CallRequestCreateInput = {
    id: string
    mobileNumber: string
    orderId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CallRequestUncheckedCreateInput = {
    id: string
    mobileNumber: string
    orderId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CallRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRequestCreateManyInput = {
    id: string
    mobileNumber: string
    orderId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CallRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    ProductColor?: ProductColorCreateNestedOneWithoutCartItemInput
    ProductImage?: ProductImageCreateNestedOneWithoutCartItemInput
    Product: ProductCreateNestedOneWithoutCartItemInput
    User: UserCreateNestedOneWithoutCartItemInput
  }

  export type CartItemUncheckedCreateInput = {
    id: string
    userId: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    sizeId?: string | null
    imageId?: string | null
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductColor?: ProductColorUpdateOneWithoutCartItemNestedInput
    ProductImage?: ProductImageUpdateOneWithoutCartItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    User?: UserUpdateOneRequiredWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemCreateManyInput = {
    id: string
    userId: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    sizeId?: string | null
    imageId?: string | null
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUsCreateInput = {
    id: string
    name: string
    email: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ContactUsUncheckedCreateInput = {
    id: string
    name: string
    email: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ContactUsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsCreateManyInput = {
    id: string
    name: string
    email: string
    message: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ContactUsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerTypeCreateInput = {
    id: string
    name: string
    slug: string
    productId?: string | null
    Product?: ProductCreateNestedManyWithoutCustomerTypeInput
  }

  export type CustomerTypeUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    productId?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutCustomerTypeInput
  }

  export type CustomerTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutCustomerTypeNestedInput
  }

  export type CustomerTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutCustomerTypeNestedInput
  }

  export type CustomerTypeCreateManyInput = {
    id: string
    name: string
    slug: string
    productId?: string | null
  }

  export type CustomerTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeleteRequestCreateInput = {
    id: string
    userName?: string | null
    userEmail?: string | null
    reason?: string | null
    status?: $Enums.DeleteRequest_status
    createdAt?: Date | string
    User?: UserCreateNestedOneWithoutDeleteRequestInput
  }

  export type DeleteRequestUncheckedCreateInput = {
    id: string
    userId?: string | null
    userName?: string | null
    userEmail?: string | null
    reason?: string | null
    status?: $Enums.DeleteRequest_status
    createdAt?: Date | string
  }

  export type DeleteRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeleteRequest_statusFieldUpdateOperationsInput | $Enums.DeleteRequest_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutDeleteRequestNestedInput
  }

  export type DeleteRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeleteRequest_statusFieldUpdateOperationsInput | $Enums.DeleteRequest_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeleteRequestCreateManyInput = {
    id: string
    userId?: string | null
    userName?: string | null
    userEmail?: string | null
    reason?: string | null
    status?: $Enums.DeleteRequest_status
    createdAt?: Date | string
  }

  export type DeleteRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeleteRequest_statusFieldUpdateOperationsInput | $Enums.DeleteRequest_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeleteRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeleteRequest_statusFieldUpdateOperationsInput | $Enums.DeleteRequest_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountCreateInput = {
    id: string
    code: string
    description?: string | null
    amount: number
    type: $Enums.Discount_type
    createdAt?: Date | string
    updatedAt: Date | string
    maxPrice?: number | null
    minPrice?: number | null
    isActive?: boolean
    isSpecial?: boolean
    orders?: number | null
    userEmails: JsonNullValueInput | InputJsonValue
    isWebAvailable?: boolean
    isCODAvailable?: boolean
    Product?: ProductCreateNestedOneWithoutDiscountInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUncheckedCreateInput = {
    id: string
    code: string
    description?: string | null
    amount: number
    type: $Enums.Discount_type
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
    maxPrice?: number | null
    minPrice?: number | null
    isActive?: boolean
    isSpecial?: boolean
    orders?: number | null
    userEmails: JsonNullValueInput | InputJsonValue
    isWebAvailable?: boolean
    isCODAvailable?: boolean
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumDiscount_typeFieldUpdateOperationsInput | $Enums.Discount_type
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    orders?: NullableIntFieldUpdateOperationsInput | number | null
    userEmails?: JsonNullValueInput | InputJsonValue
    isWebAvailable?: BoolFieldUpdateOperationsInput | boolean
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    Product?: ProductUpdateOneWithoutDiscountNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumDiscount_typeFieldUpdateOperationsInput | $Enums.Discount_type
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    orders?: NullableIntFieldUpdateOperationsInput | number | null
    userEmails?: JsonNullValueInput | InputJsonValue
    isWebAvailable?: BoolFieldUpdateOperationsInput | boolean
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountCreateManyInput = {
    id: string
    code: string
    description?: string | null
    amount: number
    type: $Enums.Discount_type
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
    maxPrice?: number | null
    minPrice?: number | null
    isActive?: boolean
    isSpecial?: boolean
    orders?: number | null
    userEmails: JsonNullValueInput | InputJsonValue
    isWebAvailable?: boolean
    isCODAvailable?: boolean
  }

  export type DiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumDiscount_typeFieldUpdateOperationsInput | $Enums.Discount_type
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    orders?: NullableIntFieldUpdateOperationsInput | number | null
    userEmails?: JsonNullValueInput | InputJsonValue
    isWebAvailable?: BoolFieldUpdateOperationsInput | boolean
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumDiscount_typeFieldUpdateOperationsInput | $Enums.Discount_type
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    orders?: NullableIntFieldUpdateOperationsInput | number | null
    userEmails?: JsonNullValueInput | InputJsonValue
    isWebAvailable?: BoolFieldUpdateOperationsInput | boolean
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DropMessageCreateInput = {
    id: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutDropMessageInput
  }

  export type DropMessageUncheckedCreateInput = {
    id: string
    userId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DropMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutDropMessageNestedInput
  }

  export type DropMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropMessageCreateManyInput = {
    id: string
    userId: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DropMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExclusiveCollectionCreateInput = {
    id: string
    imageUrl?: string | null
    hyperLink?: string | null
    categoryHyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mrp?: number | null
    price?: number | null
  }

  export type ExclusiveCollectionUncheckedCreateInput = {
    id: string
    imageUrl?: string | null
    hyperLink?: string | null
    categoryHyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mrp?: number | null
    price?: number | null
  }

  export type ExclusiveCollectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mrp?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExclusiveCollectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mrp?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExclusiveCollectionCreateManyInput = {
    id: string
    imageUrl?: string | null
    hyperLink?: string | null
    categoryHyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mrp?: number | null
    price?: number | null
  }

  export type ExclusiveCollectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mrp?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExclusiveCollectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mrp?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type HeroSlidersCreateInput = {
    id: string
    imageUrl: string
    hyperLink: string
    categoryHyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type HeroSlidersUncheckedCreateInput = {
    id: string
    imageUrl: string
    hyperLink: string
    categoryHyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type HeroSlidersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSlidersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSlidersCreateManyInput = {
    id: string
    imageUrl: string
    hyperLink: string
    categoryHyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type HeroSlidersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroSlidersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageWeekCreateInput = {
    id: string
    hyperLink?: string | null
    imageUrl?: string | null
  }

  export type ImageWeekUncheckedCreateInput = {
    id: string
    hyperLink?: string | null
    imageUrl?: string | null
  }

  export type ImageWeekUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageWeekUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageWeekCreateManyInput = {
    id: string
    hyperLink?: string | null
    imageUrl?: string | null
  }

  export type ImageWeekUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageWeekUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogosCreateInput = {
    id: string
    logoUrl: string
    isActive?: boolean
    altText?: string | null
  }

  export type LogosUncheckedCreateInput = {
    id: string
    logoUrl: string
    isActive?: boolean
    altText?: string | null
  }

  export type LogosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    logoUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    altText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    logoUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    altText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogosCreateManyInput = {
    id: string
    logoUrl: string
    isActive?: boolean
    altText?: string | null
  }

  export type LogosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    logoUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    altText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    logoUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    altText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateInput = {
    id: string
    message: string
    createdAt?: Date | string
    User_Message_handledByIdToUser?: UserCreateNestedOneWithoutMessage_Message_handledByIdToUserInput
    User_Message_receiverIdToUser: UserCreateNestedOneWithoutMessage_Message_receiverIdToUserInput
    User_Message_senderIdToUser: UserCreateNestedOneWithoutMessage_Message_senderIdToUserInput
  }

  export type MessageUncheckedCreateInput = {
    id: string
    senderId: string
    receiverId: string
    message: string
    createdAt?: Date | string
    handledById?: string | null
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Message_handledByIdToUser?: UserUpdateOneWithoutMessage_Message_handledByIdToUserNestedInput
    User_Message_receiverIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_receiverIdToUserNestedInput
    User_Message_senderIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_senderIdToUserNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyInput = {
    id: string
    senderId: string
    receiverId: string
    message: string
    createdAt?: Date | string
    handledById?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewArrivalsCreateInput = {
    id: string
    imageUrl?: string | null
    hyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    description?: string | null
    mrp?: number | null
    price?: number | null
    title?: string | null
  }

  export type NewArrivalsUncheckedCreateInput = {
    id: string
    imageUrl?: string | null
    hyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    description?: string | null
    mrp?: number | null
    price?: number | null
    title?: string | null
  }

  export type NewArrivalsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewArrivalsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewArrivalsCreateManyInput = {
    id: string
    imageUrl?: string | null
    hyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    description?: string | null
    mrp?: number | null
    price?: number | null
    title?: string | null
  }

  export type NewArrivalsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewArrivalsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableFloatFieldUpdateOperationsInput | number | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NewsletterCreateInput = {
    id: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NewsletterUncheckedCreateInput = {
    id: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NewsletterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterCreateManyInput = {
    id: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NewsletterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsletterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    hyperLink?: string | null
    title: string
    User: UserCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id: string
    userId: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    hyperLink?: string | null
    title: string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id: string
    userId: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    hyperLink?: string | null
    title: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type OrderDetailsCreateInput = {
    id: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    finalPrice?: number | null
    UserAddress?: UserAddressCreateNestedOneWithoutOrderDetailsInput
    Discount?: DiscountCreateNestedOneWithoutOrderDetailsInput
    User: UserCreateNestedOneWithoutOrderDetailsInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderDetailsInput
    PaymentDetails?: PaymentDetailsCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsUncheckedCreateInput = {
    id: string
    userId: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    discountId?: string | null
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    addressId?: string | null
    finalPrice?: number | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderDetailsInput
    PaymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    UserAddress?: UserAddressUpdateOneWithoutOrderDetailsNestedInput
    Discount?: DiscountUpdateOneWithoutOrderDetailsNestedInput
    User?: UserUpdateOneRequiredWithoutOrderDetailsNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderDetailsNestedInput
    PaymentDetails?: PaymentDetailsUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderDetailsNestedInput
    PaymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsCreateManyInput = {
    id: string
    userId: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    discountId?: string | null
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    addressId?: string | null
    finalPrice?: number | null
  }

  export type OrderDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemCreateInput = {
    id: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    isReviewed?: boolean
    ProductColor?: ProductColorCreateNestedOneWithoutOrderItemInput
    ProductImage?: ProductImageCreateNestedOneWithoutOrderItemInput
    OrderDetails: OrderDetailsCreateNestedOneWithoutOrderItemInput
    Product: ProductCreateNestedOneWithoutOrderItemInput
    ProductSize?: ProductSizeCreateNestedOneWithoutOrderItemInput
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    colorId?: string | null
    imageId?: string | null
    isReviewed?: boolean
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ProductColor?: ProductColorUpdateOneWithoutOrderItemNestedInput
    ProductImage?: ProductImageUpdateOneWithoutOrderItemNestedInput
    OrderDetails?: OrderDetailsUpdateOneRequiredWithoutOrderItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
    ProductSize?: ProductSizeUpdateOneWithoutOrderItemNestedInput
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemCreateManyInput = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    colorId?: string | null
    imageId?: string | null
    isReviewed?: boolean
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OtpCreateInput = {
    id: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutOtpInput
  }

  export type OtpUncheckedCreateInput = {
    id: string
    userId: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutOtpNestedInput
  }

  export type OtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateManyInput = {
    id: string
    userId: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentDetailsCreateInput = {
    id: string
    amount: number
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: string | null
    currency: string
    method: string
    order_id: string
    payment_id: string
    upi?: string | null
    wallet?: string | null
    OrderDetails: OrderDetailsCreateNestedOneWithoutPaymentDetailsInput
  }

  export type PaymentDetailsUncheckedCreateInput = {
    id: string
    orderId: string
    amount: number
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: string | null
    currency: string
    method: string
    order_id: string
    payment_id: string
    upi?: string | null
    wallet?: string | null
  }

  export type PaymentDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDetails?: OrderDetailsUpdateOneRequiredWithoutPaymentDetailsNestedInput
  }

  export type PaymentDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentDetailsCreateManyInput = {
    id: string
    orderId: string
    amount: number
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: string | null
    currency: string
    method: string
    order_id: string
    payment_id: string
    upi?: string | null
    wallet?: string | null
  }

  export type PaymentDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivilegeCreateInput = {
    id: string
    name: string
    label?: string | null
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutPrivilegeInput
  }

  export type PrivilegeUncheckedCreateInput = {
    id: string
    name: string
    label?: string | null
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutPrivilegeInput
  }

  export type PrivilegeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    UserPrivilege?: UserPrivilegeUpdateManyWithoutPrivilegeNestedInput
  }

  export type PrivilegeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutPrivilegeNestedInput
  }

  export type PrivilegeCreateManyInput = {
    id: string
    name: string
    label?: string | null
  }

  export type PrivilegeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivilegeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryCreateInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    AnchorText?: AnchorTextCreateNestedOneWithoutProductCategoryInput
    Quotes?: QuotesCreateNestedManyWithoutProductCategoryInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductCategoryInput
    Product?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    AnchorText?: AnchorTextUncheckedCreateNestedOneWithoutProductCategoryInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutProductCategoryInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductCategoryInput
    Product?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    AnchorText?: AnchorTextUpdateOneWithoutProductCategoryNestedInput
    Quotes?: QuotesUpdateManyWithoutProductCategoryNestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductCategoryNestedInput
    Product?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    AnchorText?: AnchorTextUncheckedUpdateOneWithoutProductCategoryNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutProductCategoryNestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductCategoryNestedInput
    Product?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductColorCreateInput = {
    id: string
    name: string
    code: string
    slug: string
    CartItem?: CartItemCreateNestedManyWithoutProductColorInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductColorInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUncheckedCreateInput = {
    id: string
    name: string
    code: string
    slug: string
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductColorInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductColorInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    CartItem?: CartItemUpdateManyWithoutProductColorNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductColorNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    CartItem?: CartItemUncheckedUpdateManyWithoutProductColorNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductColorNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorCreateManyInput = {
    id: string
    name: string
    code: string
    slug: string
  }

  export type ProductColorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductColorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductFabricCreateInput = {
    id: string
    name: string
    slug: string
    Product?: ProductCreateNestedManyWithoutProductFabricInput
  }

  export type ProductFabricUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    Product?: ProductUncheckedCreateNestedManyWithoutProductFabricInput
  }

  export type ProductFabricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Product?: ProductUpdateManyWithoutProductFabricNestedInput
  }

  export type ProductFabricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    Product?: ProductUncheckedUpdateManyWithoutProductFabricNestedInput
  }

  export type ProductFabricCreateManyInput = {
    id: string
    name: string
    slug: string
  }

  export type ProductFabricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductFabricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductImageCreateInput = {
    id: string
    imageUrl: string
    altText?: string | null
    caption?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductImageInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductImageInput
    ProductColor?: ProductColorCreateNestedOneWithoutProductImageInput
    Product: ProductCreateNestedOneWithoutProductImageInput
  }

  export type ProductImageUncheckedCreateInput = {
    id: string
    productId: string
    imageUrl: string
    colorId?: string | null
    altText?: string | null
    caption?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductImageInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductImageInput
  }

  export type ProductImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductImageNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductImageNestedInput
    ProductColor?: ProductColorUpdateOneWithoutProductImageNestedInput
    Product?: ProductUpdateOneRequiredWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductImageNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductImageNestedInput
  }

  export type ProductImageCreateManyInput = {
    id: string
    productId: string
    imageUrl: string
    colorId?: string | null
    altText?: string | null
    caption?: string | null
  }

  export type ProductImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductInventoryCreateInput = {
    id: string
    mrp: number
    price: number
    stock: number
    minQuantity?: number
    discount?: number | null
    Product: ProductCreateNestedOneWithoutProductInventoryInput
    ProductSize?: ProductSizeCreateNestedOneWithoutProductInventoryInput
  }

  export type ProductInventoryUncheckedCreateInput = {
    id: string
    productId: string
    mrp: number
    price: number
    sizeId?: string | null
    stock: number
    minQuantity?: number
    discount?: number | null
  }

  export type ProductInventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    Product?: ProductUpdateOneRequiredWithoutProductInventoryNestedInput
    ProductSize?: ProductSizeUpdateOneWithoutProductInventoryNestedInput
  }

  export type ProductInventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductInventoryCreateManyInput = {
    id: string
    productId: string
    mrp: number
    price: number
    sizeId?: string | null
    stock: number
    minQuantity?: number
    discount?: number | null
  }

  export type ProductInventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductInventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductReviewCreateInput = {
    id: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    images: JsonNullValueInput | InputJsonValue
    Product: ProductCreateNestedOneWithoutProductReviewInput
    User: UserCreateNestedOneWithoutProductReviewInput
  }

  export type ProductReviewUncheckedCreateInput = {
    id: string
    userId: string
    productId: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    images: JsonNullValueInput | InputJsonValue
  }

  export type ProductReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
    Product?: ProductUpdateOneRequiredWithoutProductReviewNestedInput
    User?: UserUpdateOneRequiredWithoutProductReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
  }

  export type ProductReviewCreateManyInput = {
    id: string
    userId: string
    productId: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    images: JsonNullValueInput | InputJsonValue
  }

  export type ProductReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
  }

  export type ProductReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
  }

  export type ProductSizeCreateInput = {
    id: string
    name: string
    slug: string
    OrderItem?: OrderItemCreateNestedManyWithoutProductSizeInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductSizeInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    OrderItem?: OrderItemUpdateManyWithoutProductSizeNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductSizeNestedInput
  }

  export type ProductSizeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductSizeNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductSizeNestedInput
  }

  export type ProductSizeCreateManyInput = {
    id: string
    name: string
    slug: string
  }

  export type ProductSizeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductSizeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductWeekCreateInput = {
    id: string
    title?: string | null
    hyperLink?: string | null
    imageUrl?: string | null
  }

  export type ProductWeekUncheckedCreateInput = {
    id: string
    title?: string | null
    hyperLink?: string | null
    imageUrl?: string | null
  }

  export type ProductWeekUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductWeekUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductWeekCreateManyInput = {
    id: string
    title?: string | null
    hyperLink?: string | null
    imageUrl?: string | null
  }

  export type ProductWeekUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductWeekUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotesCreateInput = {
    id: string
    text?: string | null
    imageUrl?: string | null
    hyperLink?: string | null
    ProductCategory: ProductCategoryCreateNestedOneWithoutQuotesInput
  }

  export type QuotesUncheckedCreateInput = {
    id: string
    text?: string | null
    imageUrl?: string | null
    hyperLink?: string | null
    categoryId: string
  }

  export type QuotesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type QuotesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type QuotesCreateManyInput = {
    id: string
    text?: string | null
    imageUrl?: string | null
    hyperLink?: string | null
    categoryId: string
  }

  export type QuotesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ReturnRequestCreateInput = {
    id: string
    reason: string
    status?: $Enums.ReturnRequest_status
    requestedAt?: Date | string
    resolvedAt?: Date | string | null
    OrderItem: OrderItemCreateNestedOneWithoutReturnRequestInput
  }

  export type ReturnRequestUncheckedCreateInput = {
    id: string
    orderItemId: string
    reason: string
    status?: $Enums.ReturnRequest_status
    requestedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReturnRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnRequest_statusFieldUpdateOperationsInput | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderItem?: OrderItemUpdateOneRequiredWithoutReturnRequestNestedInput
  }

  export type ReturnRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnRequest_statusFieldUpdateOperationsInput | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnRequestCreateManyInput = {
    id: string
    orderItemId: string
    reason: string
    status?: $Enums.ReturnRequest_status
    requestedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReturnRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnRequest_statusFieldUpdateOperationsInput | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnRequest_statusFieldUpdateOperationsInput | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RewardsCreateInput = {
    id: string
    title?: string | null
    code?: string | null
    description?: string | null
    User: UserCreateNestedOneWithoutRewardsInput
  }

  export type RewardsUncheckedCreateInput = {
    id: string
    userId: string
    title?: string | null
    code?: string | null
    description?: string | null
  }

  export type RewardsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type RewardsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardsCreateManyInput = {
    id: string
    userId: string
    title?: string | null
    code?: string | null
    description?: string | null
  }

  export type RewardsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SearchQueryCreateInput = {
    id: string
    query: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutSearchQueryInput
  }

  export type SearchQueryUncheckedCreateInput = {
    id: string
    query: string
    createdAt?: Date | string
    userId: string
  }

  export type SearchQueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutSearchQueryNestedInput
  }

  export type SearchQueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SearchQueryCreateManyInput = {
    id: string
    query: string
    createdAt?: Date | string
    userId: string
  }

  export type SearchQueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    id: string
    token: string
    createdAt?: Date | string
    updatedAt: Date | string
    expiresAt?: Date | string | null
    User: UserCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    userId: string
    token: string
    createdAt?: Date | string
    updatedAt: Date | string
    expiresAt?: Date | string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyInput = {
    id: string
    userId: string
    token: string
    createdAt?: Date | string
    updatedAt: Date | string
    expiresAt?: Date | string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShopByOccasionCreateInput = {
    id: string
    occasionName?: string | null
    categoryHyperLinks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ShopByOccasionProduct?: ShopByOccasionProductCreateNestedManyWithoutShopByOccasionInput
  }

  export type ShopByOccasionUncheckedCreateInput = {
    id: string
    occasionName?: string | null
    categoryHyperLinks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ShopByOccasionProduct?: ShopByOccasionProductUncheckedCreateNestedManyWithoutShopByOccasionInput
  }

  export type ShopByOccasionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occasionName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLinks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopByOccasionProduct?: ShopByOccasionProductUpdateManyWithoutShopByOccasionNestedInput
  }

  export type ShopByOccasionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occasionName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLinks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopByOccasionProduct?: ShopByOccasionProductUncheckedUpdateManyWithoutShopByOccasionNestedInput
  }

  export type ShopByOccasionCreateManyInput = {
    id: string
    occasionName?: string | null
    categoryHyperLinks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopByOccasionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    occasionName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLinks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopByOccasionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    occasionName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLinks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopByOccasionProductCreateInput = {
    id: string
    imageUrl: string
    hyperLink: string
    createdAt?: Date | string
    updatedAt: Date | string
    ShopByOccasion?: ShopByOccasionCreateNestedOneWithoutShopByOccasionProductInput
  }

  export type ShopByOccasionProductUncheckedCreateInput = {
    id: string
    imageUrl: string
    hyperLink: string
    shopByOccasionId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopByOccasionProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopByOccasion?: ShopByOccasionUpdateOneWithoutShopByOccasionProductNestedInput
  }

  export type ShopByOccasionProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    shopByOccasionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopByOccasionProductCreateManyInput = {
    id: string
    imageUrl: string
    hyperLink: string
    shopByOccasionId?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopByOccasionProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopByOccasionProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    shopByOccasionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopBySeasonCreateInput = {
    id: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ShopBySeasonProduct?: ShopBySeasonProductCreateNestedManyWithoutShopBySeasonInput
  }

  export type ShopBySeasonUncheckedCreateInput = {
    id: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    ShopBySeasonProduct?: ShopBySeasonProductUncheckedCreateNestedManyWithoutShopBySeasonInput
  }

  export type ShopBySeasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopBySeasonProduct?: ShopBySeasonProductUpdateManyWithoutShopBySeasonNestedInput
  }

  export type ShopBySeasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShopBySeasonProduct?: ShopBySeasonProductUncheckedUpdateManyWithoutShopBySeasonNestedInput
  }

  export type ShopBySeasonCreateManyInput = {
    id: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopBySeasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopBySeasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopBySeasonProductCreateInput = {
    id: string
    imageUrl: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    hyperLink: string
    ShopBySeason: ShopBySeasonCreateNestedOneWithoutShopBySeasonProductInput
  }

  export type ShopBySeasonProductUncheckedCreateInput = {
    id: string
    imageUrl: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    seasonId: string
    hyperLink: string
  }

  export type ShopBySeasonProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    ShopBySeason?: ShopBySeasonUpdateOneRequiredWithoutShopBySeasonProductNestedInput
  }

  export type ShopBySeasonProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
  }

  export type ShopBySeasonProductCreateManyInput = {
    id: string
    imageUrl: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    seasonId: string
    hyperLink: string
  }

  export type ShopBySeasonProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: StringFieldUpdateOperationsInput | string
  }

  export type ShopBySeasonProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonId?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
  }

  export type ShowcasesCreateInput = {
    id: string
    title: string
    imageUrl: string
    hyperLink: string
    categoryHyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShowcasesUncheckedCreateInput = {
    id: string
    title: string
    imageUrl: string
    hyperLink: string
    categoryHyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShowcasesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowcasesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowcasesCreateManyInput = {
    id: string
    title: string
    imageUrl: string
    hyperLink: string
    categoryHyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShowcasesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowcasesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    categoryHyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SizeChartCreateInput = {
    id: string
    title?: string | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
    Product?: ProductCreateNestedManyWithoutSizeChartInput
  }

  export type SizeChartUncheckedCreateInput = {
    id: string
    title?: string | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutSizeChartInput
  }

  export type SizeChartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutSizeChartNestedInput
  }

  export type SizeChartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutSizeChartNestedInput
  }

  export type SizeChartCreateManyInput = {
    id: string
    title?: string | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
  }

  export type SizeChartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SizeChartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLinksCreateInput = {
    id: string
    imageUrl?: string | null
    hyperLink?: string | null
  }

  export type SocialLinksUncheckedCreateInput = {
    id: string
    imageUrl?: string | null
    hyperLink?: string | null
  }

  export type SocialLinksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLinksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLinksCreateManyInput = {
    id: string
    imageUrl?: string | null
    hyperLink?: string | null
  }

  export type SocialLinksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLinksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StaticMessagesCreateInput = {
    id: string
    status?: $Enums.StaticMessages_status
    message: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutStaticMessagesInput
  }

  export type StaticMessagesUncheckedCreateInput = {
    id: string
    userId: string
    status?: $Enums.StaticMessages_status
    message: string
    createdAt?: Date | string
  }

  export type StaticMessagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaticMessages_statusFieldUpdateOperationsInput | $Enums.StaticMessages_status
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutStaticMessagesNestedInput
  }

  export type StaticMessagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStaticMessages_statusFieldUpdateOperationsInput | $Enums.StaticMessages_status
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticMessagesCreateManyInput = {
    id: string
    userId: string
    status?: $Enums.StaticMessages_status
    message: string
    createdAt?: Date | string
  }

  export type StaticMessagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaticMessages_statusFieldUpdateOperationsInput | $Enums.StaticMessages_status
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticMessagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumStaticMessages_statusFieldUpdateOperationsInput | $Enums.StaticMessages_status
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubCategoryCreateInput = {
    id: string
    name: string
    slug: string
    imageUrl?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    ProductCategory: ProductCategoryCreateNestedOneWithoutSubCategoryInput
    Product?: ProductCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    categoryId: string
    imageUrl?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutSubCategoryNestedInput
    Product?: ProductUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryCreateManyInput = {
    id: string
    name: string
    slug: string
    categoryId: string
    imageUrl?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
  }

  export type SubCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupportTicketCreateInput = {
    id: string
    subject: string
    message: string
    status?: $Enums.SupportTicket_status
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    User: UserCreateNestedOneWithoutSupportTicketInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id: string
    userId: string
    subject: string
    message: string
    status?: $Enums.SupportTicket_status
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicket_statusFieldUpdateOperationsInput | $Enums.SupportTicket_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutSupportTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicket_statusFieldUpdateOperationsInput | $Enums.SupportTicket_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketCreateManyInput = {
    id: string
    userId: string
    subject: string
    message: string
    status?: $Enums.SupportTicket_status
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicket_statusFieldUpdateOperationsInput | $Enums.SupportTicket_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicket_statusFieldUpdateOperationsInput | $Enums.SupportTicket_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagsCreateInput = {
    id: string
    tag: string
  }

  export type TagsUncheckedCreateInput = {
    id: string
    tag: string
  }

  export type TagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TagsCreateManyInput = {
    id: string
    tag: string
  }

  export type TagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type TrendingCreateInput = {
    id: string
    videoUrl?: string | null
    title?: string | null
    price?: string | null
    hyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    avatarUrl?: string | null
  }

  export type TrendingUncheckedCreateInput = {
    id: string
    videoUrl?: string | null
    title?: string | null
    price?: string | null
    hyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    avatarUrl?: string | null
  }

  export type TrendingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrendingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrendingCreateManyInput = {
    id: string
    videoUrl?: string | null
    title?: string | null
    price?: string | null
    hyperLink?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    avatarUrl?: string | null
  }

  export type TrendingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrendingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UpdateHistoryCreateInput = {
    id: string
    title: string
    description: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutUpdateHistoryInput
  }

  export type UpdateHistoryUncheckedCreateInput = {
    id: string
    userId: string
    title: string
    description: string
    createdAt?: Date | string
  }

  export type UpdateHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutUpdateHistoryNestedInput
  }

  export type UpdateHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpdateHistoryCreateManyInput = {
    id: string
    userId: string
    title: string
    description: string
    createdAt?: Date | string
  }

  export type UpdateHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpdateHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAddressCreateInput = {
    id: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country: string
    mobileNumber: string
    createdAt?: Date | string
    updatedAt: Date | string
    isDefault: boolean
    fullName?: string | null
    altMobileNumber?: string | null
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserAddressInput
    User: UserCreateNestedOneWithoutUserAddressInput
  }

  export type UserAddressUncheckedCreateInput = {
    id: string
    userId: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country: string
    mobileNumber: string
    createdAt?: Date | string
    updatedAt: Date | string
    isDefault: boolean
    fullName?: string | null
    altMobileNumber?: string | null
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserAddressInput
  }

  export type UserAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    altMobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDetails?: OrderDetailsUpdateManyWithoutUserAddressNestedInput
    User?: UserUpdateOneRequiredWithoutUserAddressNestedInput
  }

  export type UserAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    altMobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserAddressNestedInput
  }

  export type UserAddressCreateManyInput = {
    id: string
    userId: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country: string
    mobileNumber: string
    createdAt?: Date | string
    updatedAt: Date | string
    isDefault: boolean
    fullName?: string | null
    altMobileNumber?: string | null
  }

  export type UserAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    altMobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    altMobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPrivilegeCreateInput = {
    id: string
    createdAt?: Date | string
    Privilege: PrivilegeCreateNestedOneWithoutUserPrivilegeInput
    User: UserCreateNestedOneWithoutUserPrivilegeInput
  }

  export type UserPrivilegeUncheckedCreateInput = {
    id: string
    userId: string
    privilegeId: string
    createdAt?: Date | string
  }

  export type UserPrivilegeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Privilege?: PrivilegeUpdateOneRequiredWithoutUserPrivilegeNestedInput
    User?: UserUpdateOneRequiredWithoutUserPrivilegeNestedInput
  }

  export type UserPrivilegeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    privilegeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPrivilegeCreateManyInput = {
    id: string
    userId: string
    privilegeId: string
    createdAt?: Date | string
  }

  export type UserPrivilegeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPrivilegeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    privilegeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VidesCreateInput = {
    id: string
    videoUrl: string
    title: string
    description: string
    hyperLink: string
    price?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
  }

  export type VidesUncheckedCreateInput = {
    id: string
    videoUrl: string
    title: string
    description: string
    hyperLink: string
    price?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
  }

  export type VidesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VidesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VidesCreateManyInput = {
    id: string
    videoUrl: string
    title: string
    description: string
    hyperLink: string
    price?: number | null
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
  }

  export type VidesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VidesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisitorCreateInput = {
    id: string
    ipAddress: string
    cookieId?: string | null
    createdAt?: Date | string
  }

  export type VisitorUncheckedCreateInput = {
    id: string
    ipAddress: string
    cookieId?: string | null
    createdAt?: Date | string
  }

  export type VisitorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    cookieId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    cookieId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorCreateManyInput = {
    id: string
    ipAddress: string
    cookieId?: string | null
    createdAt?: Date | string
  }

  export type VisitorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    cookieId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    cookieId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateInput = {
    id: string
    createdAt?: Date | string
    Product: ProductCreateNestedOneWithoutWishlistItemInput
    User: UserCreateNestedOneWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateInput = {
    id: string
    userId: string
    productId: string
    createdAt?: Date | string
  }

  export type WishlistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutWishlistItemNestedInput
    User?: UserUpdateOneRequiredWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemCreateManyInput = {
    id: string
    userId: string
    productId: string
    createdAt?: Date | string
  }

  export type WishlistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProductCategoryScalarRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type AnchorTextOrderByRelevanceInput = {
    fields: AnchorTextOrderByRelevanceFieldEnum | AnchorTextOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnchorTextCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnchorTextMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnchorTextMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AnnouncementsOrderByRelevanceInput = {
    fields: AnnouncementsOrderByRelevanceFieldEnum | AnnouncementsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnnouncementsCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type AnnouncementsMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type AnnouncementsMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogOrderByRelevanceInput = {
    fields: AuditLogOrderByRelevanceFieldEnum | AuditLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type BestSellingOrderByRelevanceInput = {
    fields: BestSellingOrderByRelevanceFieldEnum | BestSellingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BestSellingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrder
  }

  export type BestSellingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrder
  }

  export type BestSellingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CallRequestOrderByRelevanceInput = {
    fields: CallRequestOrderByRelevanceFieldEnum | CallRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CallRequestCountOrderByAggregateInput = {
    id?: SortOrder
    mobileNumber?: SortOrder
    orderId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    mobileNumber?: SortOrder
    orderId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallRequestMinOrderByAggregateInput = {
    id?: SortOrder
    mobileNumber?: SortOrder
    orderId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProductColorNullableScalarRelationFilter = {
    is?: ProductColorWhereInput | null
    isNot?: ProductColorWhereInput | null
  }

  export type ProductImageNullableScalarRelationFilter = {
    is?: ProductImageWhereInput | null
    isNot?: ProductImageWhereInput | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CartItemOrderByRelevanceInput = {
    fields: CartItemOrderByRelevanceFieldEnum | CartItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    colorId?: SortOrder
    sizeId?: SortOrder
    imageId?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    colorId?: SortOrder
    sizeId?: SortOrder
    imageId?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    colorId?: SortOrder
    sizeId?: SortOrder
    imageId?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ContactUsOrderByRelevanceInput = {
    fields: ContactUsOrderByRelevanceFieldEnum | ContactUsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactUsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactUsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactUsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerTypeOrderByRelevanceInput = {
    fields: CustomerTypeOrderByRelevanceFieldEnum | CustomerTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    productId?: SortOrder
  }

  export type CustomerTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    productId?: SortOrder
  }

  export type CustomerTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    productId?: SortOrder
  }

  export type EnumDeleteRequest_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeleteRequest_status | EnumDeleteRequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.DeleteRequest_status[]
    notIn?: $Enums.DeleteRequest_status[]
    not?: NestedEnumDeleteRequest_statusFilter<$PrismaModel> | $Enums.DeleteRequest_status
  }

  export type DeleteRequestOrderByRelevanceInput = {
    fields: DeleteRequestOrderByRelevanceFieldEnum | DeleteRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeleteRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type DeleteRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type DeleteRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDeleteRequest_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeleteRequest_status | EnumDeleteRequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.DeleteRequest_status[]
    notIn?: $Enums.DeleteRequest_status[]
    not?: NestedEnumDeleteRequest_statusWithAggregatesFilter<$PrismaModel> | $Enums.DeleteRequest_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeleteRequest_statusFilter<$PrismaModel>
    _max?: NestedEnumDeleteRequest_statusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumDiscount_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.Discount_type | EnumDiscount_typeFieldRefInput<$PrismaModel>
    in?: $Enums.Discount_type[]
    notIn?: $Enums.Discount_type[]
    not?: NestedEnumDiscount_typeFilter<$PrismaModel> | $Enums.Discount_type
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type OrderDetailsListRelationFilter = {
    every?: OrderDetailsWhereInput
    some?: OrderDetailsWhereInput
    none?: OrderDetailsWhereInput
  }

  export type OrderDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountOrderByRelevanceInput = {
    fields: DiscountOrderByRelevanceFieldEnum | DiscountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    maxPrice?: SortOrder
    minPrice?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    orders?: SortOrder
    userEmails?: SortOrder
    isWebAvailable?: SortOrder
    isCODAvailable?: SortOrder
  }

  export type DiscountAvgOrderByAggregateInput = {
    amount?: SortOrder
    maxPrice?: SortOrder
    minPrice?: SortOrder
    orders?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    maxPrice?: SortOrder
    minPrice?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    orders?: SortOrder
    isWebAvailable?: SortOrder
    isCODAvailable?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    maxPrice?: SortOrder
    minPrice?: SortOrder
    isActive?: SortOrder
    isSpecial?: SortOrder
    orders?: SortOrder
    isWebAvailable?: SortOrder
    isCODAvailable?: SortOrder
  }

  export type DiscountSumOrderByAggregateInput = {
    amount?: SortOrder
    maxPrice?: SortOrder
    minPrice?: SortOrder
    orders?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumDiscount_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Discount_type | EnumDiscount_typeFieldRefInput<$PrismaModel>
    in?: $Enums.Discount_type[]
    notIn?: $Enums.Discount_type[]
    not?: NestedEnumDiscount_typeWithAggregatesFilter<$PrismaModel> | $Enums.Discount_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscount_typeFilter<$PrismaModel>
    _max?: NestedEnumDiscount_typeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DropMessageOrderByRelevanceInput = {
    fields: DropMessageOrderByRelevanceFieldEnum | DropMessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DropMessageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DropMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DropMessageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ExclusiveCollectionOrderByRelevanceInput = {
    fields: ExclusiveCollectionOrderByRelevanceFieldEnum | ExclusiveCollectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExclusiveCollectionCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
  }

  export type ExclusiveCollectionAvgOrderByAggregateInput = {
    mrp?: SortOrder
    price?: SortOrder
  }

  export type ExclusiveCollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
  }

  export type ExclusiveCollectionMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
  }

  export type ExclusiveCollectionSumOrderByAggregateInput = {
    mrp?: SortOrder
    price?: SortOrder
  }

  export type HeroSlidersOrderByRelevanceInput = {
    fields: HeroSlidersOrderByRelevanceFieldEnum | HeroSlidersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HeroSlidersCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroSlidersMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroSlidersMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageWeekOrderByRelevanceInput = {
    fields: ImageWeekOrderByRelevanceFieldEnum | ImageWeekOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImageWeekCountOrderByAggregateInput = {
    id?: SortOrder
    hyperLink?: SortOrder
    imageUrl?: SortOrder
  }

  export type ImageWeekMaxOrderByAggregateInput = {
    id?: SortOrder
    hyperLink?: SortOrder
    imageUrl?: SortOrder
  }

  export type ImageWeekMinOrderByAggregateInput = {
    id?: SortOrder
    hyperLink?: SortOrder
    imageUrl?: SortOrder
  }

  export type LogosOrderByRelevanceInput = {
    fields: LogosOrderByRelevanceFieldEnum | LogosOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LogosCountOrderByAggregateInput = {
    id?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    altText?: SortOrder
  }

  export type LogosMaxOrderByAggregateInput = {
    id?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    altText?: SortOrder
  }

  export type LogosMinOrderByAggregateInput = {
    id?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    altText?: SortOrder
  }

  export type MessageOrderByRelevanceInput = {
    fields: MessageOrderByRelevanceFieldEnum | MessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    handledById?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    handledById?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    handledById?: SortOrder
  }

  export type NewArrivalsOrderByRelevanceInput = {
    fields: NewArrivalsOrderByRelevanceFieldEnum | NewArrivalsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NewArrivalsCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
    title?: SortOrder
  }

  export type NewArrivalsAvgOrderByAggregateInput = {
    mrp?: SortOrder
    price?: SortOrder
  }

  export type NewArrivalsMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
    title?: SortOrder
  }

  export type NewArrivalsMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
    title?: SortOrder
  }

  export type NewArrivalsSumOrderByAggregateInput = {
    mrp?: SortOrder
    price?: SortOrder
  }

  export type NewsletterOrderByRelevanceInput = {
    fields: NewsletterOrderByRelevanceFieldEnum | NewsletterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NewsletterCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsletterMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    hyperLink?: SortOrder
    title?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    hyperLink?: SortOrder
    title?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    hyperLink?: SortOrder
    title?: SortOrder
  }

  export type EnumOrderDetails_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDetails_status | EnumOrderDetails_statusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderDetails_status[]
    notIn?: $Enums.OrderDetails_status[]
    not?: NestedEnumOrderDetails_statusFilter<$PrismaModel> | $Enums.OrderDetails_status
  }

  export type EnumOrderDetails_paymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDetails_paymentMethod | EnumOrderDetails_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderDetails_paymentMethod[] | null
    notIn?: $Enums.OrderDetails_paymentMethod[] | null
    not?: NestedEnumOrderDetails_paymentMethodNullableFilter<$PrismaModel> | $Enums.OrderDetails_paymentMethod | null
  }

  export type UserAddressNullableScalarRelationFilter = {
    is?: UserAddressWhereInput | null
    isNot?: UserAddressWhereInput | null
  }

  export type DiscountNullableScalarRelationFilter = {
    is?: DiscountWhereInput | null
    isNot?: DiscountWhereInput | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type PaymentDetailsListRelationFilter = {
    every?: PaymentDetailsWhereInput
    some?: PaymentDetailsWhereInput
    none?: PaymentDetailsWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderDetailsOrderByRelevanceInput = {
    fields: OrderDetailsOrderByRelevanceFieldEnum | OrderDetailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discountId?: SortOrder
    orderId?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    trackingId?: SortOrder
    addressId?: SortOrder
    finalPrice?: SortOrder
  }

  export type OrderDetailsAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type OrderDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discountId?: SortOrder
    orderId?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    trackingId?: SortOrder
    addressId?: SortOrder
    finalPrice?: SortOrder
  }

  export type OrderDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discountId?: SortOrder
    orderId?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    trackingId?: SortOrder
    addressId?: SortOrder
    finalPrice?: SortOrder
  }

  export type OrderDetailsSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    finalPrice?: SortOrder
  }

  export type EnumOrderDetails_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDetails_status | EnumOrderDetails_statusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderDetails_status[]
    notIn?: $Enums.OrderDetails_status[]
    not?: NestedEnumOrderDetails_statusWithAggregatesFilter<$PrismaModel> | $Enums.OrderDetails_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderDetails_statusFilter<$PrismaModel>
    _max?: NestedEnumOrderDetails_statusFilter<$PrismaModel>
  }

  export type EnumOrderDetails_paymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDetails_paymentMethod | EnumOrderDetails_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderDetails_paymentMethod[] | null
    notIn?: $Enums.OrderDetails_paymentMethod[] | null
    not?: NestedEnumOrderDetails_paymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderDetails_paymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderDetails_paymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderDetails_paymentMethodNullableFilter<$PrismaModel>
  }

  export type OrderDetailsScalarRelationFilter = {
    is?: OrderDetailsWhereInput
    isNot?: OrderDetailsWhereInput
  }

  export type ProductSizeNullableScalarRelationFilter = {
    is?: ProductSizeWhereInput | null
    isNot?: ProductSizeWhereInput | null
  }

  export type ReturnRequestListRelationFilter = {
    every?: ReturnRequestWhereInput
    some?: ReturnRequestWhereInput
    none?: ReturnRequestWhereInput
  }

  export type ReturnRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelevanceInput = {
    fields: OrderItemOrderByRelevanceFieldEnum | OrderItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sizeId?: SortOrder
    colorId?: SortOrder
    imageId?: SortOrder
    isReviewed?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sizeId?: SortOrder
    colorId?: SortOrder
    imageId?: SortOrder
    isReviewed?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sizeId?: SortOrder
    colorId?: SortOrder
    imageId?: SortOrder
    isReviewed?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OtpOrderByRelevanceInput = {
    fields: OtpOrderByRelevanceFieldEnum | OtpOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentDetailsOrderByRelevanceInput = {
    fields: PaymentDetailsOrderByRelevanceFieldEnum | PaymentDetailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bank?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    order_id?: SortOrder
    payment_id?: SortOrder
    upi?: SortOrder
    wallet?: SortOrder
  }

  export type PaymentDetailsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bank?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    order_id?: SortOrder
    payment_id?: SortOrder
    upi?: SortOrder
    wallet?: SortOrder
  }

  export type PaymentDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bank?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    order_id?: SortOrder
    payment_id?: SortOrder
    upi?: SortOrder
    wallet?: SortOrder
  }

  export type PaymentDetailsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UserPrivilegeListRelationFilter = {
    every?: UserPrivilegeWhereInput
    some?: UserPrivilegeWhereInput
    none?: UserPrivilegeWhereInput
  }

  export type UserPrivilegeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrivilegeOrderByRelevanceInput = {
    fields: PrivilegeOrderByRelevanceFieldEnum | PrivilegeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PrivilegeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
  }

  export type PrivilegeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
  }

  export type PrivilegeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    label?: SortOrder
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type DiscountListRelationFilter = {
    every?: DiscountWhereInput
    some?: DiscountWhereInput
    none?: DiscountWhereInput
  }

  export type CustomerTypeNullableScalarRelationFilter = {
    is?: CustomerTypeWhereInput | null
    isNot?: CustomerTypeWhereInput | null
  }

  export type ProductFabricNullableScalarRelationFilter = {
    is?: ProductFabricWhereInput | null
    isNot?: ProductFabricWhereInput | null
  }

  export type SizeChartNullableScalarRelationFilter = {
    is?: SizeChartWhereInput | null
    isNot?: SizeChartWhereInput | null
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type ProductInventoryListRelationFilter = {
    every?: ProductInventoryWhereInput
    some?: ProductInventoryWhereInput
    none?: ProductInventoryWhereInput
  }

  export type ProductReviewListRelationFilter = {
    every?: ProductReviewWhereInput
    some?: ProductReviewWhereInput
    none?: ProductReviewWhereInput
  }

  export type WishlistItemListRelationFilter = {
    every?: WishlistItemWhereInput
    some?: WishlistItemWhereInput
    none?: WishlistItemWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type SubCategoryListRelationFilter = {
    every?: SubCategoryWhereInput
    some?: SubCategoryWhereInput
    none?: SubCategoryWhereInput
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductInventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelevanceInput = {
    fields: ProductOrderByRelevanceFieldEnum | ProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    isReturnable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailUrl?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    summary?: SortOrder
    customerTypeId?: SortOrder
    userId?: SortOrder
    estimatedDeliveryDay?: SortOrder
    styleId?: SortOrder
    title?: SortOrder
    returnPolicy?: SortOrder
    views?: SortOrder
    displayPrice?: SortOrder
    tags?: SortOrder
    longTailKeyword?: SortOrder
    affiliateId?: SortOrder
    isCODAvailable?: SortOrder
    ogImage?: SortOrder
    sellerCode?: SortOrder
    sizeChartId?: SortOrder
    fabricId?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    estimatedDeliveryDay?: SortOrder
    views?: SortOrder
    displayPrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    isReturnable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailUrl?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    summary?: SortOrder
    customerTypeId?: SortOrder
    userId?: SortOrder
    estimatedDeliveryDay?: SortOrder
    styleId?: SortOrder
    title?: SortOrder
    returnPolicy?: SortOrder
    views?: SortOrder
    displayPrice?: SortOrder
    longTailKeyword?: SortOrder
    affiliateId?: SortOrder
    isCODAvailable?: SortOrder
    ogImage?: SortOrder
    sellerCode?: SortOrder
    sizeChartId?: SortOrder
    fabricId?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    isReturnable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnailUrl?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    summary?: SortOrder
    customerTypeId?: SortOrder
    userId?: SortOrder
    estimatedDeliveryDay?: SortOrder
    styleId?: SortOrder
    title?: SortOrder
    returnPolicy?: SortOrder
    views?: SortOrder
    displayPrice?: SortOrder
    longTailKeyword?: SortOrder
    affiliateId?: SortOrder
    isCODAvailable?: SortOrder
    ogImage?: SortOrder
    sellerCode?: SortOrder
    sizeChartId?: SortOrder
    fabricId?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    estimatedDeliveryDay?: SortOrder
    views?: SortOrder
    displayPrice?: SortOrder
  }

  export type AnchorTextNullableScalarRelationFilter = {
    is?: AnchorTextWhereInput | null
    isNot?: AnchorTextWhereInput | null
  }

  export type QuotesListRelationFilter = {
    every?: QuotesWhereInput
    some?: QuotesWhereInput
    none?: QuotesWhereInput
  }

  export type QuotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelevanceInput = {
    fields: ProductCategoryOrderByRelevanceFieldEnum | ProductCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCategoryNameSlugCompoundUniqueInput = {
    name: string
    slug: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isVisible?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isVisible?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    isVisible?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
  }

  export type ProductColorOrderByRelevanceInput = {
    fields: ProductColorOrderByRelevanceFieldEnum | ProductColorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductColorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    slug?: SortOrder
  }

  export type ProductColorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    slug?: SortOrder
  }

  export type ProductColorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    slug?: SortOrder
  }

  export type ProductFabricOrderByRelevanceInput = {
    fields: ProductFabricOrderByRelevanceFieldEnum | ProductFabricOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductFabricCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type ProductFabricMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type ProductFabricMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type ProductImageOrderByRelevanceInput = {
    fields: ProductImageOrderByRelevanceFieldEnum | ProductImageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    colorId?: SortOrder
    altText?: SortOrder
    caption?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    colorId?: SortOrder
    altText?: SortOrder
    caption?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    imageUrl?: SortOrder
    colorId?: SortOrder
    altText?: SortOrder
    caption?: SortOrder
  }

  export type ProductInventoryOrderByRelevanceInput = {
    fields: ProductInventoryOrderByRelevanceFieldEnum | ProductInventoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductInventoryProductIdSizeIdCompoundUniqueInput = {
    productId: string
    sizeId: string
  }

  export type ProductInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
    sizeId?: SortOrder
    stock?: SortOrder
    minQuantity?: SortOrder
    discount?: SortOrder
  }

  export type ProductInventoryAvgOrderByAggregateInput = {
    mrp?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    minQuantity?: SortOrder
    discount?: SortOrder
  }

  export type ProductInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
    sizeId?: SortOrder
    stock?: SortOrder
    minQuantity?: SortOrder
    discount?: SortOrder
  }

  export type ProductInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    mrp?: SortOrder
    price?: SortOrder
    sizeId?: SortOrder
    stock?: SortOrder
    minQuantity?: SortOrder
    discount?: SortOrder
  }

  export type ProductInventorySumOrderByAggregateInput = {
    mrp?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    minQuantity?: SortOrder
    discount?: SortOrder
  }

  export type ProductReviewOrderByRelevanceInput = {
    fields: ProductReviewOrderByRelevanceFieldEnum | ProductReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: SortOrder
  }

  export type ProductReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ProductReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ProductSizeOrderByRelevanceInput = {
    fields: ProductSizeOrderByRelevanceFieldEnum | ProductSizeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductSizeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type ProductSizeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type ProductSizeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
  }

  export type ProductWeekOrderByRelevanceInput = {
    fields: ProductWeekOrderByRelevanceFieldEnum | ProductWeekOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductWeekCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    hyperLink?: SortOrder
    imageUrl?: SortOrder
  }

  export type ProductWeekMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    hyperLink?: SortOrder
    imageUrl?: SortOrder
  }

  export type ProductWeekMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    hyperLink?: SortOrder
    imageUrl?: SortOrder
  }

  export type QuotesOrderByRelevanceInput = {
    fields: QuotesOrderByRelevanceFieldEnum | QuotesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type QuotesCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryId?: SortOrder
  }

  export type QuotesMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryId?: SortOrder
  }

  export type QuotesMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryId?: SortOrder
  }

  export type EnumReturnRequest_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnRequest_status | EnumReturnRequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnRequest_status[]
    notIn?: $Enums.ReturnRequest_status[]
    not?: NestedEnumReturnRequest_statusFilter<$PrismaModel> | $Enums.ReturnRequest_status
  }

  export type OrderItemScalarRelationFilter = {
    is?: OrderItemWhereInput
    isNot?: OrderItemWhereInput
  }

  export type ReturnRequestOrderByRelevanceInput = {
    fields: ReturnRequestOrderByRelevanceFieldEnum | ReturnRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReturnRequestCountOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type ReturnRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type ReturnRequestMinOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EnumReturnRequest_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnRequest_status | EnumReturnRequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnRequest_status[]
    notIn?: $Enums.ReturnRequest_status[]
    not?: NestedEnumReturnRequest_statusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnRequest_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnRequest_statusFilter<$PrismaModel>
    _max?: NestedEnumReturnRequest_statusFilter<$PrismaModel>
  }

  export type RewardsOrderByRelevanceInput = {
    fields: RewardsOrderByRelevanceFieldEnum | RewardsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RewardsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type RewardsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type RewardsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    code?: SortOrder
    description?: SortOrder
  }

  export type SearchQueryOrderByRelevanceInput = {
    fields: SearchQueryOrderByRelevanceFieldEnum | SearchQueryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SearchQueryCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type SearchQueryMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type SearchQueryMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ShopByOccasionProductListRelationFilter = {
    every?: ShopByOccasionProductWhereInput
    some?: ShopByOccasionProductWhereInput
    none?: ShopByOccasionProductWhereInput
  }

  export type ShopByOccasionProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopByOccasionOrderByRelevanceInput = {
    fields: ShopByOccasionOrderByRelevanceFieldEnum | ShopByOccasionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShopByOccasionCountOrderByAggregateInput = {
    id?: SortOrder
    occasionName?: SortOrder
    categoryHyperLinks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopByOccasionMaxOrderByAggregateInput = {
    id?: SortOrder
    occasionName?: SortOrder
    categoryHyperLinks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopByOccasionMinOrderByAggregateInput = {
    id?: SortOrder
    occasionName?: SortOrder
    categoryHyperLinks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopByOccasionNullableScalarRelationFilter = {
    is?: ShopByOccasionWhereInput | null
    isNot?: ShopByOccasionWhereInput | null
  }

  export type ShopByOccasionProductOrderByRelevanceInput = {
    fields: ShopByOccasionProductOrderByRelevanceFieldEnum | ShopByOccasionProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShopByOccasionProductCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    shopByOccasionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopByOccasionProductMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    shopByOccasionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopByOccasionProductMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    shopByOccasionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopBySeasonProductListRelationFilter = {
    every?: ShopBySeasonProductWhereInput
    some?: ShopBySeasonProductWhereInput
    none?: ShopBySeasonProductWhereInput
  }

  export type ShopBySeasonProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopBySeasonOrderByRelevanceInput = {
    fields: ShopBySeasonOrderByRelevanceFieldEnum | ShopBySeasonOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShopBySeasonCountOrderByAggregateInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopBySeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopBySeasonMinOrderByAggregateInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopBySeasonScalarRelationFilter = {
    is?: ShopBySeasonWhereInput
    isNot?: ShopBySeasonWhereInput
  }

  export type ShopBySeasonProductOrderByRelevanceInput = {
    fields: ShopBySeasonProductOrderByRelevanceFieldEnum | ShopBySeasonProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShopBySeasonProductCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    hyperLink?: SortOrder
  }

  export type ShopBySeasonProductMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    hyperLink?: SortOrder
  }

  export type ShopBySeasonProductMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seasonId?: SortOrder
    hyperLink?: SortOrder
  }

  export type ShowcasesOrderByRelevanceInput = {
    fields: ShowcasesOrderByRelevanceFieldEnum | ShowcasesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShowcasesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShowcasesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShowcasesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
    categoryHyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SizeChartOrderByRelevanceInput = {
    fields: SizeChartOrderByRelevanceFieldEnum | SizeChartOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SizeChartCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type SizeChartMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type SizeChartMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type SocialLinksOrderByRelevanceInput = {
    fields: SocialLinksOrderByRelevanceFieldEnum | SocialLinksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SocialLinksCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
  }

  export type SocialLinksMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
  }

  export type SocialLinksMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    hyperLink?: SortOrder
  }

  export type EnumStaticMessages_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.StaticMessages_status | EnumStaticMessages_statusFieldRefInput<$PrismaModel>
    in?: $Enums.StaticMessages_status[]
    notIn?: $Enums.StaticMessages_status[]
    not?: NestedEnumStaticMessages_statusFilter<$PrismaModel> | $Enums.StaticMessages_status
  }

  export type StaticMessagesOrderByRelevanceInput = {
    fields: StaticMessagesOrderByRelevanceFieldEnum | StaticMessagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StaticMessagesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type StaticMessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type StaticMessagesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumStaticMessages_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaticMessages_status | EnumStaticMessages_statusFieldRefInput<$PrismaModel>
    in?: $Enums.StaticMessages_status[]
    notIn?: $Enums.StaticMessages_status[]
    not?: NestedEnumStaticMessages_statusWithAggregatesFilter<$PrismaModel> | $Enums.StaticMessages_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaticMessages_statusFilter<$PrismaModel>
    _max?: NestedEnumStaticMessages_statusFilter<$PrismaModel>
  }

  export type SubCategoryOrderByRelevanceInput = {
    fields: SubCategoryOrderByRelevanceFieldEnum | SubCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
  }

  export type SubCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
  }

  export type SubCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
    imageUrl?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
  }

  export type EnumSupportTicket_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicket_status | EnumSupportTicket_statusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicket_status[]
    notIn?: $Enums.SupportTicket_status[]
    not?: NestedEnumSupportTicket_statusFilter<$PrismaModel> | $Enums.SupportTicket_status
  }

  export type SupportTicketOrderByRelevanceInput = {
    fields: SupportTicketOrderByRelevanceFieldEnum | SupportTicketOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EnumSupportTicket_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicket_status | EnumSupportTicket_statusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicket_status[]
    notIn?: $Enums.SupportTicket_status[]
    not?: NestedEnumSupportTicket_statusWithAggregatesFilter<$PrismaModel> | $Enums.SupportTicket_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportTicket_statusFilter<$PrismaModel>
    _max?: NestedEnumSupportTicket_statusFilter<$PrismaModel>
  }

  export type TagsOrderByRelevanceInput = {
    fields: TagsOrderByRelevanceFieldEnum | TagsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TagsCountOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
  }

  export type TagsMaxOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
  }

  export type TagsMinOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
  }

  export type TrendingOrderByRelevanceInput = {
    fields: TrendingOrderByRelevanceFieldEnum | TrendingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TrendingCountOrderByAggregateInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    title?: SortOrder
    price?: SortOrder
    hyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
  }

  export type TrendingMaxOrderByAggregateInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    title?: SortOrder
    price?: SortOrder
    hyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
  }

  export type TrendingMinOrderByAggregateInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    title?: SortOrder
    price?: SortOrder
    hyperLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UpdateHistoryOrderByRelevanceInput = {
    fields: UpdateHistoryOrderByRelevanceFieldEnum | UpdateHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UpdateHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type UpdateHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type UpdateHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumUser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.User_role | EnumUser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.User_role[]
    notIn?: $Enums.User_role[]
    not?: NestedEnumUser_roleFilter<$PrismaModel> | $Enums.User_role
  }

  export type EnumUser_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.User_status | EnumUser_statusFieldRefInput<$PrismaModel>
    in?: $Enums.User_status[]
    notIn?: $Enums.User_status[]
    not?: NestedEnumUser_statusFilter<$PrismaModel> | $Enums.User_status
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DeleteRequestListRelationFilter = {
    every?: DeleteRequestWhereInput
    some?: DeleteRequestWhereInput
    none?: DeleteRequestWhereInput
  }

  export type DropMessageListRelationFilter = {
    every?: DropMessageWhereInput
    some?: DropMessageWhereInput
    none?: DropMessageWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type OtpListRelationFilter = {
    every?: OtpWhereInput
    some?: OtpWhereInput
    none?: OtpWhereInput
  }

  export type RewardsListRelationFilter = {
    every?: RewardsWhereInput
    some?: RewardsWhereInput
    none?: RewardsWhereInput
  }

  export type SearchQueryListRelationFilter = {
    every?: SearchQueryWhereInput
    some?: SearchQueryWhereInput
    none?: SearchQueryWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type StaticMessagesListRelationFilter = {
    every?: StaticMessagesWhereInput
    some?: StaticMessagesWhereInput
    none?: StaticMessagesWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type UpdateHistoryListRelationFilter = {
    every?: UpdateHistoryWhereInput
    some?: UpdateHistoryWhereInput
    none?: UpdateHistoryWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserAddressListRelationFilter = {
    every?: UserAddressWhereInput
    some?: UserAddressWhereInput
    none?: UserAddressWhereInput
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeleteRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DropMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OtpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchQueryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaticMessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UpdateHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    status?: SortOrder
    profileUrl?: SortOrder
    mobileNumber?: SortOrder
    whatsAppNumber?: SortOrder
    isLoggedIn?: SortOrder
    isViewed?: SortOrder
    is2FA?: SortOrder
    assignedStaffId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    status?: SortOrder
    profileUrl?: SortOrder
    mobileNumber?: SortOrder
    whatsAppNumber?: SortOrder
    isLoggedIn?: SortOrder
    isViewed?: SortOrder
    is2FA?: SortOrder
    assignedStaffId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isVerified?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    status?: SortOrder
    profileUrl?: SortOrder
    mobileNumber?: SortOrder
    whatsAppNumber?: SortOrder
    isLoggedIn?: SortOrder
    isViewed?: SortOrder
    is2FA?: SortOrder
    assignedStaffId?: SortOrder
  }

  export type EnumUser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.User_role | EnumUser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.User_role[]
    notIn?: $Enums.User_role[]
    not?: NestedEnumUser_roleWithAggregatesFilter<$PrismaModel> | $Enums.User_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUser_roleFilter<$PrismaModel>
    _max?: NestedEnumUser_roleFilter<$PrismaModel>
  }

  export type EnumUser_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.User_status | EnumUser_statusFieldRefInput<$PrismaModel>
    in?: $Enums.User_status[]
    notIn?: $Enums.User_status[]
    not?: NestedEnumUser_statusWithAggregatesFilter<$PrismaModel> | $Enums.User_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUser_statusFilter<$PrismaModel>
    _max?: NestedEnumUser_statusFilter<$PrismaModel>
  }

  export type UserAddressOrderByRelevanceInput = {
    fields: UserAddressOrderByRelevanceFieldEnum | UserAddressOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserAddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    mobileNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDefault?: SortOrder
    fullName?: SortOrder
    altMobileNumber?: SortOrder
  }

  export type UserAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    mobileNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDefault?: SortOrder
    fullName?: SortOrder
    altMobileNumber?: SortOrder
  }

  export type UserAddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    mobileNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDefault?: SortOrder
    fullName?: SortOrder
    altMobileNumber?: SortOrder
  }

  export type PrivilegeScalarRelationFilter = {
    is?: PrivilegeWhereInput
    isNot?: PrivilegeWhereInput
  }

  export type UserPrivilegeOrderByRelevanceInput = {
    fields: UserPrivilegeOrderByRelevanceFieldEnum | UserPrivilegeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserPrivilegeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    privilegeId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPrivilegeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    privilegeId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPrivilegeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    privilegeId?: SortOrder
    createdAt?: SortOrder
  }

  export type VidesOrderByRelevanceInput = {
    fields: VidesOrderByRelevanceFieldEnum | VidesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VidesCountOrderByAggregateInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type VidesAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type VidesMaxOrderByAggregateInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type VidesMinOrderByAggregateInput = {
    id?: SortOrder
    videoUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    hyperLink?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type VidesSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type VisitorOrderByRelevanceInput = {
    fields: VisitorOrderByRelevanceFieldEnum | VisitorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VisitorCountOrderByAggregateInput = {
    id?: SortOrder
    ipAddress?: SortOrder
    cookieId?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitorMaxOrderByAggregateInput = {
    id?: SortOrder
    ipAddress?: SortOrder
    cookieId?: SortOrder
    createdAt?: SortOrder
  }

  export type VisitorMinOrderByAggregateInput = {
    id?: SortOrder
    ipAddress?: SortOrder
    cookieId?: SortOrder
    createdAt?: SortOrder
  }

  export type WishlistItemOrderByRelevanceInput = {
    fields: WishlistItemOrderByRelevanceFieldEnum | WishlistItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WishlistItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type WishlistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type WishlistItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductCategoryCreateNestedOneWithoutAnchorTextInput = {
    create?: XOR<ProductCategoryCreateWithoutAnchorTextInput, ProductCategoryUncheckedCreateWithoutAnchorTextInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutAnchorTextInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProductCategoryUpdateOneRequiredWithoutAnchorTextNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutAnchorTextInput, ProductCategoryUncheckedCreateWithoutAnchorTextInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutAnchorTextInput
    upsert?: ProductCategoryUpsertWithoutAnchorTextInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutAnchorTextInput, ProductCategoryUpdateWithoutAnchorTextInput>, ProductCategoryUncheckedUpdateWithoutAnchorTextInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    upsert?: UserUpsertWithoutAuditLogInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogInput, UserUpdateWithoutAuditLogInput>, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProductColorCreateNestedOneWithoutCartItemInput = {
    create?: XOR<ProductColorCreateWithoutCartItemInput, ProductColorUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutCartItemInput
    connect?: ProductColorWhereUniqueInput
  }

  export type ProductImageCreateNestedOneWithoutCartItemInput = {
    create?: XOR<ProductImageCreateWithoutCartItemInput, ProductImageUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductImageCreateOrConnectWithoutCartItemInput
    connect?: ProductImageWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemInput = {
    create?: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCartItemInput = {
    create?: XOR<UserCreateWithoutCartItemInput, UserUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartItemInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductColorUpdateOneWithoutCartItemNestedInput = {
    create?: XOR<ProductColorCreateWithoutCartItemInput, ProductColorUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutCartItemInput
    upsert?: ProductColorUpsertWithoutCartItemInput
    disconnect?: ProductColorWhereInput | boolean
    delete?: ProductColorWhereInput | boolean
    connect?: ProductColorWhereUniqueInput
    update?: XOR<XOR<ProductColorUpdateToOneWithWhereWithoutCartItemInput, ProductColorUpdateWithoutCartItemInput>, ProductColorUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductImageUpdateOneWithoutCartItemNestedInput = {
    create?: XOR<ProductImageCreateWithoutCartItemInput, ProductImageUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductImageCreateOrConnectWithoutCartItemInput
    upsert?: ProductImageUpsertWithoutCartItemInput
    disconnect?: ProductImageWhereInput | boolean
    delete?: ProductImageWhereInput | boolean
    connect?: ProductImageWhereUniqueInput
    update?: XOR<XOR<ProductImageUpdateToOneWithWhereWithoutCartItemInput, ProductImageUpdateWithoutCartItemInput>, ProductImageUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductUpdateOneRequiredWithoutCartItemNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemInput
    upsert?: ProductUpsertWithoutCartItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemInput, ProductUpdateWithoutCartItemInput>, ProductUncheckedUpdateWithoutCartItemInput>
  }

  export type UserUpdateOneRequiredWithoutCartItemNestedInput = {
    create?: XOR<UserCreateWithoutCartItemInput, UserUncheckedCreateWithoutCartItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartItemInput
    upsert?: UserUpsertWithoutCartItemInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartItemInput, UserUpdateWithoutCartItemInput>, UserUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductCreateNestedManyWithoutCustomerTypeInput = {
    create?: XOR<ProductCreateWithoutCustomerTypeInput, ProductUncheckedCreateWithoutCustomerTypeInput> | ProductCreateWithoutCustomerTypeInput[] | ProductUncheckedCreateWithoutCustomerTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerTypeInput | ProductCreateOrConnectWithoutCustomerTypeInput[]
    createMany?: ProductCreateManyCustomerTypeInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCustomerTypeInput = {
    create?: XOR<ProductCreateWithoutCustomerTypeInput, ProductUncheckedCreateWithoutCustomerTypeInput> | ProductCreateWithoutCustomerTypeInput[] | ProductUncheckedCreateWithoutCustomerTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerTypeInput | ProductCreateOrConnectWithoutCustomerTypeInput[]
    createMany?: ProductCreateManyCustomerTypeInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCustomerTypeNestedInput = {
    create?: XOR<ProductCreateWithoutCustomerTypeInput, ProductUncheckedCreateWithoutCustomerTypeInput> | ProductCreateWithoutCustomerTypeInput[] | ProductUncheckedCreateWithoutCustomerTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerTypeInput | ProductCreateOrConnectWithoutCustomerTypeInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCustomerTypeInput | ProductUpsertWithWhereUniqueWithoutCustomerTypeInput[]
    createMany?: ProductCreateManyCustomerTypeInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCustomerTypeInput | ProductUpdateWithWhereUniqueWithoutCustomerTypeInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCustomerTypeInput | ProductUpdateManyWithWhereWithoutCustomerTypeInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCustomerTypeNestedInput = {
    create?: XOR<ProductCreateWithoutCustomerTypeInput, ProductUncheckedCreateWithoutCustomerTypeInput> | ProductCreateWithoutCustomerTypeInput[] | ProductUncheckedCreateWithoutCustomerTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerTypeInput | ProductCreateOrConnectWithoutCustomerTypeInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCustomerTypeInput | ProductUpsertWithWhereUniqueWithoutCustomerTypeInput[]
    createMany?: ProductCreateManyCustomerTypeInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCustomerTypeInput | ProductUpdateWithWhereUniqueWithoutCustomerTypeInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCustomerTypeInput | ProductUpdateManyWithWhereWithoutCustomerTypeInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDeleteRequestInput = {
    create?: XOR<UserCreateWithoutDeleteRequestInput, UserUncheckedCreateWithoutDeleteRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeleteRequestInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDeleteRequest_statusFieldUpdateOperationsInput = {
    set?: $Enums.DeleteRequest_status
  }

  export type UserUpdateOneWithoutDeleteRequestNestedInput = {
    create?: XOR<UserCreateWithoutDeleteRequestInput, UserUncheckedCreateWithoutDeleteRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeleteRequestInput
    upsert?: UserUpsertWithoutDeleteRequestInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeleteRequestInput, UserUpdateWithoutDeleteRequestInput>, UserUncheckedUpdateWithoutDeleteRequestInput>
  }

  export type ProductCreateNestedOneWithoutDiscountInput = {
    create?: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDiscountInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderDetailsCreateNestedManyWithoutDiscountInput = {
    create?: XOR<OrderDetailsCreateWithoutDiscountInput, OrderDetailsUncheckedCreateWithoutDiscountInput> | OrderDetailsCreateWithoutDiscountInput[] | OrderDetailsUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutDiscountInput | OrderDetailsCreateOrConnectWithoutDiscountInput[]
    createMany?: OrderDetailsCreateManyDiscountInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type OrderDetailsUncheckedCreateNestedManyWithoutDiscountInput = {
    create?: XOR<OrderDetailsCreateWithoutDiscountInput, OrderDetailsUncheckedCreateWithoutDiscountInput> | OrderDetailsCreateWithoutDiscountInput[] | OrderDetailsUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutDiscountInput | OrderDetailsCreateOrConnectWithoutDiscountInput[]
    createMany?: OrderDetailsCreateManyDiscountInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDiscount_typeFieldUpdateOperationsInput = {
    set?: $Enums.Discount_type
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneWithoutDiscountNestedInput = {
    create?: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDiscountInput
    upsert?: ProductUpsertWithoutDiscountInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutDiscountInput, ProductUpdateWithoutDiscountInput>, ProductUncheckedUpdateWithoutDiscountInput>
  }

  export type OrderDetailsUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutDiscountInput, OrderDetailsUncheckedCreateWithoutDiscountInput> | OrderDetailsCreateWithoutDiscountInput[] | OrderDetailsUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutDiscountInput | OrderDetailsCreateOrConnectWithoutDiscountInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutDiscountInput | OrderDetailsUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: OrderDetailsCreateManyDiscountInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutDiscountInput | OrderDetailsUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutDiscountInput | OrderDetailsUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type OrderDetailsUncheckedUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutDiscountInput, OrderDetailsUncheckedCreateWithoutDiscountInput> | OrderDetailsCreateWithoutDiscountInput[] | OrderDetailsUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutDiscountInput | OrderDetailsCreateOrConnectWithoutDiscountInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutDiscountInput | OrderDetailsUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: OrderDetailsCreateManyDiscountInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutDiscountInput | OrderDetailsUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutDiscountInput | OrderDetailsUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDropMessageInput = {
    create?: XOR<UserCreateWithoutDropMessageInput, UserUncheckedCreateWithoutDropMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutDropMessageInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutDropMessageNestedInput = {
    create?: XOR<UserCreateWithoutDropMessageInput, UserUncheckedCreateWithoutDropMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutDropMessageInput
    upsert?: UserUpsertWithoutDropMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDropMessageInput, UserUpdateWithoutDropMessageInput>, UserUncheckedUpdateWithoutDropMessageInput>
  }

  export type UserCreateNestedOneWithoutMessage_Message_handledByIdToUserInput = {
    create?: XOR<UserCreateWithoutMessage_Message_handledByIdToUserInput, UserUncheckedCreateWithoutMessage_Message_handledByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_handledByIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessage_Message_receiverIdToUserInput = {
    create?: XOR<UserCreateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_receiverIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessage_Message_senderIdToUserInput = {
    create?: XOR<UserCreateWithoutMessage_Message_senderIdToUserInput, UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_senderIdToUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutMessage_Message_handledByIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutMessage_Message_handledByIdToUserInput, UserUncheckedCreateWithoutMessage_Message_handledByIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_handledByIdToUserInput
    upsert?: UserUpsertWithoutMessage_Message_handledByIdToUserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessage_Message_handledByIdToUserInput, UserUpdateWithoutMessage_Message_handledByIdToUserInput>, UserUncheckedUpdateWithoutMessage_Message_handledByIdToUserInput>
  }

  export type UserUpdateOneRequiredWithoutMessage_Message_receiverIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_receiverIdToUserInput
    upsert?: UserUpsertWithoutMessage_Message_receiverIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessage_Message_receiverIdToUserInput, UserUpdateWithoutMessage_Message_receiverIdToUserInput>, UserUncheckedUpdateWithoutMessage_Message_receiverIdToUserInput>
  }

  export type UserUpdateOneRequiredWithoutMessage_Message_senderIdToUserNestedInput = {
    create?: XOR<UserCreateWithoutMessage_Message_senderIdToUserInput, UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessage_Message_senderIdToUserInput
    upsert?: UserUpsertWithoutMessage_Message_senderIdToUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessage_Message_senderIdToUserInput, UserUpdateWithoutMessage_Message_senderIdToUserInput>, UserUncheckedUpdateWithoutMessage_Message_senderIdToUserInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserAddressCreateNestedOneWithoutOrderDetailsInput = {
    create?: XOR<UserAddressCreateWithoutOrderDetailsInput, UserAddressUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutOrderDetailsInput
    connect?: UserAddressWhereUniqueInput
  }

  export type DiscountCreateNestedOneWithoutOrderDetailsInput = {
    create?: XOR<DiscountCreateWithoutOrderDetailsInput, DiscountUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderDetailsInput
    connect?: DiscountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrderDetailsInput = {
    create?: XOR<UserCreateWithoutOrderDetailsInput, UserUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderDetailsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderDetailsInput = {
    create?: XOR<OrderItemCreateWithoutOrderDetailsInput, OrderItemUncheckedCreateWithoutOrderDetailsInput> | OrderItemCreateWithoutOrderDetailsInput[] | OrderItemUncheckedCreateWithoutOrderDetailsInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderDetailsInput | OrderItemCreateOrConnectWithoutOrderDetailsInput[]
    createMany?: OrderItemCreateManyOrderDetailsInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentDetailsCreateNestedManyWithoutOrderDetailsInput = {
    create?: XOR<PaymentDetailsCreateWithoutOrderDetailsInput, PaymentDetailsUncheckedCreateWithoutOrderDetailsInput> | PaymentDetailsCreateWithoutOrderDetailsInput[] | PaymentDetailsUncheckedCreateWithoutOrderDetailsInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutOrderDetailsInput | PaymentDetailsCreateOrConnectWithoutOrderDetailsInput[]
    createMany?: PaymentDetailsCreateManyOrderDetailsInputEnvelope
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderDetailsInput = {
    create?: XOR<OrderItemCreateWithoutOrderDetailsInput, OrderItemUncheckedCreateWithoutOrderDetailsInput> | OrderItemCreateWithoutOrderDetailsInput[] | OrderItemUncheckedCreateWithoutOrderDetailsInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderDetailsInput | OrderItemCreateOrConnectWithoutOrderDetailsInput[]
    createMany?: OrderItemCreateManyOrderDetailsInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentDetailsUncheckedCreateNestedManyWithoutOrderDetailsInput = {
    create?: XOR<PaymentDetailsCreateWithoutOrderDetailsInput, PaymentDetailsUncheckedCreateWithoutOrderDetailsInput> | PaymentDetailsCreateWithoutOrderDetailsInput[] | PaymentDetailsUncheckedCreateWithoutOrderDetailsInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutOrderDetailsInput | PaymentDetailsCreateOrConnectWithoutOrderDetailsInput[]
    createMany?: PaymentDetailsCreateManyOrderDetailsInputEnvelope
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
  }

  export type EnumOrderDetails_statusFieldUpdateOperationsInput = {
    set?: $Enums.OrderDetails_status
  }

  export type NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.OrderDetails_paymentMethod | null
  }

  export type UserAddressUpdateOneWithoutOrderDetailsNestedInput = {
    create?: XOR<UserAddressCreateWithoutOrderDetailsInput, UserAddressUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutOrderDetailsInput
    upsert?: UserAddressUpsertWithoutOrderDetailsInput
    disconnect?: UserAddressWhereInput | boolean
    delete?: UserAddressWhereInput | boolean
    connect?: UserAddressWhereUniqueInput
    update?: XOR<XOR<UserAddressUpdateToOneWithWhereWithoutOrderDetailsInput, UserAddressUpdateWithoutOrderDetailsInput>, UserAddressUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type DiscountUpdateOneWithoutOrderDetailsNestedInput = {
    create?: XOR<DiscountCreateWithoutOrderDetailsInput, DiscountUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderDetailsInput
    upsert?: DiscountUpsertWithoutOrderDetailsInput
    disconnect?: DiscountWhereInput | boolean
    delete?: DiscountWhereInput | boolean
    connect?: DiscountWhereUniqueInput
    update?: XOR<XOR<DiscountUpdateToOneWithWhereWithoutOrderDetailsInput, DiscountUpdateWithoutOrderDetailsInput>, DiscountUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type UserUpdateOneRequiredWithoutOrderDetailsNestedInput = {
    create?: XOR<UserCreateWithoutOrderDetailsInput, UserUncheckedCreateWithoutOrderDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderDetailsInput
    upsert?: UserUpsertWithoutOrderDetailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderDetailsInput, UserUpdateWithoutOrderDetailsInput>, UserUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type OrderItemUpdateManyWithoutOrderDetailsNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderDetailsInput, OrderItemUncheckedCreateWithoutOrderDetailsInput> | OrderItemCreateWithoutOrderDetailsInput[] | OrderItemUncheckedCreateWithoutOrderDetailsInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderDetailsInput | OrderItemCreateOrConnectWithoutOrderDetailsInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderDetailsInput | OrderItemUpsertWithWhereUniqueWithoutOrderDetailsInput[]
    createMany?: OrderItemCreateManyOrderDetailsInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderDetailsInput | OrderItemUpdateWithWhereUniqueWithoutOrderDetailsInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderDetailsInput | OrderItemUpdateManyWithWhereWithoutOrderDetailsInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentDetailsUpdateManyWithoutOrderDetailsNestedInput = {
    create?: XOR<PaymentDetailsCreateWithoutOrderDetailsInput, PaymentDetailsUncheckedCreateWithoutOrderDetailsInput> | PaymentDetailsCreateWithoutOrderDetailsInput[] | PaymentDetailsUncheckedCreateWithoutOrderDetailsInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutOrderDetailsInput | PaymentDetailsCreateOrConnectWithoutOrderDetailsInput[]
    upsert?: PaymentDetailsUpsertWithWhereUniqueWithoutOrderDetailsInput | PaymentDetailsUpsertWithWhereUniqueWithoutOrderDetailsInput[]
    createMany?: PaymentDetailsCreateManyOrderDetailsInputEnvelope
    set?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    disconnect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    delete?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    update?: PaymentDetailsUpdateWithWhereUniqueWithoutOrderDetailsInput | PaymentDetailsUpdateWithWhereUniqueWithoutOrderDetailsInput[]
    updateMany?: PaymentDetailsUpdateManyWithWhereWithoutOrderDetailsInput | PaymentDetailsUpdateManyWithWhereWithoutOrderDetailsInput[]
    deleteMany?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderDetailsNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderDetailsInput, OrderItemUncheckedCreateWithoutOrderDetailsInput> | OrderItemCreateWithoutOrderDetailsInput[] | OrderItemUncheckedCreateWithoutOrderDetailsInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderDetailsInput | OrderItemCreateOrConnectWithoutOrderDetailsInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderDetailsInput | OrderItemUpsertWithWhereUniqueWithoutOrderDetailsInput[]
    createMany?: OrderItemCreateManyOrderDetailsInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderDetailsInput | OrderItemUpdateWithWhereUniqueWithoutOrderDetailsInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderDetailsInput | OrderItemUpdateManyWithWhereWithoutOrderDetailsInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentDetailsUncheckedUpdateManyWithoutOrderDetailsNestedInput = {
    create?: XOR<PaymentDetailsCreateWithoutOrderDetailsInput, PaymentDetailsUncheckedCreateWithoutOrderDetailsInput> | PaymentDetailsCreateWithoutOrderDetailsInput[] | PaymentDetailsUncheckedCreateWithoutOrderDetailsInput[]
    connectOrCreate?: PaymentDetailsCreateOrConnectWithoutOrderDetailsInput | PaymentDetailsCreateOrConnectWithoutOrderDetailsInput[]
    upsert?: PaymentDetailsUpsertWithWhereUniqueWithoutOrderDetailsInput | PaymentDetailsUpsertWithWhereUniqueWithoutOrderDetailsInput[]
    createMany?: PaymentDetailsCreateManyOrderDetailsInputEnvelope
    set?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    disconnect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    delete?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    connect?: PaymentDetailsWhereUniqueInput | PaymentDetailsWhereUniqueInput[]
    update?: PaymentDetailsUpdateWithWhereUniqueWithoutOrderDetailsInput | PaymentDetailsUpdateWithWhereUniqueWithoutOrderDetailsInput[]
    updateMany?: PaymentDetailsUpdateManyWithWhereWithoutOrderDetailsInput | PaymentDetailsUpdateManyWithWhereWithoutOrderDetailsInput[]
    deleteMany?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
  }

  export type ProductColorCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ProductColorCreateWithoutOrderItemInput, ProductColorUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutOrderItemInput
    connect?: ProductColorWhereUniqueInput
  }

  export type ProductImageCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ProductImageCreateWithoutOrderItemInput, ProductImageUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductImageCreateOrConnectWithoutOrderItemInput
    connect?: ProductImageWhereUniqueInput
  }

  export type OrderDetailsCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<OrderDetailsCreateWithoutOrderItemInput, OrderDetailsUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutOrderItemInput
    connect?: OrderDetailsWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductSizeCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ProductSizeCreateWithoutOrderItemInput, ProductSizeUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductSizeCreateOrConnectWithoutOrderItemInput
    connect?: ProductSizeWhereUniqueInput
  }

  export type ReturnRequestCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput> | ReturnRequestCreateWithoutOrderItemInput[] | ReturnRequestUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderItemInput | ReturnRequestCreateOrConnectWithoutOrderItemInput[]
    createMany?: ReturnRequestCreateManyOrderItemInputEnvelope
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
  }

  export type ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput> | ReturnRequestCreateWithoutOrderItemInput[] | ReturnRequestUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderItemInput | ReturnRequestCreateOrConnectWithoutOrderItemInput[]
    createMany?: ReturnRequestCreateManyOrderItemInputEnvelope
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
  }

  export type ProductColorUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<ProductColorCreateWithoutOrderItemInput, ProductColorUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutOrderItemInput
    upsert?: ProductColorUpsertWithoutOrderItemInput
    disconnect?: ProductColorWhereInput | boolean
    delete?: ProductColorWhereInput | boolean
    connect?: ProductColorWhereUniqueInput
    update?: XOR<XOR<ProductColorUpdateToOneWithWhereWithoutOrderItemInput, ProductColorUpdateWithoutOrderItemInput>, ProductColorUncheckedUpdateWithoutOrderItemInput>
  }

  export type ProductImageUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<ProductImageCreateWithoutOrderItemInput, ProductImageUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductImageCreateOrConnectWithoutOrderItemInput
    upsert?: ProductImageUpsertWithoutOrderItemInput
    disconnect?: ProductImageWhereInput | boolean
    delete?: ProductImageWhereInput | boolean
    connect?: ProductImageWhereUniqueInput
    update?: XOR<XOR<ProductImageUpdateToOneWithWhereWithoutOrderItemInput, ProductImageUpdateWithoutOrderItemInput>, ProductImageUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderDetailsUpdateOneRequiredWithoutOrderItemNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutOrderItemInput, OrderDetailsUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutOrderItemInput
    upsert?: OrderDetailsUpsertWithoutOrderItemInput
    connect?: OrderDetailsWhereUniqueInput
    update?: XOR<XOR<OrderDetailsUpdateToOneWithWhereWithoutOrderItemInput, OrderDetailsUpdateWithoutOrderItemInput>, OrderDetailsUncheckedUpdateWithoutOrderItemInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemInput
    upsert?: ProductUpsertWithoutOrderItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemInput, ProductUpdateWithoutOrderItemInput>, ProductUncheckedUpdateWithoutOrderItemInput>
  }

  export type ProductSizeUpdateOneWithoutOrderItemNestedInput = {
    create?: XOR<ProductSizeCreateWithoutOrderItemInput, ProductSizeUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ProductSizeCreateOrConnectWithoutOrderItemInput
    upsert?: ProductSizeUpsertWithoutOrderItemInput
    disconnect?: ProductSizeWhereInput | boolean
    delete?: ProductSizeWhereInput | boolean
    connect?: ProductSizeWhereUniqueInput
    update?: XOR<XOR<ProductSizeUpdateToOneWithWhereWithoutOrderItemInput, ProductSizeUpdateWithoutOrderItemInput>, ProductSizeUncheckedUpdateWithoutOrderItemInput>
  }

  export type ReturnRequestUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput> | ReturnRequestCreateWithoutOrderItemInput[] | ReturnRequestUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderItemInput | ReturnRequestCreateOrConnectWithoutOrderItemInput[]
    upsert?: ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput | ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: ReturnRequestCreateManyOrderItemInputEnvelope
    set?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    disconnect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    delete?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    update?: ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput | ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: ReturnRequestUpdateManyWithWhereWithoutOrderItemInput | ReturnRequestUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[]
  }

  export type ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput> | ReturnRequestCreateWithoutOrderItemInput[] | ReturnRequestUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: ReturnRequestCreateOrConnectWithoutOrderItemInput | ReturnRequestCreateOrConnectWithoutOrderItemInput[]
    upsert?: ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput | ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: ReturnRequestCreateManyOrderItemInputEnvelope
    set?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    disconnect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    delete?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    connect?: ReturnRequestWhereUniqueInput | ReturnRequestWhereUniqueInput[]
    update?: ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput | ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: ReturnRequestUpdateManyWithWhereWithoutOrderItemInput | ReturnRequestUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOtpInput = {
    create?: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOtpNestedInput = {
    create?: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpInput
    upsert?: UserUpsertWithoutOtpInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpInput, UserUpdateWithoutOtpInput>, UserUncheckedUpdateWithoutOtpInput>
  }

  export type OrderDetailsCreateNestedOneWithoutPaymentDetailsInput = {
    create?: XOR<OrderDetailsCreateWithoutPaymentDetailsInput, OrderDetailsUncheckedCreateWithoutPaymentDetailsInput>
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutPaymentDetailsInput
    connect?: OrderDetailsWhereUniqueInput
  }

  export type OrderDetailsUpdateOneRequiredWithoutPaymentDetailsNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutPaymentDetailsInput, OrderDetailsUncheckedCreateWithoutPaymentDetailsInput>
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutPaymentDetailsInput
    upsert?: OrderDetailsUpsertWithoutPaymentDetailsInput
    connect?: OrderDetailsWhereUniqueInput
    update?: XOR<XOR<OrderDetailsUpdateToOneWithWhereWithoutPaymentDetailsInput, OrderDetailsUpdateWithoutPaymentDetailsInput>, OrderDetailsUncheckedUpdateWithoutPaymentDetailsInput>
  }

  export type UserPrivilegeCreateNestedManyWithoutPrivilegeInput = {
    create?: XOR<UserPrivilegeCreateWithoutPrivilegeInput, UserPrivilegeUncheckedCreateWithoutPrivilegeInput> | UserPrivilegeCreateWithoutPrivilegeInput[] | UserPrivilegeUncheckedCreateWithoutPrivilegeInput[]
    connectOrCreate?: UserPrivilegeCreateOrConnectWithoutPrivilegeInput | UserPrivilegeCreateOrConnectWithoutPrivilegeInput[]
    createMany?: UserPrivilegeCreateManyPrivilegeInputEnvelope
    connect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
  }

  export type UserPrivilegeUncheckedCreateNestedManyWithoutPrivilegeInput = {
    create?: XOR<UserPrivilegeCreateWithoutPrivilegeInput, UserPrivilegeUncheckedCreateWithoutPrivilegeInput> | UserPrivilegeCreateWithoutPrivilegeInput[] | UserPrivilegeUncheckedCreateWithoutPrivilegeInput[]
    connectOrCreate?: UserPrivilegeCreateOrConnectWithoutPrivilegeInput | UserPrivilegeCreateOrConnectWithoutPrivilegeInput[]
    createMany?: UserPrivilegeCreateManyPrivilegeInputEnvelope
    connect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
  }

  export type UserPrivilegeUpdateManyWithoutPrivilegeNestedInput = {
    create?: XOR<UserPrivilegeCreateWithoutPrivilegeInput, UserPrivilegeUncheckedCreateWithoutPrivilegeInput> | UserPrivilegeCreateWithoutPrivilegeInput[] | UserPrivilegeUncheckedCreateWithoutPrivilegeInput[]
    connectOrCreate?: UserPrivilegeCreateOrConnectWithoutPrivilegeInput | UserPrivilegeCreateOrConnectWithoutPrivilegeInput[]
    upsert?: UserPrivilegeUpsertWithWhereUniqueWithoutPrivilegeInput | UserPrivilegeUpsertWithWhereUniqueWithoutPrivilegeInput[]
    createMany?: UserPrivilegeCreateManyPrivilegeInputEnvelope
    set?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    disconnect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    delete?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    connect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    update?: UserPrivilegeUpdateWithWhereUniqueWithoutPrivilegeInput | UserPrivilegeUpdateWithWhereUniqueWithoutPrivilegeInput[]
    updateMany?: UserPrivilegeUpdateManyWithWhereWithoutPrivilegeInput | UserPrivilegeUpdateManyWithWhereWithoutPrivilegeInput[]
    deleteMany?: UserPrivilegeScalarWhereInput | UserPrivilegeScalarWhereInput[]
  }

  export type UserPrivilegeUncheckedUpdateManyWithoutPrivilegeNestedInput = {
    create?: XOR<UserPrivilegeCreateWithoutPrivilegeInput, UserPrivilegeUncheckedCreateWithoutPrivilegeInput> | UserPrivilegeCreateWithoutPrivilegeInput[] | UserPrivilegeUncheckedCreateWithoutPrivilegeInput[]
    connectOrCreate?: UserPrivilegeCreateOrConnectWithoutPrivilegeInput | UserPrivilegeCreateOrConnectWithoutPrivilegeInput[]
    upsert?: UserPrivilegeUpsertWithWhereUniqueWithoutPrivilegeInput | UserPrivilegeUpsertWithWhereUniqueWithoutPrivilegeInput[]
    createMany?: UserPrivilegeCreateManyPrivilegeInputEnvelope
    set?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    disconnect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    delete?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    connect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    update?: UserPrivilegeUpdateWithWhereUniqueWithoutPrivilegeInput | UserPrivilegeUpdateWithWhereUniqueWithoutPrivilegeInput[]
    updateMany?: UserPrivilegeUpdateManyWithWhereWithoutPrivilegeInput | UserPrivilegeUpdateManyWithWhereWithoutPrivilegeInput[]
    deleteMany?: UserPrivilegeScalarWhereInput | UserPrivilegeScalarWhereInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type DiscountCreateNestedManyWithoutProductInput = {
    create?: XOR<DiscountCreateWithoutProductInput, DiscountUncheckedCreateWithoutProductInput> | DiscountCreateWithoutProductInput[] | DiscountUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutProductInput | DiscountCreateOrConnectWithoutProductInput[]
    createMany?: DiscountCreateManyProductInputEnvelope
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CustomerTypeCreateNestedOneWithoutProductInput = {
    create?: XOR<CustomerTypeCreateWithoutProductInput, CustomerTypeUncheckedCreateWithoutProductInput>
    connectOrCreate?: CustomerTypeCreateOrConnectWithoutProductInput
    connect?: CustomerTypeWhereUniqueInput
  }

  export type ProductFabricCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductFabricCreateWithoutProductInput, ProductFabricUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductFabricCreateOrConnectWithoutProductInput
    connect?: ProductFabricWhereUniqueInput
  }

  export type SizeChartCreateNestedOneWithoutProductInput = {
    create?: XOR<SizeChartCreateWithoutProductInput, SizeChartUncheckedCreateWithoutProductInput>
    connectOrCreate?: SizeChartCreateOrConnectWithoutProductInput
    connect?: SizeChartWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductInput = {
    create?: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductInput
    connect?: UserWhereUniqueInput
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type ProductInventoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductInventoryCreateWithoutProductInput, ProductInventoryUncheckedCreateWithoutProductInput> | ProductInventoryCreateWithoutProductInput[] | ProductInventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductInventoryCreateOrConnectWithoutProductInput | ProductInventoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductInventoryCreateManyProductInputEnvelope
    connect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
  }

  export type ProductReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type WishlistItemCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutProduct_BInput = {
    create?: XOR<ProductCreateWithoutProduct_BInput, ProductUncheckedCreateWithoutProduct_BInput> | ProductCreateWithoutProduct_BInput[] | ProductUncheckedCreateWithoutProduct_BInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_BInput | ProductCreateOrConnectWithoutProduct_BInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutProduct_AInput = {
    create?: XOR<ProductCreateWithoutProduct_AInput, ProductUncheckedCreateWithoutProduct_AInput> | ProductCreateWithoutProduct_AInput[] | ProductUncheckedCreateWithoutProduct_AInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_AInput | ProductCreateOrConnectWithoutProduct_AInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubCategoryCreateNestedManyWithoutProductInput = {
    create?: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput> | SubCategoryCreateWithoutProductInput[] | SubCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductInput | SubCategoryCreateOrConnectWithoutProductInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type DiscountUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<DiscountCreateWithoutProductInput, DiscountUncheckedCreateWithoutProductInput> | DiscountCreateWithoutProductInput[] | DiscountUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutProductInput | DiscountCreateOrConnectWithoutProductInput[]
    createMany?: DiscountCreateManyProductInputEnvelope
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type ProductInventoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductInventoryCreateWithoutProductInput, ProductInventoryUncheckedCreateWithoutProductInput> | ProductInventoryCreateWithoutProductInput[] | ProductInventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductInventoryCreateOrConnectWithoutProductInput | ProductInventoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductInventoryCreateManyProductInputEnvelope
    connect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
  }

  export type ProductReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProduct_BInput = {
    create?: XOR<ProductCreateWithoutProduct_BInput, ProductUncheckedCreateWithoutProduct_BInput> | ProductCreateWithoutProduct_BInput[] | ProductUncheckedCreateWithoutProduct_BInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_BInput | ProductCreateOrConnectWithoutProduct_BInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProduct_AInput = {
    create?: XOR<ProductCreateWithoutProduct_AInput, ProductUncheckedCreateWithoutProduct_AInput> | ProductCreateWithoutProduct_AInput[] | ProductUncheckedCreateWithoutProduct_AInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_AInput | ProductCreateOrConnectWithoutProduct_AInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubCategoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput> | SubCategoryCreateWithoutProductInput[] | SubCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductInput | SubCategoryCreateOrConnectWithoutProductInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type DiscountUpdateManyWithoutProductNestedInput = {
    create?: XOR<DiscountCreateWithoutProductInput, DiscountUncheckedCreateWithoutProductInput> | DiscountCreateWithoutProductInput[] | DiscountUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutProductInput | DiscountCreateOrConnectWithoutProductInput[]
    upsert?: DiscountUpsertWithWhereUniqueWithoutProductInput | DiscountUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: DiscountCreateManyProductInputEnvelope
    set?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    disconnect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    delete?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    update?: DiscountUpdateWithWhereUniqueWithoutProductInput | DiscountUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: DiscountUpdateManyWithWhereWithoutProductInput | DiscountUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CustomerTypeUpdateOneWithoutProductNestedInput = {
    create?: XOR<CustomerTypeCreateWithoutProductInput, CustomerTypeUncheckedCreateWithoutProductInput>
    connectOrCreate?: CustomerTypeCreateOrConnectWithoutProductInput
    upsert?: CustomerTypeUpsertWithoutProductInput
    disconnect?: CustomerTypeWhereInput | boolean
    delete?: CustomerTypeWhereInput | boolean
    connect?: CustomerTypeWhereUniqueInput
    update?: XOR<XOR<CustomerTypeUpdateToOneWithWhereWithoutProductInput, CustomerTypeUpdateWithoutProductInput>, CustomerTypeUncheckedUpdateWithoutProductInput>
  }

  export type ProductFabricUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductFabricCreateWithoutProductInput, ProductFabricUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductFabricCreateOrConnectWithoutProductInput
    upsert?: ProductFabricUpsertWithoutProductInput
    disconnect?: ProductFabricWhereInput | boolean
    delete?: ProductFabricWhereInput | boolean
    connect?: ProductFabricWhereUniqueInput
    update?: XOR<XOR<ProductFabricUpdateToOneWithWhereWithoutProductInput, ProductFabricUpdateWithoutProductInput>, ProductFabricUncheckedUpdateWithoutProductInput>
  }

  export type SizeChartUpdateOneWithoutProductNestedInput = {
    create?: XOR<SizeChartCreateWithoutProductInput, SizeChartUncheckedCreateWithoutProductInput>
    connectOrCreate?: SizeChartCreateOrConnectWithoutProductInput
    upsert?: SizeChartUpsertWithoutProductInput
    disconnect?: SizeChartWhereInput | boolean
    delete?: SizeChartWhereInput | boolean
    connect?: SizeChartWhereUniqueInput
    update?: XOR<XOR<SizeChartUpdateToOneWithWhereWithoutProductInput, SizeChartUpdateWithoutProductInput>, SizeChartUncheckedUpdateWithoutProductInput>
  }

  export type UserUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductInput
    upsert?: UserUpsertWithoutProductInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductInput, UserUpdateWithoutProductInput>, UserUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type ProductInventoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductInventoryCreateWithoutProductInput, ProductInventoryUncheckedCreateWithoutProductInput> | ProductInventoryCreateWithoutProductInput[] | ProductInventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductInventoryCreateOrConnectWithoutProductInput | ProductInventoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductInventoryUpsertWithWhereUniqueWithoutProductInput | ProductInventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductInventoryCreateManyProductInputEnvelope
    set?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    disconnect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    delete?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    connect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    update?: ProductInventoryUpdateWithWhereUniqueWithoutProductInput | ProductInventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductInventoryUpdateManyWithWhereWithoutProductInput | ProductInventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductInventoryScalarWhereInput | ProductInventoryScalarWhereInput[]
  }

  export type ProductReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutProductInput | ProductReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutProductInput | ProductReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutProductInput | ProductReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type WishlistItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutProductInput | WishlistItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutProductInput | WishlistItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutProductInput | WishlistItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutProduct_BNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_BInput, ProductUncheckedCreateWithoutProduct_BInput> | ProductCreateWithoutProduct_BInput[] | ProductUncheckedCreateWithoutProduct_BInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_BInput | ProductCreateOrConnectWithoutProduct_BInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_BInput | ProductUpsertWithWhereUniqueWithoutProduct_BInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_BInput | ProductUpdateWithWhereUniqueWithoutProduct_BInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_BInput | ProductUpdateManyWithWhereWithoutProduct_BInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutProduct_ANestedInput = {
    create?: XOR<ProductCreateWithoutProduct_AInput, ProductUncheckedCreateWithoutProduct_AInput> | ProductCreateWithoutProduct_AInput[] | ProductUncheckedCreateWithoutProduct_AInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_AInput | ProductCreateOrConnectWithoutProduct_AInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_AInput | ProductUpsertWithWhereUniqueWithoutProduct_AInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_AInput | ProductUpdateWithWhereUniqueWithoutProduct_AInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_AInput | ProductUpdateManyWithWhereWithoutProduct_AInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubCategoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput> | SubCategoryCreateWithoutProductInput[] | SubCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductInput | SubCategoryCreateOrConnectWithoutProductInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutProductInput | SubCategoryUpsertWithWhereUniqueWithoutProductInput[]
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutProductInput | SubCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutProductInput | SubCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type DiscountUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<DiscountCreateWithoutProductInput, DiscountUncheckedCreateWithoutProductInput> | DiscountCreateWithoutProductInput[] | DiscountUncheckedCreateWithoutProductInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutProductInput | DiscountCreateOrConnectWithoutProductInput[]
    upsert?: DiscountUpsertWithWhereUniqueWithoutProductInput | DiscountUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: DiscountCreateManyProductInputEnvelope
    set?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    disconnect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    delete?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    update?: DiscountUpdateWithWhereUniqueWithoutProductInput | DiscountUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: DiscountUpdateManyWithWhereWithoutProductInput | DiscountUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type ProductInventoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductInventoryCreateWithoutProductInput, ProductInventoryUncheckedCreateWithoutProductInput> | ProductInventoryCreateWithoutProductInput[] | ProductInventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductInventoryCreateOrConnectWithoutProductInput | ProductInventoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductInventoryUpsertWithWhereUniqueWithoutProductInput | ProductInventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductInventoryCreateManyProductInputEnvelope
    set?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    disconnect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    delete?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    connect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    update?: ProductInventoryUpdateWithWhereUniqueWithoutProductInput | ProductInventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductInventoryUpdateManyWithWhereWithoutProductInput | ProductInventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductInventoryScalarWhereInput | ProductInventoryScalarWhereInput[]
  }

  export type ProductReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput> | ProductReviewCreateWithoutProductInput[] | ProductReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutProductInput | ProductReviewCreateOrConnectWithoutProductInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutProductInput | ProductReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductReviewCreateManyProductInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutProductInput | ProductReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutProductInput | ProductReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput> | WishlistItemCreateWithoutProductInput[] | WishlistItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutProductInput | WishlistItemCreateOrConnectWithoutProductInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutProductInput | WishlistItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutProductInput | WishlistItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutProductInput | WishlistItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProduct_BNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_BInput, ProductUncheckedCreateWithoutProduct_BInput> | ProductCreateWithoutProduct_BInput[] | ProductUncheckedCreateWithoutProduct_BInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_BInput | ProductCreateOrConnectWithoutProduct_BInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_BInput | ProductUpsertWithWhereUniqueWithoutProduct_BInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_BInput | ProductUpdateWithWhereUniqueWithoutProduct_BInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_BInput | ProductUpdateManyWithWhereWithoutProduct_BInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProduct_ANestedInput = {
    create?: XOR<ProductCreateWithoutProduct_AInput, ProductUncheckedCreateWithoutProduct_AInput> | ProductCreateWithoutProduct_AInput[] | ProductUncheckedCreateWithoutProduct_AInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_AInput | ProductCreateOrConnectWithoutProduct_AInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_AInput | ProductUpsertWithWhereUniqueWithoutProduct_AInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_AInput | ProductUpdateWithWhereUniqueWithoutProduct_AInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_AInput | ProductUpdateManyWithWhereWithoutProduct_AInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubCategoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput> | SubCategoryCreateWithoutProductInput[] | SubCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductInput | SubCategoryCreateOrConnectWithoutProductInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutProductInput | SubCategoryUpsertWithWhereUniqueWithoutProductInput[]
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutProductInput | SubCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutProductInput | SubCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type AnchorTextCreateNestedOneWithoutProductCategoryInput = {
    create?: XOR<AnchorTextCreateWithoutProductCategoryInput, AnchorTextUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: AnchorTextCreateOrConnectWithoutProductCategoryInput
    connect?: AnchorTextWhereUniqueInput
  }

  export type QuotesCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<QuotesCreateWithoutProductCategoryInput, QuotesUncheckedCreateWithoutProductCategoryInput> | QuotesCreateWithoutProductCategoryInput[] | QuotesUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutProductCategoryInput | QuotesCreateOrConnectWithoutProductCategoryInput[]
    createMany?: QuotesCreateManyProductCategoryInputEnvelope
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
  }

  export type SubCategoryCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutProductCategoryInput, SubCategoryUncheckedCreateWithoutProductCategoryInput> | SubCategoryCreateWithoutProductCategoryInput[] | SubCategoryUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductCategoryInput | SubCategoryCreateOrConnectWithoutProductCategoryInput[]
    createMany?: SubCategoryCreateManyProductCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type AnchorTextUncheckedCreateNestedOneWithoutProductCategoryInput = {
    create?: XOR<AnchorTextCreateWithoutProductCategoryInput, AnchorTextUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: AnchorTextCreateOrConnectWithoutProductCategoryInput
    connect?: AnchorTextWhereUniqueInput
  }

  export type QuotesUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<QuotesCreateWithoutProductCategoryInput, QuotesUncheckedCreateWithoutProductCategoryInput> | QuotesCreateWithoutProductCategoryInput[] | QuotesUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutProductCategoryInput | QuotesCreateOrConnectWithoutProductCategoryInput[]
    createMany?: QuotesCreateManyProductCategoryInputEnvelope
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
  }

  export type SubCategoryUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutProductCategoryInput, SubCategoryUncheckedCreateWithoutProductCategoryInput> | SubCategoryCreateWithoutProductCategoryInput[] | SubCategoryUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductCategoryInput | SubCategoryCreateOrConnectWithoutProductCategoryInput[]
    createMany?: SubCategoryCreateManyProductCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type AnchorTextUpdateOneWithoutProductCategoryNestedInput = {
    create?: XOR<AnchorTextCreateWithoutProductCategoryInput, AnchorTextUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: AnchorTextCreateOrConnectWithoutProductCategoryInput
    upsert?: AnchorTextUpsertWithoutProductCategoryInput
    disconnect?: AnchorTextWhereInput | boolean
    delete?: AnchorTextWhereInput | boolean
    connect?: AnchorTextWhereUniqueInput
    update?: XOR<XOR<AnchorTextUpdateToOneWithWhereWithoutProductCategoryInput, AnchorTextUpdateWithoutProductCategoryInput>, AnchorTextUncheckedUpdateWithoutProductCategoryInput>
  }

  export type QuotesUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<QuotesCreateWithoutProductCategoryInput, QuotesUncheckedCreateWithoutProductCategoryInput> | QuotesCreateWithoutProductCategoryInput[] | QuotesUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutProductCategoryInput | QuotesCreateOrConnectWithoutProductCategoryInput[]
    upsert?: QuotesUpsertWithWhereUniqueWithoutProductCategoryInput | QuotesUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: QuotesCreateManyProductCategoryInputEnvelope
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    update?: QuotesUpdateWithWhereUniqueWithoutProductCategoryInput | QuotesUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: QuotesUpdateManyWithWhereWithoutProductCategoryInput | QuotesUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
  }

  export type SubCategoryUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutProductCategoryInput, SubCategoryUncheckedCreateWithoutProductCategoryInput> | SubCategoryCreateWithoutProductCategoryInput[] | SubCategoryUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductCategoryInput | SubCategoryCreateOrConnectWithoutProductCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutProductCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: SubCategoryCreateManyProductCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutProductCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutProductCategoryInput | SubCategoryUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AnchorTextUncheckedUpdateOneWithoutProductCategoryNestedInput = {
    create?: XOR<AnchorTextCreateWithoutProductCategoryInput, AnchorTextUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: AnchorTextCreateOrConnectWithoutProductCategoryInput
    upsert?: AnchorTextUpsertWithoutProductCategoryInput
    disconnect?: AnchorTextWhereInput | boolean
    delete?: AnchorTextWhereInput | boolean
    connect?: AnchorTextWhereUniqueInput
    update?: XOR<XOR<AnchorTextUpdateToOneWithWhereWithoutProductCategoryInput, AnchorTextUpdateWithoutProductCategoryInput>, AnchorTextUncheckedUpdateWithoutProductCategoryInput>
  }

  export type QuotesUncheckedUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<QuotesCreateWithoutProductCategoryInput, QuotesUncheckedCreateWithoutProductCategoryInput> | QuotesCreateWithoutProductCategoryInput[] | QuotesUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: QuotesCreateOrConnectWithoutProductCategoryInput | QuotesCreateOrConnectWithoutProductCategoryInput[]
    upsert?: QuotesUpsertWithWhereUniqueWithoutProductCategoryInput | QuotesUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: QuotesCreateManyProductCategoryInputEnvelope
    set?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    disconnect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    delete?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    connect?: QuotesWhereUniqueInput | QuotesWhereUniqueInput[]
    update?: QuotesUpdateWithWhereUniqueWithoutProductCategoryInput | QuotesUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: QuotesUpdateManyWithWhereWithoutProductCategoryInput | QuotesUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
  }

  export type SubCategoryUncheckedUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutProductCategoryInput, SubCategoryUncheckedCreateWithoutProductCategoryInput> | SubCategoryCreateWithoutProductCategoryInput[] | SubCategoryUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutProductCategoryInput | SubCategoryCreateOrConnectWithoutProductCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutProductCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: SubCategoryCreateManyProductCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutProductCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutProductCategoryInput | SubCategoryUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CartItemCreateNestedManyWithoutProductColorInput = {
    create?: XOR<CartItemCreateWithoutProductColorInput, CartItemUncheckedCreateWithoutProductColorInput> | CartItemCreateWithoutProductColorInput[] | CartItemUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductColorInput | CartItemCreateOrConnectWithoutProductColorInput[]
    createMany?: CartItemCreateManyProductColorInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductColorInput = {
    create?: XOR<OrderItemCreateWithoutProductColorInput, OrderItemUncheckedCreateWithoutProductColorInput> | OrderItemCreateWithoutProductColorInput[] | OrderItemUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductColorInput | OrderItemCreateOrConnectWithoutProductColorInput[]
    createMany?: OrderItemCreateManyProductColorInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductImageCreateNestedManyWithoutProductColorInput = {
    create?: XOR<ProductImageCreateWithoutProductColorInput, ProductImageUncheckedCreateWithoutProductColorInput> | ProductImageCreateWithoutProductColorInput[] | ProductImageUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductColorInput | ProductImageCreateOrConnectWithoutProductColorInput[]
    createMany?: ProductImageCreateManyProductColorInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductColorInput = {
    create?: XOR<CartItemCreateWithoutProductColorInput, CartItemUncheckedCreateWithoutProductColorInput> | CartItemCreateWithoutProductColorInput[] | CartItemUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductColorInput | CartItemCreateOrConnectWithoutProductColorInput[]
    createMany?: CartItemCreateManyProductColorInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductColorInput = {
    create?: XOR<OrderItemCreateWithoutProductColorInput, OrderItemUncheckedCreateWithoutProductColorInput> | OrderItemCreateWithoutProductColorInput[] | OrderItemUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductColorInput | OrderItemCreateOrConnectWithoutProductColorInput[]
    createMany?: OrderItemCreateManyProductColorInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductColorInput = {
    create?: XOR<ProductImageCreateWithoutProductColorInput, ProductImageUncheckedCreateWithoutProductColorInput> | ProductImageCreateWithoutProductColorInput[] | ProductImageUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductColorInput | ProductImageCreateOrConnectWithoutProductColorInput[]
    createMany?: ProductImageCreateManyProductColorInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type CartItemUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<CartItemCreateWithoutProductColorInput, CartItemUncheckedCreateWithoutProductColorInput> | CartItemCreateWithoutProductColorInput[] | CartItemUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductColorInput | CartItemCreateOrConnectWithoutProductColorInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductColorInput | CartItemUpsertWithWhereUniqueWithoutProductColorInput[]
    createMany?: CartItemCreateManyProductColorInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductColorInput | CartItemUpdateWithWhereUniqueWithoutProductColorInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductColorInput | CartItemUpdateManyWithWhereWithoutProductColorInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductColorInput, OrderItemUncheckedCreateWithoutProductColorInput> | OrderItemCreateWithoutProductColorInput[] | OrderItemUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductColorInput | OrderItemCreateOrConnectWithoutProductColorInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductColorInput | OrderItemUpsertWithWhereUniqueWithoutProductColorInput[]
    createMany?: OrderItemCreateManyProductColorInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductColorInput | OrderItemUpdateWithWhereUniqueWithoutProductColorInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductColorInput | OrderItemUpdateManyWithWhereWithoutProductColorInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductImageUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductColorInput, ProductImageUncheckedCreateWithoutProductColorInput> | ProductImageCreateWithoutProductColorInput[] | ProductImageUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductColorInput | ProductImageCreateOrConnectWithoutProductColorInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductColorInput | ProductImageUpsertWithWhereUniqueWithoutProductColorInput[]
    createMany?: ProductImageCreateManyProductColorInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductColorInput | ProductImageUpdateWithWhereUniqueWithoutProductColorInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductColorInput | ProductImageUpdateManyWithWhereWithoutProductColorInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<CartItemCreateWithoutProductColorInput, CartItemUncheckedCreateWithoutProductColorInput> | CartItemCreateWithoutProductColorInput[] | CartItemUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductColorInput | CartItemCreateOrConnectWithoutProductColorInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductColorInput | CartItemUpsertWithWhereUniqueWithoutProductColorInput[]
    createMany?: CartItemCreateManyProductColorInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductColorInput | CartItemUpdateWithWhereUniqueWithoutProductColorInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductColorInput | CartItemUpdateManyWithWhereWithoutProductColorInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductColorInput, OrderItemUncheckedCreateWithoutProductColorInput> | OrderItemCreateWithoutProductColorInput[] | OrderItemUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductColorInput | OrderItemCreateOrConnectWithoutProductColorInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductColorInput | OrderItemUpsertWithWhereUniqueWithoutProductColorInput[]
    createMany?: OrderItemCreateManyProductColorInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductColorInput | OrderItemUpdateWithWhereUniqueWithoutProductColorInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductColorInput | OrderItemUpdateManyWithWhereWithoutProductColorInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductImageUncheckedUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductColorInput, ProductImageUncheckedCreateWithoutProductColorInput> | ProductImageCreateWithoutProductColorInput[] | ProductImageUncheckedCreateWithoutProductColorInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductColorInput | ProductImageCreateOrConnectWithoutProductColorInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductColorInput | ProductImageUpsertWithWhereUniqueWithoutProductColorInput[]
    createMany?: ProductImageCreateManyProductColorInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductColorInput | ProductImageUpdateWithWhereUniqueWithoutProductColorInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductColorInput | ProductImageUpdateManyWithWhereWithoutProductColorInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProductFabricInput = {
    create?: XOR<ProductCreateWithoutProductFabricInput, ProductUncheckedCreateWithoutProductFabricInput> | ProductCreateWithoutProductFabricInput[] | ProductUncheckedCreateWithoutProductFabricInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductFabricInput | ProductCreateOrConnectWithoutProductFabricInput[]
    createMany?: ProductCreateManyProductFabricInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProductFabricInput = {
    create?: XOR<ProductCreateWithoutProductFabricInput, ProductUncheckedCreateWithoutProductFabricInput> | ProductCreateWithoutProductFabricInput[] | ProductUncheckedCreateWithoutProductFabricInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductFabricInput | ProductCreateOrConnectWithoutProductFabricInput[]
    createMany?: ProductCreateManyProductFabricInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProductFabricNestedInput = {
    create?: XOR<ProductCreateWithoutProductFabricInput, ProductUncheckedCreateWithoutProductFabricInput> | ProductCreateWithoutProductFabricInput[] | ProductUncheckedCreateWithoutProductFabricInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductFabricInput | ProductCreateOrConnectWithoutProductFabricInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductFabricInput | ProductUpsertWithWhereUniqueWithoutProductFabricInput[]
    createMany?: ProductCreateManyProductFabricInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductFabricInput | ProductUpdateWithWhereUniqueWithoutProductFabricInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductFabricInput | ProductUpdateManyWithWhereWithoutProductFabricInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProductFabricNestedInput = {
    create?: XOR<ProductCreateWithoutProductFabricInput, ProductUncheckedCreateWithoutProductFabricInput> | ProductCreateWithoutProductFabricInput[] | ProductUncheckedCreateWithoutProductFabricInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductFabricInput | ProductCreateOrConnectWithoutProductFabricInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductFabricInput | ProductUpsertWithWhereUniqueWithoutProductFabricInput[]
    createMany?: ProductCreateManyProductFabricInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductFabricInput | ProductUpdateWithWhereUniqueWithoutProductFabricInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductFabricInput | ProductUpdateManyWithWhereWithoutProductFabricInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CartItemCreateNestedManyWithoutProductImageInput = {
    create?: XOR<CartItemCreateWithoutProductImageInput, CartItemUncheckedCreateWithoutProductImageInput> | CartItemCreateWithoutProductImageInput[] | CartItemUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductImageInput | CartItemCreateOrConnectWithoutProductImageInput[]
    createMany?: CartItemCreateManyProductImageInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductImageInput = {
    create?: XOR<OrderItemCreateWithoutProductImageInput, OrderItemUncheckedCreateWithoutProductImageInput> | OrderItemCreateWithoutProductImageInput[] | OrderItemUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductImageInput | OrderItemCreateOrConnectWithoutProductImageInput[]
    createMany?: OrderItemCreateManyProductImageInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductColorCreateNestedOneWithoutProductImageInput = {
    create?: XOR<ProductColorCreateWithoutProductImageInput, ProductColorUncheckedCreateWithoutProductImageInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutProductImageInput
    connect?: ProductColorWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProductImageInput = {
    create?: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImageInput
    connect?: ProductWhereUniqueInput
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductImageInput = {
    create?: XOR<CartItemCreateWithoutProductImageInput, CartItemUncheckedCreateWithoutProductImageInput> | CartItemCreateWithoutProductImageInput[] | CartItemUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductImageInput | CartItemCreateOrConnectWithoutProductImageInput[]
    createMany?: CartItemCreateManyProductImageInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductImageInput = {
    create?: XOR<OrderItemCreateWithoutProductImageInput, OrderItemUncheckedCreateWithoutProductImageInput> | OrderItemCreateWithoutProductImageInput[] | OrderItemUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductImageInput | OrderItemCreateOrConnectWithoutProductImageInput[]
    createMany?: OrderItemCreateManyProductImageInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CartItemUpdateManyWithoutProductImageNestedInput = {
    create?: XOR<CartItemCreateWithoutProductImageInput, CartItemUncheckedCreateWithoutProductImageInput> | CartItemCreateWithoutProductImageInput[] | CartItemUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductImageInput | CartItemCreateOrConnectWithoutProductImageInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductImageInput | CartItemUpsertWithWhereUniqueWithoutProductImageInput[]
    createMany?: CartItemCreateManyProductImageInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductImageInput | CartItemUpdateWithWhereUniqueWithoutProductImageInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductImageInput | CartItemUpdateManyWithWhereWithoutProductImageInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductImageNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductImageInput, OrderItemUncheckedCreateWithoutProductImageInput> | OrderItemCreateWithoutProductImageInput[] | OrderItemUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductImageInput | OrderItemCreateOrConnectWithoutProductImageInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductImageInput | OrderItemUpsertWithWhereUniqueWithoutProductImageInput[]
    createMany?: OrderItemCreateManyProductImageInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductImageInput | OrderItemUpdateWithWhereUniqueWithoutProductImageInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductImageInput | OrderItemUpdateManyWithWhereWithoutProductImageInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductColorUpdateOneWithoutProductImageNestedInput = {
    create?: XOR<ProductColorCreateWithoutProductImageInput, ProductColorUncheckedCreateWithoutProductImageInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutProductImageInput
    upsert?: ProductColorUpsertWithoutProductImageInput
    disconnect?: ProductColorWhereInput | boolean
    delete?: ProductColorWhereInput | boolean
    connect?: ProductColorWhereUniqueInput
    update?: XOR<XOR<ProductColorUpdateToOneWithWhereWithoutProductImageInput, ProductColorUpdateWithoutProductImageInput>, ProductColorUncheckedUpdateWithoutProductImageInput>
  }

  export type ProductUpdateOneRequiredWithoutProductImageNestedInput = {
    create?: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImageInput
    upsert?: ProductUpsertWithoutProductImageInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductImageInput, ProductUpdateWithoutProductImageInput>, ProductUncheckedUpdateWithoutProductImageInput>
  }

  export type CartItemUncheckedUpdateManyWithoutProductImageNestedInput = {
    create?: XOR<CartItemCreateWithoutProductImageInput, CartItemUncheckedCreateWithoutProductImageInput> | CartItemCreateWithoutProductImageInput[] | CartItemUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductImageInput | CartItemCreateOrConnectWithoutProductImageInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductImageInput | CartItemUpsertWithWhereUniqueWithoutProductImageInput[]
    createMany?: CartItemCreateManyProductImageInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductImageInput | CartItemUpdateWithWhereUniqueWithoutProductImageInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductImageInput | CartItemUpdateManyWithWhereWithoutProductImageInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductImageNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductImageInput, OrderItemUncheckedCreateWithoutProductImageInput> | OrderItemCreateWithoutProductImageInput[] | OrderItemUncheckedCreateWithoutProductImageInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductImageInput | OrderItemCreateOrConnectWithoutProductImageInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductImageInput | OrderItemUpsertWithWhereUniqueWithoutProductImageInput[]
    createMany?: OrderItemCreateManyProductImageInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductImageInput | OrderItemUpdateWithWhereUniqueWithoutProductImageInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductImageInput | OrderItemUpdateManyWithWhereWithoutProductImageInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductInventoryInput = {
    create?: XOR<ProductCreateWithoutProductInventoryInput, ProductUncheckedCreateWithoutProductInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductInventoryInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductSizeCreateNestedOneWithoutProductInventoryInput = {
    create?: XOR<ProductSizeCreateWithoutProductInventoryInput, ProductSizeUncheckedCreateWithoutProductInventoryInput>
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInventoryInput
    connect?: ProductSizeWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductInventoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductInventoryInput, ProductUncheckedCreateWithoutProductInventoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductInventoryInput
    upsert?: ProductUpsertWithoutProductInventoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductInventoryInput, ProductUpdateWithoutProductInventoryInput>, ProductUncheckedUpdateWithoutProductInventoryInput>
  }

  export type ProductSizeUpdateOneWithoutProductInventoryNestedInput = {
    create?: XOR<ProductSizeCreateWithoutProductInventoryInput, ProductSizeUncheckedCreateWithoutProductInventoryInput>
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInventoryInput
    upsert?: ProductSizeUpsertWithoutProductInventoryInput
    disconnect?: ProductSizeWhereInput | boolean
    delete?: ProductSizeWhereInput | boolean
    connect?: ProductSizeWhereUniqueInput
    update?: XOR<XOR<ProductSizeUpdateToOneWithWhereWithoutProductInventoryInput, ProductSizeUpdateWithoutProductInventoryInput>, ProductSizeUncheckedUpdateWithoutProductInventoryInput>
  }

  export type ProductCreateNestedOneWithoutProductReviewInput = {
    create?: XOR<ProductCreateWithoutProductReviewInput, ProductUncheckedCreateWithoutProductReviewInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductReviewInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductReviewInput = {
    create?: XOR<UserCreateWithoutProductReviewInput, UserUncheckedCreateWithoutProductReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductReviewInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductReviewNestedInput = {
    create?: XOR<ProductCreateWithoutProductReviewInput, ProductUncheckedCreateWithoutProductReviewInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductReviewInput
    upsert?: ProductUpsertWithoutProductReviewInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductReviewInput, ProductUpdateWithoutProductReviewInput>, ProductUncheckedUpdateWithoutProductReviewInput>
  }

  export type UserUpdateOneRequiredWithoutProductReviewNestedInput = {
    create?: XOR<UserCreateWithoutProductReviewInput, UserUncheckedCreateWithoutProductReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductReviewInput
    upsert?: UserUpsertWithoutProductReviewInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductReviewInput, UserUpdateWithoutProductReviewInput>, UserUncheckedUpdateWithoutProductReviewInput>
  }

  export type OrderItemCreateNestedManyWithoutProductSizeInput = {
    create?: XOR<OrderItemCreateWithoutProductSizeInput, OrderItemUncheckedCreateWithoutProductSizeInput> | OrderItemCreateWithoutProductSizeInput[] | OrderItemUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductSizeInput | OrderItemCreateOrConnectWithoutProductSizeInput[]
    createMany?: OrderItemCreateManyProductSizeInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductInventoryCreateNestedManyWithoutProductSizeInput = {
    create?: XOR<ProductInventoryCreateWithoutProductSizeInput, ProductInventoryUncheckedCreateWithoutProductSizeInput> | ProductInventoryCreateWithoutProductSizeInput[] | ProductInventoryUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: ProductInventoryCreateOrConnectWithoutProductSizeInput | ProductInventoryCreateOrConnectWithoutProductSizeInput[]
    createMany?: ProductInventoryCreateManyProductSizeInputEnvelope
    connect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductSizeInput = {
    create?: XOR<OrderItemCreateWithoutProductSizeInput, OrderItemUncheckedCreateWithoutProductSizeInput> | OrderItemCreateWithoutProductSizeInput[] | OrderItemUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductSizeInput | OrderItemCreateOrConnectWithoutProductSizeInput[]
    createMany?: OrderItemCreateManyProductSizeInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductInventoryUncheckedCreateNestedManyWithoutProductSizeInput = {
    create?: XOR<ProductInventoryCreateWithoutProductSizeInput, ProductInventoryUncheckedCreateWithoutProductSizeInput> | ProductInventoryCreateWithoutProductSizeInput[] | ProductInventoryUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: ProductInventoryCreateOrConnectWithoutProductSizeInput | ProductInventoryCreateOrConnectWithoutProductSizeInput[]
    createMany?: ProductInventoryCreateManyProductSizeInputEnvelope
    connect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
  }

  export type OrderItemUpdateManyWithoutProductSizeNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductSizeInput, OrderItemUncheckedCreateWithoutProductSizeInput> | OrderItemCreateWithoutProductSizeInput[] | OrderItemUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductSizeInput | OrderItemCreateOrConnectWithoutProductSizeInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductSizeInput | OrderItemUpsertWithWhereUniqueWithoutProductSizeInput[]
    createMany?: OrderItemCreateManyProductSizeInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductSizeInput | OrderItemUpdateWithWhereUniqueWithoutProductSizeInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductSizeInput | OrderItemUpdateManyWithWhereWithoutProductSizeInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductInventoryUpdateManyWithoutProductSizeNestedInput = {
    create?: XOR<ProductInventoryCreateWithoutProductSizeInput, ProductInventoryUncheckedCreateWithoutProductSizeInput> | ProductInventoryCreateWithoutProductSizeInput[] | ProductInventoryUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: ProductInventoryCreateOrConnectWithoutProductSizeInput | ProductInventoryCreateOrConnectWithoutProductSizeInput[]
    upsert?: ProductInventoryUpsertWithWhereUniqueWithoutProductSizeInput | ProductInventoryUpsertWithWhereUniqueWithoutProductSizeInput[]
    createMany?: ProductInventoryCreateManyProductSizeInputEnvelope
    set?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    disconnect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    delete?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    connect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    update?: ProductInventoryUpdateWithWhereUniqueWithoutProductSizeInput | ProductInventoryUpdateWithWhereUniqueWithoutProductSizeInput[]
    updateMany?: ProductInventoryUpdateManyWithWhereWithoutProductSizeInput | ProductInventoryUpdateManyWithWhereWithoutProductSizeInput[]
    deleteMany?: ProductInventoryScalarWhereInput | ProductInventoryScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductSizeNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductSizeInput, OrderItemUncheckedCreateWithoutProductSizeInput> | OrderItemCreateWithoutProductSizeInput[] | OrderItemUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductSizeInput | OrderItemCreateOrConnectWithoutProductSizeInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductSizeInput | OrderItemUpsertWithWhereUniqueWithoutProductSizeInput[]
    createMany?: OrderItemCreateManyProductSizeInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductSizeInput | OrderItemUpdateWithWhereUniqueWithoutProductSizeInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductSizeInput | OrderItemUpdateManyWithWhereWithoutProductSizeInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductInventoryUncheckedUpdateManyWithoutProductSizeNestedInput = {
    create?: XOR<ProductInventoryCreateWithoutProductSizeInput, ProductInventoryUncheckedCreateWithoutProductSizeInput> | ProductInventoryCreateWithoutProductSizeInput[] | ProductInventoryUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: ProductInventoryCreateOrConnectWithoutProductSizeInput | ProductInventoryCreateOrConnectWithoutProductSizeInput[]
    upsert?: ProductInventoryUpsertWithWhereUniqueWithoutProductSizeInput | ProductInventoryUpsertWithWhereUniqueWithoutProductSizeInput[]
    createMany?: ProductInventoryCreateManyProductSizeInputEnvelope
    set?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    disconnect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    delete?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    connect?: ProductInventoryWhereUniqueInput | ProductInventoryWhereUniqueInput[]
    update?: ProductInventoryUpdateWithWhereUniqueWithoutProductSizeInput | ProductInventoryUpdateWithWhereUniqueWithoutProductSizeInput[]
    updateMany?: ProductInventoryUpdateManyWithWhereWithoutProductSizeInput | ProductInventoryUpdateManyWithWhereWithoutProductSizeInput[]
    deleteMany?: ProductInventoryScalarWhereInput | ProductInventoryScalarWhereInput[]
  }

  export type ProductCategoryCreateNestedOneWithoutQuotesInput = {
    create?: XOR<ProductCategoryCreateWithoutQuotesInput, ProductCategoryUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutQuotesInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutQuotesInput, ProductCategoryUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutQuotesInput
    upsert?: ProductCategoryUpsertWithoutQuotesInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutQuotesInput, ProductCategoryUpdateWithoutQuotesInput>, ProductCategoryUncheckedUpdateWithoutQuotesInput>
  }

  export type OrderItemCreateNestedOneWithoutReturnRequestInput = {
    create?: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutReturnRequestInput
    connect?: OrderItemWhereUniqueInput
  }

  export type EnumReturnRequest_statusFieldUpdateOperationsInput = {
    set?: $Enums.ReturnRequest_status
  }

  export type OrderItemUpdateOneRequiredWithoutReturnRequestNestedInput = {
    create?: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutReturnRequestInput
    upsert?: OrderItemUpsertWithoutReturnRequestInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutReturnRequestInput, OrderItemUpdateWithoutReturnRequestInput>, OrderItemUncheckedUpdateWithoutReturnRequestInput>
  }

  export type UserCreateNestedOneWithoutRewardsInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardsInput
    upsert?: UserUpsertWithoutRewardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRewardsInput, UserUpdateWithoutRewardsInput>, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type UserCreateNestedOneWithoutSearchQueryInput = {
    create?: XOR<UserCreateWithoutSearchQueryInput, UserUncheckedCreateWithoutSearchQueryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchQueryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSearchQueryNestedInput = {
    create?: XOR<UserCreateWithoutSearchQueryInput, UserUncheckedCreateWithoutSearchQueryInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchQueryInput
    upsert?: UserUpsertWithoutSearchQueryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchQueryInput, UserUpdateWithoutSearchQueryInput>, UserUncheckedUpdateWithoutSearchQueryInput>
  }

  export type UserCreateNestedOneWithoutSessionInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    upsert?: UserUpsertWithoutSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionInput, UserUpdateWithoutSessionInput>, UserUncheckedUpdateWithoutSessionInput>
  }

  export type ShopByOccasionProductCreateNestedManyWithoutShopByOccasionInput = {
    create?: XOR<ShopByOccasionProductCreateWithoutShopByOccasionInput, ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput> | ShopByOccasionProductCreateWithoutShopByOccasionInput[] | ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput[]
    connectOrCreate?: ShopByOccasionProductCreateOrConnectWithoutShopByOccasionInput | ShopByOccasionProductCreateOrConnectWithoutShopByOccasionInput[]
    createMany?: ShopByOccasionProductCreateManyShopByOccasionInputEnvelope
    connect?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
  }

  export type ShopByOccasionProductUncheckedCreateNestedManyWithoutShopByOccasionInput = {
    create?: XOR<ShopByOccasionProductCreateWithoutShopByOccasionInput, ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput> | ShopByOccasionProductCreateWithoutShopByOccasionInput[] | ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput[]
    connectOrCreate?: ShopByOccasionProductCreateOrConnectWithoutShopByOccasionInput | ShopByOccasionProductCreateOrConnectWithoutShopByOccasionInput[]
    createMany?: ShopByOccasionProductCreateManyShopByOccasionInputEnvelope
    connect?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
  }

  export type ShopByOccasionProductUpdateManyWithoutShopByOccasionNestedInput = {
    create?: XOR<ShopByOccasionProductCreateWithoutShopByOccasionInput, ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput> | ShopByOccasionProductCreateWithoutShopByOccasionInput[] | ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput[]
    connectOrCreate?: ShopByOccasionProductCreateOrConnectWithoutShopByOccasionInput | ShopByOccasionProductCreateOrConnectWithoutShopByOccasionInput[]
    upsert?: ShopByOccasionProductUpsertWithWhereUniqueWithoutShopByOccasionInput | ShopByOccasionProductUpsertWithWhereUniqueWithoutShopByOccasionInput[]
    createMany?: ShopByOccasionProductCreateManyShopByOccasionInputEnvelope
    set?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
    disconnect?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
    delete?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
    connect?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
    update?: ShopByOccasionProductUpdateWithWhereUniqueWithoutShopByOccasionInput | ShopByOccasionProductUpdateWithWhereUniqueWithoutShopByOccasionInput[]
    updateMany?: ShopByOccasionProductUpdateManyWithWhereWithoutShopByOccasionInput | ShopByOccasionProductUpdateManyWithWhereWithoutShopByOccasionInput[]
    deleteMany?: ShopByOccasionProductScalarWhereInput | ShopByOccasionProductScalarWhereInput[]
  }

  export type ShopByOccasionProductUncheckedUpdateManyWithoutShopByOccasionNestedInput = {
    create?: XOR<ShopByOccasionProductCreateWithoutShopByOccasionInput, ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput> | ShopByOccasionProductCreateWithoutShopByOccasionInput[] | ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput[]
    connectOrCreate?: ShopByOccasionProductCreateOrConnectWithoutShopByOccasionInput | ShopByOccasionProductCreateOrConnectWithoutShopByOccasionInput[]
    upsert?: ShopByOccasionProductUpsertWithWhereUniqueWithoutShopByOccasionInput | ShopByOccasionProductUpsertWithWhereUniqueWithoutShopByOccasionInput[]
    createMany?: ShopByOccasionProductCreateManyShopByOccasionInputEnvelope
    set?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
    disconnect?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
    delete?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
    connect?: ShopByOccasionProductWhereUniqueInput | ShopByOccasionProductWhereUniqueInput[]
    update?: ShopByOccasionProductUpdateWithWhereUniqueWithoutShopByOccasionInput | ShopByOccasionProductUpdateWithWhereUniqueWithoutShopByOccasionInput[]
    updateMany?: ShopByOccasionProductUpdateManyWithWhereWithoutShopByOccasionInput | ShopByOccasionProductUpdateManyWithWhereWithoutShopByOccasionInput[]
    deleteMany?: ShopByOccasionProductScalarWhereInput | ShopByOccasionProductScalarWhereInput[]
  }

  export type ShopByOccasionCreateNestedOneWithoutShopByOccasionProductInput = {
    create?: XOR<ShopByOccasionCreateWithoutShopByOccasionProductInput, ShopByOccasionUncheckedCreateWithoutShopByOccasionProductInput>
    connectOrCreate?: ShopByOccasionCreateOrConnectWithoutShopByOccasionProductInput
    connect?: ShopByOccasionWhereUniqueInput
  }

  export type ShopByOccasionUpdateOneWithoutShopByOccasionProductNestedInput = {
    create?: XOR<ShopByOccasionCreateWithoutShopByOccasionProductInput, ShopByOccasionUncheckedCreateWithoutShopByOccasionProductInput>
    connectOrCreate?: ShopByOccasionCreateOrConnectWithoutShopByOccasionProductInput
    upsert?: ShopByOccasionUpsertWithoutShopByOccasionProductInput
    disconnect?: ShopByOccasionWhereInput | boolean
    delete?: ShopByOccasionWhereInput | boolean
    connect?: ShopByOccasionWhereUniqueInput
    update?: XOR<XOR<ShopByOccasionUpdateToOneWithWhereWithoutShopByOccasionProductInput, ShopByOccasionUpdateWithoutShopByOccasionProductInput>, ShopByOccasionUncheckedUpdateWithoutShopByOccasionProductInput>
  }

  export type ShopBySeasonProductCreateNestedManyWithoutShopBySeasonInput = {
    create?: XOR<ShopBySeasonProductCreateWithoutShopBySeasonInput, ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput> | ShopBySeasonProductCreateWithoutShopBySeasonInput[] | ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput[]
    connectOrCreate?: ShopBySeasonProductCreateOrConnectWithoutShopBySeasonInput | ShopBySeasonProductCreateOrConnectWithoutShopBySeasonInput[]
    createMany?: ShopBySeasonProductCreateManyShopBySeasonInputEnvelope
    connect?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
  }

  export type ShopBySeasonProductUncheckedCreateNestedManyWithoutShopBySeasonInput = {
    create?: XOR<ShopBySeasonProductCreateWithoutShopBySeasonInput, ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput> | ShopBySeasonProductCreateWithoutShopBySeasonInput[] | ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput[]
    connectOrCreate?: ShopBySeasonProductCreateOrConnectWithoutShopBySeasonInput | ShopBySeasonProductCreateOrConnectWithoutShopBySeasonInput[]
    createMany?: ShopBySeasonProductCreateManyShopBySeasonInputEnvelope
    connect?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
  }

  export type ShopBySeasonProductUpdateManyWithoutShopBySeasonNestedInput = {
    create?: XOR<ShopBySeasonProductCreateWithoutShopBySeasonInput, ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput> | ShopBySeasonProductCreateWithoutShopBySeasonInput[] | ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput[]
    connectOrCreate?: ShopBySeasonProductCreateOrConnectWithoutShopBySeasonInput | ShopBySeasonProductCreateOrConnectWithoutShopBySeasonInput[]
    upsert?: ShopBySeasonProductUpsertWithWhereUniqueWithoutShopBySeasonInput | ShopBySeasonProductUpsertWithWhereUniqueWithoutShopBySeasonInput[]
    createMany?: ShopBySeasonProductCreateManyShopBySeasonInputEnvelope
    set?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
    disconnect?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
    delete?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
    connect?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
    update?: ShopBySeasonProductUpdateWithWhereUniqueWithoutShopBySeasonInput | ShopBySeasonProductUpdateWithWhereUniqueWithoutShopBySeasonInput[]
    updateMany?: ShopBySeasonProductUpdateManyWithWhereWithoutShopBySeasonInput | ShopBySeasonProductUpdateManyWithWhereWithoutShopBySeasonInput[]
    deleteMany?: ShopBySeasonProductScalarWhereInput | ShopBySeasonProductScalarWhereInput[]
  }

  export type ShopBySeasonProductUncheckedUpdateManyWithoutShopBySeasonNestedInput = {
    create?: XOR<ShopBySeasonProductCreateWithoutShopBySeasonInput, ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput> | ShopBySeasonProductCreateWithoutShopBySeasonInput[] | ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput[]
    connectOrCreate?: ShopBySeasonProductCreateOrConnectWithoutShopBySeasonInput | ShopBySeasonProductCreateOrConnectWithoutShopBySeasonInput[]
    upsert?: ShopBySeasonProductUpsertWithWhereUniqueWithoutShopBySeasonInput | ShopBySeasonProductUpsertWithWhereUniqueWithoutShopBySeasonInput[]
    createMany?: ShopBySeasonProductCreateManyShopBySeasonInputEnvelope
    set?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
    disconnect?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
    delete?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
    connect?: ShopBySeasonProductWhereUniqueInput | ShopBySeasonProductWhereUniqueInput[]
    update?: ShopBySeasonProductUpdateWithWhereUniqueWithoutShopBySeasonInput | ShopBySeasonProductUpdateWithWhereUniqueWithoutShopBySeasonInput[]
    updateMany?: ShopBySeasonProductUpdateManyWithWhereWithoutShopBySeasonInput | ShopBySeasonProductUpdateManyWithWhereWithoutShopBySeasonInput[]
    deleteMany?: ShopBySeasonProductScalarWhereInput | ShopBySeasonProductScalarWhereInput[]
  }

  export type ShopBySeasonCreateNestedOneWithoutShopBySeasonProductInput = {
    create?: XOR<ShopBySeasonCreateWithoutShopBySeasonProductInput, ShopBySeasonUncheckedCreateWithoutShopBySeasonProductInput>
    connectOrCreate?: ShopBySeasonCreateOrConnectWithoutShopBySeasonProductInput
    connect?: ShopBySeasonWhereUniqueInput
  }

  export type ShopBySeasonUpdateOneRequiredWithoutShopBySeasonProductNestedInput = {
    create?: XOR<ShopBySeasonCreateWithoutShopBySeasonProductInput, ShopBySeasonUncheckedCreateWithoutShopBySeasonProductInput>
    connectOrCreate?: ShopBySeasonCreateOrConnectWithoutShopBySeasonProductInput
    upsert?: ShopBySeasonUpsertWithoutShopBySeasonProductInput
    connect?: ShopBySeasonWhereUniqueInput
    update?: XOR<XOR<ShopBySeasonUpdateToOneWithWhereWithoutShopBySeasonProductInput, ShopBySeasonUpdateWithoutShopBySeasonProductInput>, ShopBySeasonUncheckedUpdateWithoutShopBySeasonProductInput>
  }

  export type ProductCreateNestedManyWithoutSizeChartInput = {
    create?: XOR<ProductCreateWithoutSizeChartInput, ProductUncheckedCreateWithoutSizeChartInput> | ProductCreateWithoutSizeChartInput[] | ProductUncheckedCreateWithoutSizeChartInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSizeChartInput | ProductCreateOrConnectWithoutSizeChartInput[]
    createMany?: ProductCreateManySizeChartInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSizeChartInput = {
    create?: XOR<ProductCreateWithoutSizeChartInput, ProductUncheckedCreateWithoutSizeChartInput> | ProductCreateWithoutSizeChartInput[] | ProductUncheckedCreateWithoutSizeChartInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSizeChartInput | ProductCreateOrConnectWithoutSizeChartInput[]
    createMany?: ProductCreateManySizeChartInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutSizeChartNestedInput = {
    create?: XOR<ProductCreateWithoutSizeChartInput, ProductUncheckedCreateWithoutSizeChartInput> | ProductCreateWithoutSizeChartInput[] | ProductUncheckedCreateWithoutSizeChartInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSizeChartInput | ProductCreateOrConnectWithoutSizeChartInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSizeChartInput | ProductUpsertWithWhereUniqueWithoutSizeChartInput[]
    createMany?: ProductCreateManySizeChartInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSizeChartInput | ProductUpdateWithWhereUniqueWithoutSizeChartInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSizeChartInput | ProductUpdateManyWithWhereWithoutSizeChartInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSizeChartNestedInput = {
    create?: XOR<ProductCreateWithoutSizeChartInput, ProductUncheckedCreateWithoutSizeChartInput> | ProductCreateWithoutSizeChartInput[] | ProductUncheckedCreateWithoutSizeChartInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSizeChartInput | ProductCreateOrConnectWithoutSizeChartInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSizeChartInput | ProductUpsertWithWhereUniqueWithoutSizeChartInput[]
    createMany?: ProductCreateManySizeChartInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSizeChartInput | ProductUpdateWithWhereUniqueWithoutSizeChartInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSizeChartInput | ProductUpdateManyWithWhereWithoutSizeChartInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStaticMessagesInput = {
    create?: XOR<UserCreateWithoutStaticMessagesInput, UserUncheckedCreateWithoutStaticMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaticMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStaticMessages_statusFieldUpdateOperationsInput = {
    set?: $Enums.StaticMessages_status
  }

  export type UserUpdateOneRequiredWithoutStaticMessagesNestedInput = {
    create?: XOR<UserCreateWithoutStaticMessagesInput, UserUncheckedCreateWithoutStaticMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaticMessagesInput
    upsert?: UserUpsertWithoutStaticMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaticMessagesInput, UserUpdateWithoutStaticMessagesInput>, UserUncheckedUpdateWithoutStaticMessagesInput>
  }

  export type ProductCategoryCreateNestedOneWithoutSubCategoryInput = {
    create?: XOR<ProductCategoryCreateWithoutSubCategoryInput, ProductCategoryUncheckedCreateWithoutSubCategoryInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSubCategoryInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryUpdateOneRequiredWithoutSubCategoryNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutSubCategoryInput, ProductCategoryUncheckedCreateWithoutSubCategoryInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutSubCategoryInput
    upsert?: ProductCategoryUpsertWithoutSubCategoryInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutSubCategoryInput, ProductCategoryUpdateWithoutSubCategoryInput>, ProductCategoryUncheckedUpdateWithoutSubCategoryInput>
  }

  export type ProductUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubCategoryInput | ProductUpsertWithWhereUniqueWithoutSubCategoryInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubCategoryInput | ProductUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubCategoryInput | ProductUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput> | ProductCreateWithoutSubCategoryInput[] | ProductUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSubCategoryInput | ProductCreateOrConnectWithoutSubCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSubCategoryInput | ProductUpsertWithWhereUniqueWithoutSubCategoryInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSubCategoryInput | ProductUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSubCategoryInput | ProductUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSupportTicketInput = {
    create?: XOR<UserCreateWithoutSupportTicketInput, UserUncheckedCreateWithoutSupportTicketInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSupportTicket_statusFieldUpdateOperationsInput = {
    set?: $Enums.SupportTicket_status
  }

  export type UserUpdateOneRequiredWithoutSupportTicketNestedInput = {
    create?: XOR<UserCreateWithoutSupportTicketInput, UserUncheckedCreateWithoutSupportTicketInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketInput
    upsert?: UserUpsertWithoutSupportTicketInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportTicketInput, UserUpdateWithoutSupportTicketInput>, UserUncheckedUpdateWithoutSupportTicketInput>
  }

  export type UserCreateNestedOneWithoutUpdateHistoryInput = {
    create?: XOR<UserCreateWithoutUpdateHistoryInput, UserUncheckedCreateWithoutUpdateHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdateHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUpdateHistoryNestedInput = {
    create?: XOR<UserCreateWithoutUpdateHistoryInput, UserUncheckedCreateWithoutUpdateHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdateHistoryInput
    upsert?: UserUpsertWithoutUpdateHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdateHistoryInput, UserUpdateWithoutUpdateHistoryInput>, UserUncheckedUpdateWithoutUpdateHistoryInput>
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutUserInput = {
    create?: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput> | CartItemCreateWithoutUserInput[] | CartItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUserInput | CartItemCreateOrConnectWithoutUserInput[]
    createMany?: CartItemCreateManyUserInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type DeleteRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<DeleteRequestCreateWithoutUserInput, DeleteRequestUncheckedCreateWithoutUserInput> | DeleteRequestCreateWithoutUserInput[] | DeleteRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeleteRequestCreateOrConnectWithoutUserInput | DeleteRequestCreateOrConnectWithoutUserInput[]
    createMany?: DeleteRequestCreateManyUserInputEnvelope
    connect?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
  }

  export type DropMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<DropMessageCreateWithoutUserInput, DropMessageUncheckedCreateWithoutUserInput> | DropMessageCreateWithoutUserInput[] | DropMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DropMessageCreateOrConnectWithoutUserInput | DropMessageCreateOrConnectWithoutUserInput[]
    createMany?: DropMessageCreateManyUserInputEnvelope
    connect?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_handledByIdToUserInput, MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput> | MessageCreateWithoutUser_Message_handledByIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_handledByIdToUserInput | MessageCreateOrConnectWithoutUser_Message_handledByIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_handledByIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput> | MessageCreateWithoutUser_Message_receiverIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput | MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_receiverIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput> | MessageCreateWithoutUser_Message_senderIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput | MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_senderIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrderDetailsCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput> | OrderDetailsCreateWithoutUserInput[] | OrderDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserInput | OrderDetailsCreateOrConnectWithoutUserInput[]
    createMany?: OrderDetailsCreateManyUserInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type OtpCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput> | ProductReviewCreateWithoutUserInput[] | ProductReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutUserInput | ProductReviewCreateOrConnectWithoutUserInput[]
    createMany?: ProductReviewCreateManyUserInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type RewardsCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardsCreateWithoutUserInput, RewardsUncheckedCreateWithoutUserInput> | RewardsCreateWithoutUserInput[] | RewardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardsCreateOrConnectWithoutUserInput | RewardsCreateOrConnectWithoutUserInput[]
    createMany?: RewardsCreateManyUserInputEnvelope
    connect?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
  }

  export type SearchQueryCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StaticMessagesCreateNestedManyWithoutUserInput = {
    create?: XOR<StaticMessagesCreateWithoutUserInput, StaticMessagesUncheckedCreateWithoutUserInput> | StaticMessagesCreateWithoutUserInput[] | StaticMessagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaticMessagesCreateOrConnectWithoutUserInput | StaticMessagesCreateOrConnectWithoutUserInput[]
    createMany?: StaticMessagesCreateManyUserInputEnvelope
    connect?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type UpdateHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UpdateHistoryCreateWithoutUserInput, UpdateHistoryUncheckedCreateWithoutUserInput> | UpdateHistoryCreateWithoutUserInput[] | UpdateHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UpdateHistoryCreateOrConnectWithoutUserInput | UpdateHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UpdateHistoryCreateManyUserInputEnvelope
    connect?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOther_UserInput = {
    create?: XOR<UserCreateWithoutOther_UserInput, UserUncheckedCreateWithoutOther_UserInput>
    connectOrCreate?: UserCreateOrConnectWithoutOther_UserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput> | UserCreateWithoutUserInput[] | UserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserInput | UserCreateOrConnectWithoutUserInput[]
    createMany?: UserCreateManyUserInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserAddressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type UserPrivilegeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPrivilegeCreateWithoutUserInput, UserPrivilegeUncheckedCreateWithoutUserInput> | UserPrivilegeCreateWithoutUserInput[] | UserPrivilegeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPrivilegeCreateOrConnectWithoutUserInput | UserPrivilegeCreateOrConnectWithoutUserInput[]
    createMany?: UserPrivilegeCreateManyUserInputEnvelope
    connect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
  }

  export type WishlistItemCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput> | CartItemCreateWithoutUserInput[] | CartItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUserInput | CartItemCreateOrConnectWithoutUserInput[]
    createMany?: CartItemCreateManyUserInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type DeleteRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeleteRequestCreateWithoutUserInput, DeleteRequestUncheckedCreateWithoutUserInput> | DeleteRequestCreateWithoutUserInput[] | DeleteRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeleteRequestCreateOrConnectWithoutUserInput | DeleteRequestCreateOrConnectWithoutUserInput[]
    createMany?: DeleteRequestCreateManyUserInputEnvelope
    connect?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
  }

  export type DropMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DropMessageCreateWithoutUserInput, DropMessageUncheckedCreateWithoutUserInput> | DropMessageCreateWithoutUserInput[] | DropMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DropMessageCreateOrConnectWithoutUserInput | DropMessageCreateOrConnectWithoutUserInput[]
    createMany?: DropMessageCreateManyUserInputEnvelope
    connect?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_handledByIdToUserInput, MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput> | MessageCreateWithoutUser_Message_handledByIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_handledByIdToUserInput | MessageCreateOrConnectWithoutUser_Message_handledByIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_handledByIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput> | MessageCreateWithoutUser_Message_receiverIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput | MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_receiverIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput = {
    create?: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput> | MessageCreateWithoutUser_Message_senderIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput | MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_senderIdToUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OrderDetailsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput> | OrderDetailsCreateWithoutUserInput[] | OrderDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserInput | OrderDetailsCreateOrConnectWithoutUserInput[]
    createMany?: OrderDetailsCreateManyUserInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type OtpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput> | ProductReviewCreateWithoutUserInput[] | ProductReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutUserInput | ProductReviewCreateOrConnectWithoutUserInput[]
    createMany?: ProductReviewCreateManyUserInputEnvelope
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
  }

  export type RewardsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardsCreateWithoutUserInput, RewardsUncheckedCreateWithoutUserInput> | RewardsCreateWithoutUserInput[] | RewardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardsCreateOrConnectWithoutUserInput | RewardsCreateOrConnectWithoutUserInput[]
    createMany?: RewardsCreateManyUserInputEnvelope
    connect?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
  }

  export type SearchQueryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StaticMessagesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StaticMessagesCreateWithoutUserInput, StaticMessagesUncheckedCreateWithoutUserInput> | StaticMessagesCreateWithoutUserInput[] | StaticMessagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaticMessagesCreateOrConnectWithoutUserInput | StaticMessagesCreateOrConnectWithoutUserInput[]
    createMany?: StaticMessagesCreateManyUserInputEnvelope
    connect?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type UpdateHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UpdateHistoryCreateWithoutUserInput, UpdateHistoryUncheckedCreateWithoutUserInput> | UpdateHistoryCreateWithoutUserInput[] | UpdateHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UpdateHistoryCreateOrConnectWithoutUserInput | UpdateHistoryCreateOrConnectWithoutUserInput[]
    createMany?: UpdateHistoryCreateManyUserInputEnvelope
    connect?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput> | UserCreateWithoutUserInput[] | UserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserInput | UserCreateOrConnectWithoutUserInput[]
    createMany?: UserCreateManyUserInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserAddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
  }

  export type UserPrivilegeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPrivilegeCreateWithoutUserInput, UserPrivilegeUncheckedCreateWithoutUserInput> | UserPrivilegeCreateWithoutUserInput[] | UserPrivilegeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPrivilegeCreateOrConnectWithoutUserInput | UserPrivilegeCreateOrConnectWithoutUserInput[]
    createMany?: UserPrivilegeCreateManyUserInputEnvelope
    connect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
  }

  export type EnumUser_roleFieldUpdateOperationsInput = {
    set?: $Enums.User_role
  }

  export type EnumUser_statusFieldUpdateOperationsInput = {
    set?: $Enums.User_status
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput> | CartItemCreateWithoutUserInput[] | CartItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUserInput | CartItemCreateOrConnectWithoutUserInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutUserInput | CartItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartItemCreateManyUserInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutUserInput | CartItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutUserInput | CartItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type DeleteRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeleteRequestCreateWithoutUserInput, DeleteRequestUncheckedCreateWithoutUserInput> | DeleteRequestCreateWithoutUserInput[] | DeleteRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeleteRequestCreateOrConnectWithoutUserInput | DeleteRequestCreateOrConnectWithoutUserInput[]
    upsert?: DeleteRequestUpsertWithWhereUniqueWithoutUserInput | DeleteRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeleteRequestCreateManyUserInputEnvelope
    set?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
    disconnect?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
    delete?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
    connect?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
    update?: DeleteRequestUpdateWithWhereUniqueWithoutUserInput | DeleteRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeleteRequestUpdateManyWithWhereWithoutUserInput | DeleteRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeleteRequestScalarWhereInput | DeleteRequestScalarWhereInput[]
  }

  export type DropMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<DropMessageCreateWithoutUserInput, DropMessageUncheckedCreateWithoutUserInput> | DropMessageCreateWithoutUserInput[] | DropMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DropMessageCreateOrConnectWithoutUserInput | DropMessageCreateOrConnectWithoutUserInput[]
    upsert?: DropMessageUpsertWithWhereUniqueWithoutUserInput | DropMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DropMessageCreateManyUserInputEnvelope
    set?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
    disconnect?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
    delete?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
    connect?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
    update?: DropMessageUpdateWithWhereUniqueWithoutUserInput | DropMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DropMessageUpdateManyWithWhereWithoutUserInput | DropMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DropMessageScalarWhereInput | DropMessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_handledByIdToUserInput, MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput> | MessageCreateWithoutUser_Message_handledByIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_handledByIdToUserInput | MessageCreateOrConnectWithoutUser_Message_handledByIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_handledByIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_handledByIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_handledByIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_handledByIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_handledByIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_handledByIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_handledByIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput> | MessageCreateWithoutUser_Message_receiverIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput | MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_receiverIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput> | MessageCreateWithoutUser_Message_senderIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput | MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_senderIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrderDetailsUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput> | OrderDetailsCreateWithoutUserInput[] | OrderDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserInput | OrderDetailsCreateOrConnectWithoutUserInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutUserInput | OrderDetailsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderDetailsCreateManyUserInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutUserInput | OrderDetailsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutUserInput | OrderDetailsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type OtpUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    upsert?: OtpUpsertWithWhereUniqueWithoutUserInput | OtpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    set?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    disconnect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    delete?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    update?: OtpUpdateWithWhereUniqueWithoutUserInput | OtpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpUpdateManyWithWhereWithoutUserInput | OtpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpScalarWhereInput | OtpScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUserInput | ProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUserInput | ProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUserInput | ProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput> | ProductReviewCreateWithoutUserInput[] | ProductReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutUserInput | ProductReviewCreateOrConnectWithoutUserInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutUserInput | ProductReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductReviewCreateManyUserInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutUserInput | ProductReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutUserInput | ProductReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type RewardsUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardsCreateWithoutUserInput, RewardsUncheckedCreateWithoutUserInput> | RewardsCreateWithoutUserInput[] | RewardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardsCreateOrConnectWithoutUserInput | RewardsCreateOrConnectWithoutUserInput[]
    upsert?: RewardsUpsertWithWhereUniqueWithoutUserInput | RewardsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardsCreateManyUserInputEnvelope
    set?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
    disconnect?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
    delete?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
    connect?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
    update?: RewardsUpdateWithWhereUniqueWithoutUserInput | RewardsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardsUpdateManyWithWhereWithoutUserInput | RewardsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardsScalarWhereInput | RewardsScalarWhereInput[]
  }

  export type SearchQueryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    upsert?: SearchQueryUpsertWithWhereUniqueWithoutUserInput | SearchQueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    set?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    disconnect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    delete?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    update?: SearchQueryUpdateWithWhereUniqueWithoutUserInput | SearchQueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchQueryUpdateManyWithWhereWithoutUserInput | SearchQueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type StaticMessagesUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaticMessagesCreateWithoutUserInput, StaticMessagesUncheckedCreateWithoutUserInput> | StaticMessagesCreateWithoutUserInput[] | StaticMessagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaticMessagesCreateOrConnectWithoutUserInput | StaticMessagesCreateOrConnectWithoutUserInput[]
    upsert?: StaticMessagesUpsertWithWhereUniqueWithoutUserInput | StaticMessagesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaticMessagesCreateManyUserInputEnvelope
    set?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
    disconnect?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
    delete?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
    connect?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
    update?: StaticMessagesUpdateWithWhereUniqueWithoutUserInput | StaticMessagesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaticMessagesUpdateManyWithWhereWithoutUserInput | StaticMessagesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaticMessagesScalarWhereInput | StaticMessagesScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UpdateHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UpdateHistoryCreateWithoutUserInput, UpdateHistoryUncheckedCreateWithoutUserInput> | UpdateHistoryCreateWithoutUserInput[] | UpdateHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UpdateHistoryCreateOrConnectWithoutUserInput | UpdateHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UpdateHistoryUpsertWithWhereUniqueWithoutUserInput | UpdateHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UpdateHistoryCreateManyUserInputEnvelope
    set?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
    disconnect?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
    delete?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
    connect?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
    update?: UpdateHistoryUpdateWithWhereUniqueWithoutUserInput | UpdateHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UpdateHistoryUpdateManyWithWhereWithoutUserInput | UpdateHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UpdateHistoryScalarWhereInput | UpdateHistoryScalarWhereInput[]
  }

  export type UserUpdateOneWithoutOther_UserNestedInput = {
    create?: XOR<UserCreateWithoutOther_UserInput, UserUncheckedCreateWithoutOther_UserInput>
    connectOrCreate?: UserCreateOrConnectWithoutOther_UserInput
    upsert?: UserUpsertWithoutOther_UserInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOther_UserInput, UserUpdateWithoutOther_UserInput>, UserUncheckedUpdateWithoutOther_UserInput>
  }

  export type UserUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput> | UserCreateWithoutUserInput[] | UserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserInput | UserCreateOrConnectWithoutUserInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUserInput | UserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCreateManyUserInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUserInput | UserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUserInput | UserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserAddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutUserInput | UserAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutUserInput | UserAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutUserInput | UserAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type UserPrivilegeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPrivilegeCreateWithoutUserInput, UserPrivilegeUncheckedCreateWithoutUserInput> | UserPrivilegeCreateWithoutUserInput[] | UserPrivilegeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPrivilegeCreateOrConnectWithoutUserInput | UserPrivilegeCreateOrConnectWithoutUserInput[]
    upsert?: UserPrivilegeUpsertWithWhereUniqueWithoutUserInput | UserPrivilegeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPrivilegeCreateManyUserInputEnvelope
    set?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    disconnect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    delete?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    connect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    update?: UserPrivilegeUpdateWithWhereUniqueWithoutUserInput | UserPrivilegeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPrivilegeUpdateManyWithWhereWithoutUserInput | UserPrivilegeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPrivilegeScalarWhereInput | UserPrivilegeScalarWhereInput[]
  }

  export type WishlistItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutUserInput | WishlistItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutUserInput | WishlistItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutUserInput | WishlistItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput> | CartItemCreateWithoutUserInput[] | CartItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUserInput | CartItemCreateOrConnectWithoutUserInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutUserInput | CartItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartItemCreateManyUserInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutUserInput | CartItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutUserInput | CartItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type DeleteRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeleteRequestCreateWithoutUserInput, DeleteRequestUncheckedCreateWithoutUserInput> | DeleteRequestCreateWithoutUserInput[] | DeleteRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeleteRequestCreateOrConnectWithoutUserInput | DeleteRequestCreateOrConnectWithoutUserInput[]
    upsert?: DeleteRequestUpsertWithWhereUniqueWithoutUserInput | DeleteRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeleteRequestCreateManyUserInputEnvelope
    set?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
    disconnect?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
    delete?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
    connect?: DeleteRequestWhereUniqueInput | DeleteRequestWhereUniqueInput[]
    update?: DeleteRequestUpdateWithWhereUniqueWithoutUserInput | DeleteRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeleteRequestUpdateManyWithWhereWithoutUserInput | DeleteRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeleteRequestScalarWhereInput | DeleteRequestScalarWhereInput[]
  }

  export type DropMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DropMessageCreateWithoutUserInput, DropMessageUncheckedCreateWithoutUserInput> | DropMessageCreateWithoutUserInput[] | DropMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DropMessageCreateOrConnectWithoutUserInput | DropMessageCreateOrConnectWithoutUserInput[]
    upsert?: DropMessageUpsertWithWhereUniqueWithoutUserInput | DropMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DropMessageCreateManyUserInputEnvelope
    set?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
    disconnect?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
    delete?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
    connect?: DropMessageWhereUniqueInput | DropMessageWhereUniqueInput[]
    update?: DropMessageUpdateWithWhereUniqueWithoutUserInput | DropMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DropMessageUpdateManyWithWhereWithoutUserInput | DropMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DropMessageScalarWhereInput | DropMessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_handledByIdToUserInput, MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput> | MessageCreateWithoutUser_Message_handledByIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_handledByIdToUserInput | MessageCreateOrConnectWithoutUser_Message_handledByIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_handledByIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_handledByIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_handledByIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_handledByIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_handledByIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_handledByIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_handledByIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput> | MessageCreateWithoutUser_Message_receiverIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput | MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_receiverIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput = {
    create?: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput> | MessageCreateWithoutUser_Message_senderIdToUserInput[] | MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput | MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput | MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput[]
    createMany?: MessageCreateManyUser_Message_senderIdToUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput | MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput | MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OrderDetailsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput> | OrderDetailsCreateWithoutUserInput[] | OrderDetailsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserInput | OrderDetailsCreateOrConnectWithoutUserInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutUserInput | OrderDetailsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderDetailsCreateManyUserInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutUserInput | OrderDetailsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutUserInput | OrderDetailsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type OtpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput> | OtpCreateWithoutUserInput[] | OtpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput | OtpCreateOrConnectWithoutUserInput[]
    upsert?: OtpUpsertWithWhereUniqueWithoutUserInput | OtpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OtpCreateManyUserInputEnvelope
    set?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    disconnect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    delete?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    connect?: OtpWhereUniqueInput | OtpWhereUniqueInput[]
    update?: OtpUpdateWithWhereUniqueWithoutUserInput | OtpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OtpUpdateManyWithWhereWithoutUserInput | OtpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OtpScalarWhereInput | OtpScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUserInput | ProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUserInput | ProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUserInput | ProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput> | ProductReviewCreateWithoutUserInput[] | ProductReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductReviewCreateOrConnectWithoutUserInput | ProductReviewCreateOrConnectWithoutUserInput[]
    upsert?: ProductReviewUpsertWithWhereUniqueWithoutUserInput | ProductReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductReviewCreateManyUserInputEnvelope
    set?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    disconnect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    delete?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    connect?: ProductReviewWhereUniqueInput | ProductReviewWhereUniqueInput[]
    update?: ProductReviewUpdateWithWhereUniqueWithoutUserInput | ProductReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductReviewUpdateManyWithWhereWithoutUserInput | ProductReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
  }

  export type RewardsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardsCreateWithoutUserInput, RewardsUncheckedCreateWithoutUserInput> | RewardsCreateWithoutUserInput[] | RewardsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardsCreateOrConnectWithoutUserInput | RewardsCreateOrConnectWithoutUserInput[]
    upsert?: RewardsUpsertWithWhereUniqueWithoutUserInput | RewardsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardsCreateManyUserInputEnvelope
    set?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
    disconnect?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
    delete?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
    connect?: RewardsWhereUniqueInput | RewardsWhereUniqueInput[]
    update?: RewardsUpdateWithWhereUniqueWithoutUserInput | RewardsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardsUpdateManyWithWhereWithoutUserInput | RewardsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardsScalarWhereInput | RewardsScalarWhereInput[]
  }

  export type SearchQueryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput> | SearchQueryCreateWithoutUserInput[] | SearchQueryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchQueryCreateOrConnectWithoutUserInput | SearchQueryCreateOrConnectWithoutUserInput[]
    upsert?: SearchQueryUpsertWithWhereUniqueWithoutUserInput | SearchQueryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchQueryCreateManyUserInputEnvelope
    set?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    disconnect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    delete?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    connect?: SearchQueryWhereUniqueInput | SearchQueryWhereUniqueInput[]
    update?: SearchQueryUpdateWithWhereUniqueWithoutUserInput | SearchQueryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchQueryUpdateManyWithWhereWithoutUserInput | SearchQueryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type StaticMessagesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StaticMessagesCreateWithoutUserInput, StaticMessagesUncheckedCreateWithoutUserInput> | StaticMessagesCreateWithoutUserInput[] | StaticMessagesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StaticMessagesCreateOrConnectWithoutUserInput | StaticMessagesCreateOrConnectWithoutUserInput[]
    upsert?: StaticMessagesUpsertWithWhereUniqueWithoutUserInput | StaticMessagesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StaticMessagesCreateManyUserInputEnvelope
    set?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
    disconnect?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
    delete?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
    connect?: StaticMessagesWhereUniqueInput | StaticMessagesWhereUniqueInput[]
    update?: StaticMessagesUpdateWithWhereUniqueWithoutUserInput | StaticMessagesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StaticMessagesUpdateManyWithWhereWithoutUserInput | StaticMessagesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StaticMessagesScalarWhereInput | StaticMessagesScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UpdateHistoryCreateWithoutUserInput, UpdateHistoryUncheckedCreateWithoutUserInput> | UpdateHistoryCreateWithoutUserInput[] | UpdateHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UpdateHistoryCreateOrConnectWithoutUserInput | UpdateHistoryCreateOrConnectWithoutUserInput[]
    upsert?: UpdateHistoryUpsertWithWhereUniqueWithoutUserInput | UpdateHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UpdateHistoryCreateManyUserInputEnvelope
    set?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
    disconnect?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
    delete?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
    connect?: UpdateHistoryWhereUniqueInput | UpdateHistoryWhereUniqueInput[]
    update?: UpdateHistoryUpdateWithWhereUniqueWithoutUserInput | UpdateHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UpdateHistoryUpdateManyWithWhereWithoutUserInput | UpdateHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UpdateHistoryScalarWhereInput | UpdateHistoryScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput> | UserCreateWithoutUserInput[] | UserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCreateOrConnectWithoutUserInput | UserCreateOrConnectWithoutUserInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutUserInput | UserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCreateManyUserInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutUserInput | UserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserUpdateManyWithWhereWithoutUserInput | UserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserAddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput> | UserAddressCreateWithoutUserInput[] | UserAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput | UserAddressCreateOrConnectWithoutUserInput[]
    upsert?: UserAddressUpsertWithWhereUniqueWithoutUserInput | UserAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    disconnect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    delete?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    connect?: UserAddressWhereUniqueInput | UserAddressWhereUniqueInput[]
    update?: UserAddressUpdateWithWhereUniqueWithoutUserInput | UserAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAddressUpdateManyWithWhereWithoutUserInput | UserAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
  }

  export type UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPrivilegeCreateWithoutUserInput, UserPrivilegeUncheckedCreateWithoutUserInput> | UserPrivilegeCreateWithoutUserInput[] | UserPrivilegeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPrivilegeCreateOrConnectWithoutUserInput | UserPrivilegeCreateOrConnectWithoutUserInput[]
    upsert?: UserPrivilegeUpsertWithWhereUniqueWithoutUserInput | UserPrivilegeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPrivilegeCreateManyUserInputEnvelope
    set?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    disconnect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    delete?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    connect?: UserPrivilegeWhereUniqueInput | UserPrivilegeWhereUniqueInput[]
    update?: UserPrivilegeUpdateWithWhereUniqueWithoutUserInput | UserPrivilegeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPrivilegeUpdateManyWithWhereWithoutUserInput | UserPrivilegeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPrivilegeScalarWhereInput | UserPrivilegeScalarWhereInput[]
  }

  export type WishlistItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput> | WishlistItemCreateWithoutUserInput[] | WishlistItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WishlistItemCreateOrConnectWithoutUserInput | WishlistItemCreateOrConnectWithoutUserInput[]
    upsert?: WishlistItemUpsertWithWhereUniqueWithoutUserInput | WishlistItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WishlistItemCreateManyUserInputEnvelope
    set?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    disconnect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    delete?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    connect?: WishlistItemWhereUniqueInput | WishlistItemWhereUniqueInput[]
    update?: WishlistItemUpdateWithWhereUniqueWithoutUserInput | WishlistItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WishlistItemUpdateManyWithWhereWithoutUserInput | WishlistItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
  }

  export type OrderDetailsCreateNestedManyWithoutUserAddressInput = {
    create?: XOR<OrderDetailsCreateWithoutUserAddressInput, OrderDetailsUncheckedCreateWithoutUserAddressInput> | OrderDetailsCreateWithoutUserAddressInput[] | OrderDetailsUncheckedCreateWithoutUserAddressInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserAddressInput | OrderDetailsCreateOrConnectWithoutUserAddressInput[]
    createMany?: OrderDetailsCreateManyUserAddressInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutUserAddressInput = {
    create?: XOR<UserCreateWithoutUserAddressInput, UserUncheckedCreateWithoutUserAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAddressInput
    connect?: UserWhereUniqueInput
  }

  export type OrderDetailsUncheckedCreateNestedManyWithoutUserAddressInput = {
    create?: XOR<OrderDetailsCreateWithoutUserAddressInput, OrderDetailsUncheckedCreateWithoutUserAddressInput> | OrderDetailsCreateWithoutUserAddressInput[] | OrderDetailsUncheckedCreateWithoutUserAddressInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserAddressInput | OrderDetailsCreateOrConnectWithoutUserAddressInput[]
    createMany?: OrderDetailsCreateManyUserAddressInputEnvelope
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
  }

  export type OrderDetailsUpdateManyWithoutUserAddressNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutUserAddressInput, OrderDetailsUncheckedCreateWithoutUserAddressInput> | OrderDetailsCreateWithoutUserAddressInput[] | OrderDetailsUncheckedCreateWithoutUserAddressInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserAddressInput | OrderDetailsCreateOrConnectWithoutUserAddressInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutUserAddressInput | OrderDetailsUpsertWithWhereUniqueWithoutUserAddressInput[]
    createMany?: OrderDetailsCreateManyUserAddressInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutUserAddressInput | OrderDetailsUpdateWithWhereUniqueWithoutUserAddressInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutUserAddressInput | OrderDetailsUpdateManyWithWhereWithoutUserAddressInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutUserAddressNestedInput = {
    create?: XOR<UserCreateWithoutUserAddressInput, UserUncheckedCreateWithoutUserAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAddressInput
    upsert?: UserUpsertWithoutUserAddressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserAddressInput, UserUpdateWithoutUserAddressInput>, UserUncheckedUpdateWithoutUserAddressInput>
  }

  export type OrderDetailsUncheckedUpdateManyWithoutUserAddressNestedInput = {
    create?: XOR<OrderDetailsCreateWithoutUserAddressInput, OrderDetailsUncheckedCreateWithoutUserAddressInput> | OrderDetailsCreateWithoutUserAddressInput[] | OrderDetailsUncheckedCreateWithoutUserAddressInput[]
    connectOrCreate?: OrderDetailsCreateOrConnectWithoutUserAddressInput | OrderDetailsCreateOrConnectWithoutUserAddressInput[]
    upsert?: OrderDetailsUpsertWithWhereUniqueWithoutUserAddressInput | OrderDetailsUpsertWithWhereUniqueWithoutUserAddressInput[]
    createMany?: OrderDetailsCreateManyUserAddressInputEnvelope
    set?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    disconnect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    delete?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    connect?: OrderDetailsWhereUniqueInput | OrderDetailsWhereUniqueInput[]
    update?: OrderDetailsUpdateWithWhereUniqueWithoutUserAddressInput | OrderDetailsUpdateWithWhereUniqueWithoutUserAddressInput[]
    updateMany?: OrderDetailsUpdateManyWithWhereWithoutUserAddressInput | OrderDetailsUpdateManyWithWhereWithoutUserAddressInput[]
    deleteMany?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
  }

  export type PrivilegeCreateNestedOneWithoutUserPrivilegeInput = {
    create?: XOR<PrivilegeCreateWithoutUserPrivilegeInput, PrivilegeUncheckedCreateWithoutUserPrivilegeInput>
    connectOrCreate?: PrivilegeCreateOrConnectWithoutUserPrivilegeInput
    connect?: PrivilegeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserPrivilegeInput = {
    create?: XOR<UserCreateWithoutUserPrivilegeInput, UserUncheckedCreateWithoutUserPrivilegeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPrivilegeInput
    connect?: UserWhereUniqueInput
  }

  export type PrivilegeUpdateOneRequiredWithoutUserPrivilegeNestedInput = {
    create?: XOR<PrivilegeCreateWithoutUserPrivilegeInput, PrivilegeUncheckedCreateWithoutUserPrivilegeInput>
    connectOrCreate?: PrivilegeCreateOrConnectWithoutUserPrivilegeInput
    upsert?: PrivilegeUpsertWithoutUserPrivilegeInput
    connect?: PrivilegeWhereUniqueInput
    update?: XOR<XOR<PrivilegeUpdateToOneWithWhereWithoutUserPrivilegeInput, PrivilegeUpdateWithoutUserPrivilegeInput>, PrivilegeUncheckedUpdateWithoutUserPrivilegeInput>
  }

  export type UserUpdateOneRequiredWithoutUserPrivilegeNestedInput = {
    create?: XOR<UserCreateWithoutUserPrivilegeInput, UserUncheckedCreateWithoutUserPrivilegeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPrivilegeInput
    upsert?: UserUpsertWithoutUserPrivilegeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPrivilegeInput, UserUpdateWithoutUserPrivilegeInput>, UserUncheckedUpdateWithoutUserPrivilegeInput>
  }

  export type ProductCreateNestedOneWithoutWishlistItemInput = {
    create?: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWishlistItemInput = {
    create?: XOR<UserCreateWithoutWishlistItemInput, UserUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistItemInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutWishlistItemNestedInput = {
    create?: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemInput
    upsert?: ProductUpsertWithoutWishlistItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutWishlistItemInput, ProductUpdateWithoutWishlistItemInput>, ProductUncheckedUpdateWithoutWishlistItemInput>
  }

  export type UserUpdateOneRequiredWithoutWishlistItemNestedInput = {
    create?: XOR<UserCreateWithoutWishlistItemInput, UserUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistItemInput
    upsert?: UserUpsertWithoutWishlistItemInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWishlistItemInput, UserUpdateWithoutWishlistItemInput>, UserUncheckedUpdateWithoutWishlistItemInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumDeleteRequest_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeleteRequest_status | EnumDeleteRequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.DeleteRequest_status[]
    notIn?: $Enums.DeleteRequest_status[]
    not?: NestedEnumDeleteRequest_statusFilter<$PrismaModel> | $Enums.DeleteRequest_status
  }

  export type NestedEnumDeleteRequest_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeleteRequest_status | EnumDeleteRequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.DeleteRequest_status[]
    notIn?: $Enums.DeleteRequest_status[]
    not?: NestedEnumDeleteRequest_statusWithAggregatesFilter<$PrismaModel> | $Enums.DeleteRequest_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeleteRequest_statusFilter<$PrismaModel>
    _max?: NestedEnumDeleteRequest_statusFilter<$PrismaModel>
  }

  export type NestedEnumDiscount_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.Discount_type | EnumDiscount_typeFieldRefInput<$PrismaModel>
    in?: $Enums.Discount_type[]
    notIn?: $Enums.Discount_type[]
    not?: NestedEnumDiscount_typeFilter<$PrismaModel> | $Enums.Discount_type
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDiscount_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Discount_type | EnumDiscount_typeFieldRefInput<$PrismaModel>
    in?: $Enums.Discount_type[]
    notIn?: $Enums.Discount_type[]
    not?: NestedEnumDiscount_typeWithAggregatesFilter<$PrismaModel> | $Enums.Discount_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscount_typeFilter<$PrismaModel>
    _max?: NestedEnumDiscount_typeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderDetails_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDetails_status | EnumOrderDetails_statusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderDetails_status[]
    notIn?: $Enums.OrderDetails_status[]
    not?: NestedEnumOrderDetails_statusFilter<$PrismaModel> | $Enums.OrderDetails_status
  }

  export type NestedEnumOrderDetails_paymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDetails_paymentMethod | EnumOrderDetails_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderDetails_paymentMethod[] | null
    notIn?: $Enums.OrderDetails_paymentMethod[] | null
    not?: NestedEnumOrderDetails_paymentMethodNullableFilter<$PrismaModel> | $Enums.OrderDetails_paymentMethod | null
  }

  export type NestedEnumOrderDetails_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDetails_status | EnumOrderDetails_statusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderDetails_status[]
    notIn?: $Enums.OrderDetails_status[]
    not?: NestedEnumOrderDetails_statusWithAggregatesFilter<$PrismaModel> | $Enums.OrderDetails_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderDetails_statusFilter<$PrismaModel>
    _max?: NestedEnumOrderDetails_statusFilter<$PrismaModel>
  }

  export type NestedEnumOrderDetails_paymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderDetails_paymentMethod | EnumOrderDetails_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderDetails_paymentMethod[] | null
    notIn?: $Enums.OrderDetails_paymentMethod[] | null
    not?: NestedEnumOrderDetails_paymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderDetails_paymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderDetails_paymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderDetails_paymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumReturnRequest_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnRequest_status | EnumReturnRequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnRequest_status[]
    notIn?: $Enums.ReturnRequest_status[]
    not?: NestedEnumReturnRequest_statusFilter<$PrismaModel> | $Enums.ReturnRequest_status
  }

  export type NestedEnumReturnRequest_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnRequest_status | EnumReturnRequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnRequest_status[]
    notIn?: $Enums.ReturnRequest_status[]
    not?: NestedEnumReturnRequest_statusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnRequest_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnRequest_statusFilter<$PrismaModel>
    _max?: NestedEnumReturnRequest_statusFilter<$PrismaModel>
  }

  export type NestedEnumStaticMessages_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.StaticMessages_status | EnumStaticMessages_statusFieldRefInput<$PrismaModel>
    in?: $Enums.StaticMessages_status[]
    notIn?: $Enums.StaticMessages_status[]
    not?: NestedEnumStaticMessages_statusFilter<$PrismaModel> | $Enums.StaticMessages_status
  }

  export type NestedEnumStaticMessages_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaticMessages_status | EnumStaticMessages_statusFieldRefInput<$PrismaModel>
    in?: $Enums.StaticMessages_status[]
    notIn?: $Enums.StaticMessages_status[]
    not?: NestedEnumStaticMessages_statusWithAggregatesFilter<$PrismaModel> | $Enums.StaticMessages_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaticMessages_statusFilter<$PrismaModel>
    _max?: NestedEnumStaticMessages_statusFilter<$PrismaModel>
  }

  export type NestedEnumSupportTicket_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicket_status | EnumSupportTicket_statusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicket_status[]
    notIn?: $Enums.SupportTicket_status[]
    not?: NestedEnumSupportTicket_statusFilter<$PrismaModel> | $Enums.SupportTicket_status
  }

  export type NestedEnumSupportTicket_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicket_status | EnumSupportTicket_statusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicket_status[]
    notIn?: $Enums.SupportTicket_status[]
    not?: NestedEnumSupportTicket_statusWithAggregatesFilter<$PrismaModel> | $Enums.SupportTicket_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportTicket_statusFilter<$PrismaModel>
    _max?: NestedEnumSupportTicket_statusFilter<$PrismaModel>
  }

  export type NestedEnumUser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.User_role | EnumUser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.User_role[]
    notIn?: $Enums.User_role[]
    not?: NestedEnumUser_roleFilter<$PrismaModel> | $Enums.User_role
  }

  export type NestedEnumUser_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.User_status | EnumUser_statusFieldRefInput<$PrismaModel>
    in?: $Enums.User_status[]
    notIn?: $Enums.User_status[]
    not?: NestedEnumUser_statusFilter<$PrismaModel> | $Enums.User_status
  }

  export type NestedEnumUser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.User_role | EnumUser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.User_role[]
    notIn?: $Enums.User_role[]
    not?: NestedEnumUser_roleWithAggregatesFilter<$PrismaModel> | $Enums.User_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUser_roleFilter<$PrismaModel>
    _max?: NestedEnumUser_roleFilter<$PrismaModel>
  }

  export type NestedEnumUser_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.User_status | EnumUser_statusFieldRefInput<$PrismaModel>
    in?: $Enums.User_status[]
    notIn?: $Enums.User_status[]
    not?: NestedEnumUser_statusWithAggregatesFilter<$PrismaModel> | $Enums.User_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUser_statusFilter<$PrismaModel>
    _max?: NestedEnumUser_statusFilter<$PrismaModel>
  }

  export type ProductCategoryCreateWithoutAnchorTextInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    Quotes?: QuotesCreateNestedManyWithoutProductCategoryInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductCategoryInput
    Product?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutAnchorTextInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    Quotes?: QuotesUncheckedCreateNestedManyWithoutProductCategoryInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductCategoryInput
    Product?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutAnchorTextInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutAnchorTextInput, ProductCategoryUncheckedCreateWithoutAnchorTextInput>
  }

  export type ProductCategoryUpsertWithoutAnchorTextInput = {
    update: XOR<ProductCategoryUpdateWithoutAnchorTextInput, ProductCategoryUncheckedUpdateWithoutAnchorTextInput>
    create: XOR<ProductCategoryCreateWithoutAnchorTextInput, ProductCategoryUncheckedCreateWithoutAnchorTextInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutAnchorTextInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutAnchorTextInput, ProductCategoryUncheckedUpdateWithoutAnchorTextInput>
  }

  export type ProductCategoryUpdateWithoutAnchorTextInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    Quotes?: QuotesUpdateManyWithoutProductCategoryNestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductCategoryNestedInput
    Product?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutAnchorTextInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    Quotes?: QuotesUncheckedUpdateManyWithoutProductCategoryNestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductCategoryNestedInput
    Product?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type UserCreateWithoutAuditLogInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
  }

  export type UserUpsertWithoutAuditLogInput = {
    update: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type UserUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductColorCreateWithoutCartItemInput = {
    id: string
    name: string
    code: string
    slug: string
    OrderItem?: OrderItemCreateNestedManyWithoutProductColorInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUncheckedCreateWithoutCartItemInput = {
    id: string
    name: string
    code: string
    slug: string
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductColorInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorCreateOrConnectWithoutCartItemInput = {
    where: ProductColorWhereUniqueInput
    create: XOR<ProductColorCreateWithoutCartItemInput, ProductColorUncheckedCreateWithoutCartItemInput>
  }

  export type ProductImageCreateWithoutCartItemInput = {
    id: string
    imageUrl: string
    altText?: string | null
    caption?: string | null
    OrderItem?: OrderItemCreateNestedManyWithoutProductImageInput
    ProductColor?: ProductColorCreateNestedOneWithoutProductImageInput
    Product: ProductCreateNestedOneWithoutProductImageInput
  }

  export type ProductImageUncheckedCreateWithoutCartItemInput = {
    id: string
    productId: string
    imageUrl: string
    colorId?: string | null
    altText?: string | null
    caption?: string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductImageInput
  }

  export type ProductImageCreateOrConnectWithoutCartItemInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutCartItemInput, ProductImageUncheckedCreateWithoutCartItemInput>
  }

  export type ProductCreateWithoutCartItemInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartItemInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
  }

  export type UserCreateWithoutCartItemInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartItemInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartItemInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartItemInput, UserUncheckedCreateWithoutCartItemInput>
  }

  export type ProductColorUpsertWithoutCartItemInput = {
    update: XOR<ProductColorUpdateWithoutCartItemInput, ProductColorUncheckedUpdateWithoutCartItemInput>
    create: XOR<ProductColorCreateWithoutCartItemInput, ProductColorUncheckedCreateWithoutCartItemInput>
    where?: ProductColorWhereInput
  }

  export type ProductColorUpdateToOneWithWhereWithoutCartItemInput = {
    where?: ProductColorWhereInput
    data: XOR<ProductColorUpdateWithoutCartItemInput, ProductColorUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductColorUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    OrderItem?: OrderItemUpdateManyWithoutProductColorNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductColorNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductColorNestedInput
  }

  export type ProductImageUpsertWithoutCartItemInput = {
    update: XOR<ProductImageUpdateWithoutCartItemInput, ProductImageUncheckedUpdateWithoutCartItemInput>
    create: XOR<ProductImageCreateWithoutCartItemInput, ProductImageUncheckedCreateWithoutCartItemInput>
    where?: ProductImageWhereInput
  }

  export type ProductImageUpdateToOneWithWhereWithoutCartItemInput = {
    where?: ProductImageWhereInput
    data: XOR<ProductImageUpdateWithoutCartItemInput, ProductImageUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductImageUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    OrderItem?: OrderItemUpdateManyWithoutProductImageNestedInput
    ProductColor?: ProductColorUpdateOneWithoutProductImageNestedInput
    Product?: ProductUpdateOneRequiredWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductImageNestedInput
  }

  export type ProductUpsertWithoutCartItemInput = {
    update: XOR<ProductUpdateWithoutCartItemInput, ProductUncheckedUpdateWithoutCartItemInput>
    create: XOR<ProductCreateWithoutCartItemInput, ProductUncheckedCreateWithoutCartItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemInput, ProductUncheckedUpdateWithoutCartItemInput>
  }

  export type ProductUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutCartItemInput = {
    update: XOR<UserUpdateWithoutCartItemInput, UserUncheckedUpdateWithoutCartItemInput>
    create: XOR<UserCreateWithoutCartItemInput, UserUncheckedCreateWithoutCartItemInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartItemInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartItemInput, UserUncheckedUpdateWithoutCartItemInput>
  }

  export type UserUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutCustomerTypeInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCustomerTypeInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCustomerTypeInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCustomerTypeInput, ProductUncheckedCreateWithoutCustomerTypeInput>
  }

  export type ProductCreateManyCustomerTypeInputEnvelope = {
    data: ProductCreateManyCustomerTypeInput | ProductCreateManyCustomerTypeInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCustomerTypeInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCustomerTypeInput, ProductUncheckedUpdateWithoutCustomerTypeInput>
    create: XOR<ProductCreateWithoutCustomerTypeInput, ProductUncheckedCreateWithoutCustomerTypeInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCustomerTypeInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCustomerTypeInput, ProductUncheckedUpdateWithoutCustomerTypeInput>
  }

  export type ProductUpdateManyWithWhereWithoutCustomerTypeInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCustomerTypeInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    isReturnable?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    thumbnailUrl?: StringFilter<"Product"> | string
    isActive?: BoolFilter<"Product"> | boolean
    description?: StringNullableFilter<"Product"> | string | null
    summary?: StringNullableFilter<"Product"> | string | null
    customerTypeId?: StringNullableFilter<"Product"> | string | null
    userId?: StringFilter<"Product"> | string
    estimatedDeliveryDay?: IntNullableFilter<"Product"> | number | null
    styleId?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    returnPolicy?: StringNullableFilter<"Product"> | string | null
    views?: IntFilter<"Product"> | number
    displayPrice?: FloatFilter<"Product"> | number
    tags?: JsonFilter<"Product">
    longTailKeyword?: StringNullableFilter<"Product"> | string | null
    affiliateId?: StringFilter<"Product"> | string
    isCODAvailable?: BoolFilter<"Product"> | boolean
    ogImage?: StringNullableFilter<"Product"> | string | null
    sellerCode?: StringNullableFilter<"Product"> | string | null
    sizeChartId?: StringNullableFilter<"Product"> | string | null
    fabricId?: StringNullableFilter<"Product"> | string | null
    seoTitle?: StringNullableFilter<"Product"> | string | null
    seoDescription?: StringNullableFilter<"Product"> | string | null
  }

  export type UserCreateWithoutDeleteRequestInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeleteRequestInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeleteRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeleteRequestInput, UserUncheckedCreateWithoutDeleteRequestInput>
  }

  export type UserUpsertWithoutDeleteRequestInput = {
    update: XOR<UserUpdateWithoutDeleteRequestInput, UserUncheckedUpdateWithoutDeleteRequestInput>
    create: XOR<UserCreateWithoutDeleteRequestInput, UserUncheckedCreateWithoutDeleteRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeleteRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeleteRequestInput, UserUncheckedUpdateWithoutDeleteRequestInput>
  }

  export type UserUpdateWithoutDeleteRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeleteRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutDiscountInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDiscountInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDiscountInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput>
  }

  export type OrderDetailsCreateWithoutDiscountInput = {
    id: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    finalPrice?: number | null
    UserAddress?: UserAddressCreateNestedOneWithoutOrderDetailsInput
    User: UserCreateNestedOneWithoutOrderDetailsInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderDetailsInput
    PaymentDetails?: PaymentDetailsCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsUncheckedCreateWithoutDiscountInput = {
    id: string
    userId: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    addressId?: string | null
    finalPrice?: number | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderDetailsInput
    PaymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsCreateOrConnectWithoutDiscountInput = {
    where: OrderDetailsWhereUniqueInput
    create: XOR<OrderDetailsCreateWithoutDiscountInput, OrderDetailsUncheckedCreateWithoutDiscountInput>
  }

  export type OrderDetailsCreateManyDiscountInputEnvelope = {
    data: OrderDetailsCreateManyDiscountInput | OrderDetailsCreateManyDiscountInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutDiscountInput = {
    update: XOR<ProductUpdateWithoutDiscountInput, ProductUncheckedUpdateWithoutDiscountInput>
    create: XOR<ProductCreateWithoutDiscountInput, ProductUncheckedCreateWithoutDiscountInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutDiscountInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutDiscountInput, ProductUncheckedUpdateWithoutDiscountInput>
  }

  export type ProductUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderDetailsUpsertWithWhereUniqueWithoutDiscountInput = {
    where: OrderDetailsWhereUniqueInput
    update: XOR<OrderDetailsUpdateWithoutDiscountInput, OrderDetailsUncheckedUpdateWithoutDiscountInput>
    create: XOR<OrderDetailsCreateWithoutDiscountInput, OrderDetailsUncheckedCreateWithoutDiscountInput>
  }

  export type OrderDetailsUpdateWithWhereUniqueWithoutDiscountInput = {
    where: OrderDetailsWhereUniqueInput
    data: XOR<OrderDetailsUpdateWithoutDiscountInput, OrderDetailsUncheckedUpdateWithoutDiscountInput>
  }

  export type OrderDetailsUpdateManyWithWhereWithoutDiscountInput = {
    where: OrderDetailsScalarWhereInput
    data: XOR<OrderDetailsUpdateManyMutationInput, OrderDetailsUncheckedUpdateManyWithoutDiscountInput>
  }

  export type OrderDetailsScalarWhereInput = {
    AND?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
    OR?: OrderDetailsScalarWhereInput[]
    NOT?: OrderDetailsScalarWhereInput | OrderDetailsScalarWhereInput[]
    id?: StringFilter<"OrderDetails"> | string
    userId?: StringFilter<"OrderDetails"> | string
    totalPrice?: FloatFilter<"OrderDetails"> | number
    status?: EnumOrderDetails_statusFilter<"OrderDetails"> | $Enums.OrderDetails_status
    createdAt?: DateTimeFilter<"OrderDetails"> | Date | string
    updatedAt?: DateTimeFilter<"OrderDetails"> | Date | string
    discountId?: StringNullableFilter<"OrderDetails"> | string | null
    orderId?: StringFilter<"OrderDetails"> | string
    paymentMethod?: EnumOrderDetails_paymentMethodNullableFilter<"OrderDetails"> | $Enums.OrderDetails_paymentMethod | null
    notes?: StringNullableFilter<"OrderDetails"> | string | null
    trackingId?: StringNullableFilter<"OrderDetails"> | string | null
    addressId?: StringNullableFilter<"OrderDetails"> | string | null
    finalPrice?: FloatNullableFilter<"OrderDetails"> | number | null
  }

  export type UserCreateWithoutDropMessageInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDropMessageInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDropMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDropMessageInput, UserUncheckedCreateWithoutDropMessageInput>
  }

  export type UserUpsertWithoutDropMessageInput = {
    update: XOR<UserUpdateWithoutDropMessageInput, UserUncheckedUpdateWithoutDropMessageInput>
    create: XOR<UserCreateWithoutDropMessageInput, UserUncheckedCreateWithoutDropMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDropMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDropMessageInput, UserUncheckedUpdateWithoutDropMessageInput>
  }

  export type UserUpdateWithoutDropMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDropMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMessage_Message_handledByIdToUserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessage_Message_handledByIdToUserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessage_Message_handledByIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessage_Message_handledByIdToUserInput, UserUncheckedCreateWithoutMessage_Message_handledByIdToUserInput>
  }

  export type UserCreateWithoutMessage_Message_receiverIdToUserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessage_Message_receiverIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput>
  }

  export type UserCreateWithoutMessage_Message_senderIdToUserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessage_Message_senderIdToUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessage_Message_senderIdToUserInput, UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput>
  }

  export type UserUpsertWithoutMessage_Message_handledByIdToUserInput = {
    update: XOR<UserUpdateWithoutMessage_Message_handledByIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_handledByIdToUserInput>
    create: XOR<UserCreateWithoutMessage_Message_handledByIdToUserInput, UserUncheckedCreateWithoutMessage_Message_handledByIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessage_Message_handledByIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessage_Message_handledByIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_handledByIdToUserInput>
  }

  export type UserUpdateWithoutMessage_Message_handledByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessage_Message_handledByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMessage_Message_receiverIdToUserInput = {
    update: XOR<UserUpdateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_receiverIdToUserInput>
    create: XOR<UserCreateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedCreateWithoutMessage_Message_receiverIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessage_Message_receiverIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessage_Message_receiverIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_receiverIdToUserInput>
  }

  export type UserUpdateWithoutMessage_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessage_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMessage_Message_senderIdToUserInput = {
    update: XOR<UserUpdateWithoutMessage_Message_senderIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_senderIdToUserInput>
    create: XOR<UserCreateWithoutMessage_Message_senderIdToUserInput, UserUncheckedCreateWithoutMessage_Message_senderIdToUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessage_Message_senderIdToUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessage_Message_senderIdToUserInput, UserUncheckedUpdateWithoutMessage_Message_senderIdToUserInput>
  }

  export type UserUpdateWithoutMessage_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessage_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAddressCreateWithoutOrderDetailsInput = {
    id: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country: string
    mobileNumber: string
    createdAt?: Date | string
    updatedAt: Date | string
    isDefault: boolean
    fullName?: string | null
    altMobileNumber?: string | null
    User: UserCreateNestedOneWithoutUserAddressInput
  }

  export type UserAddressUncheckedCreateWithoutOrderDetailsInput = {
    id: string
    userId: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country: string
    mobileNumber: string
    createdAt?: Date | string
    updatedAt: Date | string
    isDefault: boolean
    fullName?: string | null
    altMobileNumber?: string | null
  }

  export type UserAddressCreateOrConnectWithoutOrderDetailsInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutOrderDetailsInput, UserAddressUncheckedCreateWithoutOrderDetailsInput>
  }

  export type DiscountCreateWithoutOrderDetailsInput = {
    id: string
    code: string
    description?: string | null
    amount: number
    type: $Enums.Discount_type
    createdAt?: Date | string
    updatedAt: Date | string
    maxPrice?: number | null
    minPrice?: number | null
    isActive?: boolean
    isSpecial?: boolean
    orders?: number | null
    userEmails: JsonNullValueInput | InputJsonValue
    isWebAvailable?: boolean
    isCODAvailable?: boolean
    Product?: ProductCreateNestedOneWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutOrderDetailsInput = {
    id: string
    code: string
    description?: string | null
    amount: number
    type: $Enums.Discount_type
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
    maxPrice?: number | null
    minPrice?: number | null
    isActive?: boolean
    isSpecial?: boolean
    orders?: number | null
    userEmails: JsonNullValueInput | InputJsonValue
    isWebAvailable?: boolean
    isCODAvailable?: boolean
  }

  export type DiscountCreateOrConnectWithoutOrderDetailsInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutOrderDetailsInput, DiscountUncheckedCreateWithoutOrderDetailsInput>
  }

  export type UserCreateWithoutOrderDetailsInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrderDetailsInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrderDetailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderDetailsInput, UserUncheckedCreateWithoutOrderDetailsInput>
  }

  export type OrderItemCreateWithoutOrderDetailsInput = {
    id: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    isReviewed?: boolean
    ProductColor?: ProductColorCreateNestedOneWithoutOrderItemInput
    ProductImage?: ProductImageCreateNestedOneWithoutOrderItemInput
    Product: ProductCreateNestedOneWithoutOrderItemInput
    ProductSize?: ProductSizeCreateNestedOneWithoutOrderItemInput
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderDetailsInput = {
    id: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    colorId?: string | null
    imageId?: string | null
    isReviewed?: boolean
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderDetailsInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderDetailsInput, OrderItemUncheckedCreateWithoutOrderDetailsInput>
  }

  export type OrderItemCreateManyOrderDetailsInputEnvelope = {
    data: OrderItemCreateManyOrderDetailsInput | OrderItemCreateManyOrderDetailsInput[]
    skipDuplicates?: boolean
  }

  export type PaymentDetailsCreateWithoutOrderDetailsInput = {
    id: string
    amount: number
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: string | null
    currency: string
    method: string
    order_id: string
    payment_id: string
    upi?: string | null
    wallet?: string | null
  }

  export type PaymentDetailsUncheckedCreateWithoutOrderDetailsInput = {
    id: string
    amount: number
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: string | null
    currency: string
    method: string
    order_id: string
    payment_id: string
    upi?: string | null
    wallet?: string | null
  }

  export type PaymentDetailsCreateOrConnectWithoutOrderDetailsInput = {
    where: PaymentDetailsWhereUniqueInput
    create: XOR<PaymentDetailsCreateWithoutOrderDetailsInput, PaymentDetailsUncheckedCreateWithoutOrderDetailsInput>
  }

  export type PaymentDetailsCreateManyOrderDetailsInputEnvelope = {
    data: PaymentDetailsCreateManyOrderDetailsInput | PaymentDetailsCreateManyOrderDetailsInput[]
    skipDuplicates?: boolean
  }

  export type UserAddressUpsertWithoutOrderDetailsInput = {
    update: XOR<UserAddressUpdateWithoutOrderDetailsInput, UserAddressUncheckedUpdateWithoutOrderDetailsInput>
    create: XOR<UserAddressCreateWithoutOrderDetailsInput, UserAddressUncheckedCreateWithoutOrderDetailsInput>
    where?: UserAddressWhereInput
  }

  export type UserAddressUpdateToOneWithWhereWithoutOrderDetailsInput = {
    where?: UserAddressWhereInput
    data: XOR<UserAddressUpdateWithoutOrderDetailsInput, UserAddressUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type UserAddressUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    altMobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneRequiredWithoutUserAddressNestedInput
  }

  export type UserAddressUncheckedUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    altMobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiscountUpsertWithoutOrderDetailsInput = {
    update: XOR<DiscountUpdateWithoutOrderDetailsInput, DiscountUncheckedUpdateWithoutOrderDetailsInput>
    create: XOR<DiscountCreateWithoutOrderDetailsInput, DiscountUncheckedCreateWithoutOrderDetailsInput>
    where?: DiscountWhereInput
  }

  export type DiscountUpdateToOneWithWhereWithoutOrderDetailsInput = {
    where?: DiscountWhereInput
    data: XOR<DiscountUpdateWithoutOrderDetailsInput, DiscountUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type DiscountUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumDiscount_typeFieldUpdateOperationsInput | $Enums.Discount_type
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    orders?: NullableIntFieldUpdateOperationsInput | number | null
    userEmails?: JsonNullValueInput | InputJsonValue
    isWebAvailable?: BoolFieldUpdateOperationsInput | boolean
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    Product?: ProductUpdateOneWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumDiscount_typeFieldUpdateOperationsInput | $Enums.Discount_type
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    orders?: NullableIntFieldUpdateOperationsInput | number | null
    userEmails?: JsonNullValueInput | InputJsonValue
    isWebAvailable?: BoolFieldUpdateOperationsInput | boolean
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutOrderDetailsInput = {
    update: XOR<UserUpdateWithoutOrderDetailsInput, UserUncheckedUpdateWithoutOrderDetailsInput>
    create: XOR<UserCreateWithoutOrderDetailsInput, UserUncheckedCreateWithoutOrderDetailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderDetailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderDetailsInput, UserUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type UserUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderDetailsInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderDetailsInput, OrderItemUncheckedUpdateWithoutOrderDetailsInput>
    create: XOR<OrderItemCreateWithoutOrderDetailsInput, OrderItemUncheckedCreateWithoutOrderDetailsInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderDetailsInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderDetailsInput, OrderItemUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderDetailsInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderDetailsInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    sizeId?: StringNullableFilter<"OrderItem"> | string | null
    colorId?: StringNullableFilter<"OrderItem"> | string | null
    imageId?: StringNullableFilter<"OrderItem"> | string | null
    isReviewed?: BoolFilter<"OrderItem"> | boolean
  }

  export type PaymentDetailsUpsertWithWhereUniqueWithoutOrderDetailsInput = {
    where: PaymentDetailsWhereUniqueInput
    update: XOR<PaymentDetailsUpdateWithoutOrderDetailsInput, PaymentDetailsUncheckedUpdateWithoutOrderDetailsInput>
    create: XOR<PaymentDetailsCreateWithoutOrderDetailsInput, PaymentDetailsUncheckedCreateWithoutOrderDetailsInput>
  }

  export type PaymentDetailsUpdateWithWhereUniqueWithoutOrderDetailsInput = {
    where: PaymentDetailsWhereUniqueInput
    data: XOR<PaymentDetailsUpdateWithoutOrderDetailsInput, PaymentDetailsUncheckedUpdateWithoutOrderDetailsInput>
  }

  export type PaymentDetailsUpdateManyWithWhereWithoutOrderDetailsInput = {
    where: PaymentDetailsScalarWhereInput
    data: XOR<PaymentDetailsUpdateManyMutationInput, PaymentDetailsUncheckedUpdateManyWithoutOrderDetailsInput>
  }

  export type PaymentDetailsScalarWhereInput = {
    AND?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
    OR?: PaymentDetailsScalarWhereInput[]
    NOT?: PaymentDetailsScalarWhereInput | PaymentDetailsScalarWhereInput[]
    id?: StringFilter<"PaymentDetails"> | string
    orderId?: StringFilter<"PaymentDetails"> | string
    amount?: FloatFilter<"PaymentDetails"> | number
    createdAt?: DateTimeFilter<"PaymentDetails"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentDetails"> | Date | string
    bank?: StringNullableFilter<"PaymentDetails"> | string | null
    currency?: StringFilter<"PaymentDetails"> | string
    method?: StringFilter<"PaymentDetails"> | string
    order_id?: StringFilter<"PaymentDetails"> | string
    payment_id?: StringFilter<"PaymentDetails"> | string
    upi?: StringNullableFilter<"PaymentDetails"> | string | null
    wallet?: StringNullableFilter<"PaymentDetails"> | string | null
  }

  export type ProductColorCreateWithoutOrderItemInput = {
    id: string
    name: string
    code: string
    slug: string
    CartItem?: CartItemCreateNestedManyWithoutProductColorInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUncheckedCreateWithoutOrderItemInput = {
    id: string
    name: string
    code: string
    slug: string
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductColorInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorCreateOrConnectWithoutOrderItemInput = {
    where: ProductColorWhereUniqueInput
    create: XOR<ProductColorCreateWithoutOrderItemInput, ProductColorUncheckedCreateWithoutOrderItemInput>
  }

  export type ProductImageCreateWithoutOrderItemInput = {
    id: string
    imageUrl: string
    altText?: string | null
    caption?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductImageInput
    ProductColor?: ProductColorCreateNestedOneWithoutProductImageInput
    Product: ProductCreateNestedOneWithoutProductImageInput
  }

  export type ProductImageUncheckedCreateWithoutOrderItemInput = {
    id: string
    productId: string
    imageUrl: string
    colorId?: string | null
    altText?: string | null
    caption?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductImageInput
  }

  export type ProductImageCreateOrConnectWithoutOrderItemInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutOrderItemInput, ProductImageUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderDetailsCreateWithoutOrderItemInput = {
    id: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    finalPrice?: number | null
    UserAddress?: UserAddressCreateNestedOneWithoutOrderDetailsInput
    Discount?: DiscountCreateNestedOneWithoutOrderDetailsInput
    User: UserCreateNestedOneWithoutOrderDetailsInput
    PaymentDetails?: PaymentDetailsCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsUncheckedCreateWithoutOrderItemInput = {
    id: string
    userId: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    discountId?: string | null
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    addressId?: string | null
    finalPrice?: number | null
    PaymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsCreateOrConnectWithoutOrderItemInput = {
    where: OrderDetailsWhereUniqueInput
    create: XOR<OrderDetailsCreateWithoutOrderItemInput, OrderDetailsUncheckedCreateWithoutOrderItemInput>
  }

  export type ProductCreateWithoutOrderItemInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
  }

  export type ProductSizeCreateWithoutOrderItemInput = {
    id: string
    name: string
    slug: string
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeUncheckedCreateWithoutOrderItemInput = {
    id: string
    name: string
    slug: string
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeCreateOrConnectWithoutOrderItemInput = {
    where: ProductSizeWhereUniqueInput
    create: XOR<ProductSizeCreateWithoutOrderItemInput, ProductSizeUncheckedCreateWithoutOrderItemInput>
  }

  export type ReturnRequestCreateWithoutOrderItemInput = {
    id: string
    reason: string
    status?: $Enums.ReturnRequest_status
    requestedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReturnRequestUncheckedCreateWithoutOrderItemInput = {
    id: string
    reason: string
    status?: $Enums.ReturnRequest_status
    requestedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReturnRequestCreateOrConnectWithoutOrderItemInput = {
    where: ReturnRequestWhereUniqueInput
    create: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
  }

  export type ReturnRequestCreateManyOrderItemInputEnvelope = {
    data: ReturnRequestCreateManyOrderItemInput | ReturnRequestCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type ProductColorUpsertWithoutOrderItemInput = {
    update: XOR<ProductColorUpdateWithoutOrderItemInput, ProductColorUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ProductColorCreateWithoutOrderItemInput, ProductColorUncheckedCreateWithoutOrderItemInput>
    where?: ProductColorWhereInput
  }

  export type ProductColorUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: ProductColorWhereInput
    data: XOR<ProductColorUpdateWithoutOrderItemInput, ProductColorUncheckedUpdateWithoutOrderItemInput>
  }

  export type ProductColorUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    CartItem?: CartItemUpdateManyWithoutProductColorNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    CartItem?: CartItemUncheckedUpdateManyWithoutProductColorNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductColorNestedInput
  }

  export type ProductImageUpsertWithoutOrderItemInput = {
    update: XOR<ProductImageUpdateWithoutOrderItemInput, ProductImageUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ProductImageCreateWithoutOrderItemInput, ProductImageUncheckedCreateWithoutOrderItemInput>
    where?: ProductImageWhereInput
  }

  export type ProductImageUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: ProductImageWhereInput
    data: XOR<ProductImageUpdateWithoutOrderItemInput, ProductImageUncheckedUpdateWithoutOrderItemInput>
  }

  export type ProductImageUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductImageNestedInput
    ProductColor?: ProductColorUpdateOneWithoutProductImageNestedInput
    Product?: ProductUpdateOneRequiredWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductImageNestedInput
  }

  export type OrderDetailsUpsertWithoutOrderItemInput = {
    update: XOR<OrderDetailsUpdateWithoutOrderItemInput, OrderDetailsUncheckedUpdateWithoutOrderItemInput>
    create: XOR<OrderDetailsCreateWithoutOrderItemInput, OrderDetailsUncheckedCreateWithoutOrderItemInput>
    where?: OrderDetailsWhereInput
  }

  export type OrderDetailsUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: OrderDetailsWhereInput
    data: XOR<OrderDetailsUpdateWithoutOrderItemInput, OrderDetailsUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderDetailsUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    UserAddress?: UserAddressUpdateOneWithoutOrderDetailsNestedInput
    Discount?: DiscountUpdateOneWithoutOrderDetailsNestedInput
    User?: UserUpdateOneRequiredWithoutOrderDetailsNestedInput
    PaymentDetails?: PaymentDetailsUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutOrderDetailsNestedInput
  }

  export type ProductUpsertWithoutOrderItemInput = {
    update: XOR<ProductUpdateWithoutOrderItemInput, ProductUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ProductCreateWithoutOrderItemInput, ProductUncheckedCreateWithoutOrderItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemInput, ProductUncheckedUpdateWithoutOrderItemInput>
  }

  export type ProductUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductSizeUpsertWithoutOrderItemInput = {
    update: XOR<ProductSizeUpdateWithoutOrderItemInput, ProductSizeUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ProductSizeCreateWithoutOrderItemInput, ProductSizeUncheckedCreateWithoutOrderItemInput>
    where?: ProductSizeWhereInput
  }

  export type ProductSizeUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: ProductSizeWhereInput
    data: XOR<ProductSizeUpdateWithoutOrderItemInput, ProductSizeUncheckedUpdateWithoutOrderItemInput>
  }

  export type ProductSizeUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    ProductInventory?: ProductInventoryUpdateManyWithoutProductSizeNestedInput
  }

  export type ProductSizeUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductSizeNestedInput
  }

  export type ReturnRequestUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: ReturnRequestWhereUniqueInput
    update: XOR<ReturnRequestUpdateWithoutOrderItemInput, ReturnRequestUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ReturnRequestCreateWithoutOrderItemInput, ReturnRequestUncheckedCreateWithoutOrderItemInput>
  }

  export type ReturnRequestUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: ReturnRequestWhereUniqueInput
    data: XOR<ReturnRequestUpdateWithoutOrderItemInput, ReturnRequestUncheckedUpdateWithoutOrderItemInput>
  }

  export type ReturnRequestUpdateManyWithWhereWithoutOrderItemInput = {
    where: ReturnRequestScalarWhereInput
    data: XOR<ReturnRequestUpdateManyMutationInput, ReturnRequestUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type ReturnRequestScalarWhereInput = {
    AND?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[]
    OR?: ReturnRequestScalarWhereInput[]
    NOT?: ReturnRequestScalarWhereInput | ReturnRequestScalarWhereInput[]
    id?: StringFilter<"ReturnRequest"> | string
    orderItemId?: StringFilter<"ReturnRequest"> | string
    reason?: StringFilter<"ReturnRequest"> | string
    status?: EnumReturnRequest_statusFilter<"ReturnRequest"> | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFilter<"ReturnRequest"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"ReturnRequest"> | Date | string | null
  }

  export type UserCreateWithoutOtpInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
  }

  export type UserUpsertWithoutOtpInput = {
    update: XOR<UserUpdateWithoutOtpInput, UserUncheckedUpdateWithoutOtpInput>
    create: XOR<UserCreateWithoutOtpInput, UserUncheckedCreateWithoutOtpInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpInput, UserUncheckedUpdateWithoutOtpInput>
  }

  export type UserUpdateWithoutOtpInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderDetailsCreateWithoutPaymentDetailsInput = {
    id: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    finalPrice?: number | null
    UserAddress?: UserAddressCreateNestedOneWithoutOrderDetailsInput
    Discount?: DiscountCreateNestedOneWithoutOrderDetailsInput
    User: UserCreateNestedOneWithoutOrderDetailsInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsUncheckedCreateWithoutPaymentDetailsInput = {
    id: string
    userId: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    discountId?: string | null
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    addressId?: string | null
    finalPrice?: number | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsCreateOrConnectWithoutPaymentDetailsInput = {
    where: OrderDetailsWhereUniqueInput
    create: XOR<OrderDetailsCreateWithoutPaymentDetailsInput, OrderDetailsUncheckedCreateWithoutPaymentDetailsInput>
  }

  export type OrderDetailsUpsertWithoutPaymentDetailsInput = {
    update: XOR<OrderDetailsUpdateWithoutPaymentDetailsInput, OrderDetailsUncheckedUpdateWithoutPaymentDetailsInput>
    create: XOR<OrderDetailsCreateWithoutPaymentDetailsInput, OrderDetailsUncheckedCreateWithoutPaymentDetailsInput>
    where?: OrderDetailsWhereInput
  }

  export type OrderDetailsUpdateToOneWithWhereWithoutPaymentDetailsInput = {
    where?: OrderDetailsWhereInput
    data: XOR<OrderDetailsUpdateWithoutPaymentDetailsInput, OrderDetailsUncheckedUpdateWithoutPaymentDetailsInput>
  }

  export type OrderDetailsUpdateWithoutPaymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    UserAddress?: UserAddressUpdateOneWithoutOrderDetailsNestedInput
    Discount?: DiscountUpdateOneWithoutOrderDetailsNestedInput
    User?: UserUpdateOneRequiredWithoutOrderDetailsNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateWithoutPaymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderDetailsNestedInput
  }

  export type UserPrivilegeCreateWithoutPrivilegeInput = {
    id: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutUserPrivilegeInput
  }

  export type UserPrivilegeUncheckedCreateWithoutPrivilegeInput = {
    id: string
    userId: string
    createdAt?: Date | string
  }

  export type UserPrivilegeCreateOrConnectWithoutPrivilegeInput = {
    where: UserPrivilegeWhereUniqueInput
    create: XOR<UserPrivilegeCreateWithoutPrivilegeInput, UserPrivilegeUncheckedCreateWithoutPrivilegeInput>
  }

  export type UserPrivilegeCreateManyPrivilegeInputEnvelope = {
    data: UserPrivilegeCreateManyPrivilegeInput | UserPrivilegeCreateManyPrivilegeInput[]
    skipDuplicates?: boolean
  }

  export type UserPrivilegeUpsertWithWhereUniqueWithoutPrivilegeInput = {
    where: UserPrivilegeWhereUniqueInput
    update: XOR<UserPrivilegeUpdateWithoutPrivilegeInput, UserPrivilegeUncheckedUpdateWithoutPrivilegeInput>
    create: XOR<UserPrivilegeCreateWithoutPrivilegeInput, UserPrivilegeUncheckedCreateWithoutPrivilegeInput>
  }

  export type UserPrivilegeUpdateWithWhereUniqueWithoutPrivilegeInput = {
    where: UserPrivilegeWhereUniqueInput
    data: XOR<UserPrivilegeUpdateWithoutPrivilegeInput, UserPrivilegeUncheckedUpdateWithoutPrivilegeInput>
  }

  export type UserPrivilegeUpdateManyWithWhereWithoutPrivilegeInput = {
    where: UserPrivilegeScalarWhereInput
    data: XOR<UserPrivilegeUpdateManyMutationInput, UserPrivilegeUncheckedUpdateManyWithoutPrivilegeInput>
  }

  export type UserPrivilegeScalarWhereInput = {
    AND?: UserPrivilegeScalarWhereInput | UserPrivilegeScalarWhereInput[]
    OR?: UserPrivilegeScalarWhereInput[]
    NOT?: UserPrivilegeScalarWhereInput | UserPrivilegeScalarWhereInput[]
    id?: StringFilter<"UserPrivilege"> | string
    userId?: StringFilter<"UserPrivilege"> | string
    privilegeId?: StringFilter<"UserPrivilege"> | string
    createdAt?: DateTimeFilter<"UserPrivilege"> | Date | string
  }

  export type CartItemCreateWithoutProductInput = {
    id: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    ProductColor?: ProductColorCreateNestedOneWithoutCartItemInput
    ProductImage?: ProductImageCreateNestedOneWithoutCartItemInput
    User: UserCreateNestedOneWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id: string
    userId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    sizeId?: string | null
    imageId?: string | null
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type DiscountCreateWithoutProductInput = {
    id: string
    code: string
    description?: string | null
    amount: number
    type: $Enums.Discount_type
    createdAt?: Date | string
    updatedAt: Date | string
    maxPrice?: number | null
    minPrice?: number | null
    isActive?: boolean
    isSpecial?: boolean
    orders?: number | null
    userEmails: JsonNullValueInput | InputJsonValue
    isWebAvailable?: boolean
    isCODAvailable?: boolean
    OrderDetails?: OrderDetailsCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutProductInput = {
    id: string
    code: string
    description?: string | null
    amount: number
    type: $Enums.Discount_type
    createdAt?: Date | string
    updatedAt: Date | string
    maxPrice?: number | null
    minPrice?: number | null
    isActive?: boolean
    isSpecial?: boolean
    orders?: number | null
    userEmails: JsonNullValueInput | InputJsonValue
    isWebAvailable?: boolean
    isCODAvailable?: boolean
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutProductInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutProductInput, DiscountUncheckedCreateWithoutProductInput>
  }

  export type DiscountCreateManyProductInputEnvelope = {
    data: DiscountCreateManyProductInput | DiscountCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    id: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    isReviewed?: boolean
    ProductColor?: ProductColorCreateNestedOneWithoutOrderItemInput
    ProductImage?: ProductImageCreateNestedOneWithoutOrderItemInput
    OrderDetails: OrderDetailsCreateNestedOneWithoutOrderItemInput
    ProductSize?: ProductSizeCreateNestedOneWithoutOrderItemInput
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id: string
    orderId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    colorId?: string | null
    imageId?: string | null
    isReviewed?: boolean
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CustomerTypeCreateWithoutProductInput = {
    id: string
    name: string
    slug: string
    productId?: string | null
  }

  export type CustomerTypeUncheckedCreateWithoutProductInput = {
    id: string
    name: string
    slug: string
    productId?: string | null
  }

  export type CustomerTypeCreateOrConnectWithoutProductInput = {
    where: CustomerTypeWhereUniqueInput
    create: XOR<CustomerTypeCreateWithoutProductInput, CustomerTypeUncheckedCreateWithoutProductInput>
  }

  export type ProductFabricCreateWithoutProductInput = {
    id: string
    name: string
    slug: string
  }

  export type ProductFabricUncheckedCreateWithoutProductInput = {
    id: string
    name: string
    slug: string
  }

  export type ProductFabricCreateOrConnectWithoutProductInput = {
    where: ProductFabricWhereUniqueInput
    create: XOR<ProductFabricCreateWithoutProductInput, ProductFabricUncheckedCreateWithoutProductInput>
  }

  export type SizeChartCreateWithoutProductInput = {
    id: string
    title?: string | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
  }

  export type SizeChartUncheckedCreateWithoutProductInput = {
    id: string
    title?: string | null
    imageUrl: string
    createdAt?: Date | string
    updatedAt: Date | string
    productId?: string | null
  }

  export type SizeChartCreateOrConnectWithoutProductInput = {
    where: SizeChartWhereUniqueInput
    create: XOR<SizeChartCreateWithoutProductInput, SizeChartUncheckedCreateWithoutProductInput>
  }

  export type UserCreateWithoutProductInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateWithoutProductInput = {
    id: string
    imageUrl: string
    altText?: string | null
    caption?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductImageInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductImageInput
    ProductColor?: ProductColorCreateNestedOneWithoutProductImageInput
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id: string
    imageUrl: string
    colorId?: string | null
    altText?: string | null
    caption?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductImageInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductImageInput
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: ProductImageCreateManyProductInput | ProductImageCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductInventoryCreateWithoutProductInput = {
    id: string
    mrp: number
    price: number
    stock: number
    minQuantity?: number
    discount?: number | null
    ProductSize?: ProductSizeCreateNestedOneWithoutProductInventoryInput
  }

  export type ProductInventoryUncheckedCreateWithoutProductInput = {
    id: string
    mrp: number
    price: number
    sizeId?: string | null
    stock: number
    minQuantity?: number
    discount?: number | null
  }

  export type ProductInventoryCreateOrConnectWithoutProductInput = {
    where: ProductInventoryWhereUniqueInput
    create: XOR<ProductInventoryCreateWithoutProductInput, ProductInventoryUncheckedCreateWithoutProductInput>
  }

  export type ProductInventoryCreateManyProductInputEnvelope = {
    data: ProductInventoryCreateManyProductInput | ProductInventoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductReviewCreateWithoutProductInput = {
    id: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    images: JsonNullValueInput | InputJsonValue
    User: UserCreateNestedOneWithoutProductReviewInput
  }

  export type ProductReviewUncheckedCreateWithoutProductInput = {
    id: string
    userId: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    images: JsonNullValueInput | InputJsonValue
  }

  export type ProductReviewCreateOrConnectWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput>
  }

  export type ProductReviewCreateManyProductInputEnvelope = {
    data: ProductReviewCreateManyProductInput | ProductReviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type WishlistItemCreateWithoutProductInput = {
    id: string
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateWithoutProductInput = {
    id: string
    userId: string
    createdAt?: Date | string
  }

  export type WishlistItemCreateOrConnectWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemCreateManyProductInputEnvelope = {
    data: WishlistItemCreateManyProductInput | WishlistItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutProductInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    AnchorText?: AnchorTextCreateNestedOneWithoutProductCategoryInput
    Quotes?: QuotesCreateNestedManyWithoutProductCategoryInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    AnchorText?: AnchorTextUncheckedCreateNestedOneWithoutProductCategoryInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutProductCategoryInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCreateWithoutProduct_BInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProduct_BInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_BInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_BInput, ProductUncheckedCreateWithoutProduct_BInput>
  }

  export type ProductCreateWithoutProduct_AInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProduct_AInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_AInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_AInput, ProductUncheckedCreateWithoutProduct_AInput>
  }

  export type SubCategoryCreateWithoutProductInput = {
    id: string
    name: string
    slug: string
    imageUrl?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    ProductCategory: ProductCategoryCreateNestedOneWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateWithoutProductInput = {
    id: string
    name: string
    slug: string
    categoryId: string
    imageUrl?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
  }

  export type SubCategoryCreateOrConnectWithoutProductInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    userId?: StringFilter<"CartItem"> | string
    productId?: StringFilter<"CartItem"> | string
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    colorId?: StringNullableFilter<"CartItem"> | string | null
    sizeId?: StringNullableFilter<"CartItem"> | string | null
    imageId?: StringNullableFilter<"CartItem"> | string | null
  }

  export type DiscountUpsertWithWhereUniqueWithoutProductInput = {
    where: DiscountWhereUniqueInput
    update: XOR<DiscountUpdateWithoutProductInput, DiscountUncheckedUpdateWithoutProductInput>
    create: XOR<DiscountCreateWithoutProductInput, DiscountUncheckedCreateWithoutProductInput>
  }

  export type DiscountUpdateWithWhereUniqueWithoutProductInput = {
    where: DiscountWhereUniqueInput
    data: XOR<DiscountUpdateWithoutProductInput, DiscountUncheckedUpdateWithoutProductInput>
  }

  export type DiscountUpdateManyWithWhereWithoutProductInput = {
    where: DiscountScalarWhereInput
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyWithoutProductInput>
  }

  export type DiscountScalarWhereInput = {
    AND?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
    OR?: DiscountScalarWhereInput[]
    NOT?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
    id?: StringFilter<"Discount"> | string
    code?: StringFilter<"Discount"> | string
    description?: StringNullableFilter<"Discount"> | string | null
    amount?: FloatFilter<"Discount"> | number
    type?: EnumDiscount_typeFilter<"Discount"> | $Enums.Discount_type
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    productId?: StringNullableFilter<"Discount"> | string | null
    maxPrice?: FloatNullableFilter<"Discount"> | number | null
    minPrice?: FloatNullableFilter<"Discount"> | number | null
    isActive?: BoolFilter<"Discount"> | boolean
    isSpecial?: BoolFilter<"Discount"> | boolean
    orders?: IntNullableFilter<"Discount"> | number | null
    userEmails?: JsonFilter<"Discount">
    isWebAvailable?: BoolFilter<"Discount"> | boolean
    isCODAvailable?: BoolFilter<"Discount"> | boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CustomerTypeUpsertWithoutProductInput = {
    update: XOR<CustomerTypeUpdateWithoutProductInput, CustomerTypeUncheckedUpdateWithoutProductInput>
    create: XOR<CustomerTypeCreateWithoutProductInput, CustomerTypeUncheckedCreateWithoutProductInput>
    where?: CustomerTypeWhereInput
  }

  export type CustomerTypeUpdateToOneWithWhereWithoutProductInput = {
    where?: CustomerTypeWhereInput
    data: XOR<CustomerTypeUpdateWithoutProductInput, CustomerTypeUncheckedUpdateWithoutProductInput>
  }

  export type CustomerTypeUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerTypeUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductFabricUpsertWithoutProductInput = {
    update: XOR<ProductFabricUpdateWithoutProductInput, ProductFabricUncheckedUpdateWithoutProductInput>
    create: XOR<ProductFabricCreateWithoutProductInput, ProductFabricUncheckedCreateWithoutProductInput>
    where?: ProductFabricWhereInput
  }

  export type ProductFabricUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductFabricWhereInput
    data: XOR<ProductFabricUpdateWithoutProductInput, ProductFabricUncheckedUpdateWithoutProductInput>
  }

  export type ProductFabricUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProductFabricUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type SizeChartUpsertWithoutProductInput = {
    update: XOR<SizeChartUpdateWithoutProductInput, SizeChartUncheckedUpdateWithoutProductInput>
    create: XOR<SizeChartCreateWithoutProductInput, SizeChartUncheckedCreateWithoutProductInput>
    where?: SizeChartWhereInput
  }

  export type SizeChartUpdateToOneWithWhereWithoutProductInput = {
    where?: SizeChartWhereInput
    data: XOR<SizeChartUpdateWithoutProductInput, SizeChartUncheckedUpdateWithoutProductInput>
  }

  export type SizeChartUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SizeChartUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutProductInput = {
    update: XOR<UserUpdateWithoutProductInput, UserUncheckedUpdateWithoutProductInput>
    create: XOR<UserCreateWithoutProductInput, UserUncheckedCreateWithoutProductInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductInput, UserUncheckedUpdateWithoutProductInput>
  }

  export type UserUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    OR?: ProductImageScalarWhereInput[]
    NOT?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    id?: StringFilter<"ProductImage"> | string
    productId?: StringFilter<"ProductImage"> | string
    imageUrl?: StringFilter<"ProductImage"> | string
    colorId?: StringNullableFilter<"ProductImage"> | string | null
    altText?: StringNullableFilter<"ProductImage"> | string | null
    caption?: StringNullableFilter<"ProductImage"> | string | null
  }

  export type ProductInventoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductInventoryWhereUniqueInput
    update: XOR<ProductInventoryUpdateWithoutProductInput, ProductInventoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductInventoryCreateWithoutProductInput, ProductInventoryUncheckedCreateWithoutProductInput>
  }

  export type ProductInventoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductInventoryWhereUniqueInput
    data: XOR<ProductInventoryUpdateWithoutProductInput, ProductInventoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductInventoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductInventoryScalarWhereInput
    data: XOR<ProductInventoryUpdateManyMutationInput, ProductInventoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductInventoryScalarWhereInput = {
    AND?: ProductInventoryScalarWhereInput | ProductInventoryScalarWhereInput[]
    OR?: ProductInventoryScalarWhereInput[]
    NOT?: ProductInventoryScalarWhereInput | ProductInventoryScalarWhereInput[]
    id?: StringFilter<"ProductInventory"> | string
    productId?: StringFilter<"ProductInventory"> | string
    mrp?: IntFilter<"ProductInventory"> | number
    price?: IntFilter<"ProductInventory"> | number
    sizeId?: StringNullableFilter<"ProductInventory"> | string | null
    stock?: IntFilter<"ProductInventory"> | number
    minQuantity?: IntFilter<"ProductInventory"> | number
    discount?: FloatNullableFilter<"ProductInventory"> | number | null
  }

  export type ProductReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    update: XOR<ProductReviewUpdateWithoutProductInput, ProductReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput>
  }

  export type ProductReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    data: XOR<ProductReviewUpdateWithoutProductInput, ProductReviewUncheckedUpdateWithoutProductInput>
  }

  export type ProductReviewUpdateManyWithWhereWithoutProductInput = {
    where: ProductReviewScalarWhereInput
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductReviewScalarWhereInput = {
    AND?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
    OR?: ProductReviewScalarWhereInput[]
    NOT?: ProductReviewScalarWhereInput | ProductReviewScalarWhereInput[]
    id?: StringFilter<"ProductReview"> | string
    userId?: StringFilter<"ProductReview"> | string
    productId?: StringFilter<"ProductReview"> | string
    rating?: IntFilter<"ProductReview"> | number
    review?: StringNullableFilter<"ProductReview"> | string | null
    createdAt?: DateTimeFilter<"ProductReview"> | Date | string
    updatedAt?: DateTimeFilter<"ProductReview"> | Date | string
    images?: JsonFilter<"ProductReview">
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutProductInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutProductInput>
  }

  export type WishlistItemScalarWhereInput = {
    AND?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    OR?: WishlistItemScalarWhereInput[]
    NOT?: WishlistItemScalarWhereInput | WishlistItemScalarWhereInput[]
    id?: StringFilter<"WishlistItem"> | string
    userId?: StringFilter<"WishlistItem"> | string
    productId?: StringFilter<"WishlistItem"> | string
    createdAt?: DateTimeFilter<"WishlistItem"> | Date | string
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    slug?: StringFilter<"ProductCategory"> | string
    isVisible?: BoolFilter<"ProductCategory"> | boolean
    seoTitle?: StringNullableFilter<"ProductCategory"> | string | null
    seoDescription?: StringNullableFilter<"ProductCategory"> | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutProduct_BInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProduct_BInput, ProductUncheckedUpdateWithoutProduct_BInput>
    create: XOR<ProductCreateWithoutProduct_BInput, ProductUncheckedCreateWithoutProduct_BInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProduct_BInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProduct_BInput, ProductUncheckedUpdateWithoutProduct_BInput>
  }

  export type ProductUpdateManyWithWhereWithoutProduct_BInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProduct_BInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutProduct_AInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProduct_AInput, ProductUncheckedUpdateWithoutProduct_AInput>
    create: XOR<ProductCreateWithoutProduct_AInput, ProductUncheckedCreateWithoutProduct_AInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProduct_AInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProduct_AInput, ProductUncheckedUpdateWithoutProduct_AInput>
  }

  export type ProductUpdateManyWithWhereWithoutProduct_AInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProduct_AInput>
  }

  export type SubCategoryUpsertWithWhereUniqueWithoutProductInput = {
    where: SubCategoryWhereUniqueInput
    update: XOR<SubCategoryUpdateWithoutProductInput, SubCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<SubCategoryCreateWithoutProductInput, SubCategoryUncheckedCreateWithoutProductInput>
  }

  export type SubCategoryUpdateWithWhereUniqueWithoutProductInput = {
    where: SubCategoryWhereUniqueInput
    data: XOR<SubCategoryUpdateWithoutProductInput, SubCategoryUncheckedUpdateWithoutProductInput>
  }

  export type SubCategoryUpdateManyWithWhereWithoutProductInput = {
    where: SubCategoryScalarWhereInput
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyWithoutProductInput>
  }

  export type SubCategoryScalarWhereInput = {
    AND?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    OR?: SubCategoryScalarWhereInput[]
    NOT?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    id?: StringFilter<"SubCategory"> | string
    name?: StringFilter<"SubCategory"> | string
    slug?: StringFilter<"SubCategory"> | string
    categoryId?: StringFilter<"SubCategory"> | string
    imageUrl?: StringNullableFilter<"SubCategory"> | string | null
    seoTitle?: StringNullableFilter<"SubCategory"> | string | null
    seoDescription?: StringNullableFilter<"SubCategory"> | string | null
  }

  export type AnchorTextCreateWithoutProductCategoryInput = {
    id: string
    data: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AnchorTextUncheckedCreateWithoutProductCategoryInput = {
    id: string
    data: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AnchorTextCreateOrConnectWithoutProductCategoryInput = {
    where: AnchorTextWhereUniqueInput
    create: XOR<AnchorTextCreateWithoutProductCategoryInput, AnchorTextUncheckedCreateWithoutProductCategoryInput>
  }

  export type QuotesCreateWithoutProductCategoryInput = {
    id: string
    text?: string | null
    imageUrl?: string | null
    hyperLink?: string | null
  }

  export type QuotesUncheckedCreateWithoutProductCategoryInput = {
    id: string
    text?: string | null
    imageUrl?: string | null
    hyperLink?: string | null
  }

  export type QuotesCreateOrConnectWithoutProductCategoryInput = {
    where: QuotesWhereUniqueInput
    create: XOR<QuotesCreateWithoutProductCategoryInput, QuotesUncheckedCreateWithoutProductCategoryInput>
  }

  export type QuotesCreateManyProductCategoryInputEnvelope = {
    data: QuotesCreateManyProductCategoryInput | QuotesCreateManyProductCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubCategoryCreateWithoutProductCategoryInput = {
    id: string
    name: string
    slug: string
    imageUrl?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    Product?: ProductCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateWithoutProductCategoryInput = {
    id: string
    name: string
    slug: string
    imageUrl?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryCreateOrConnectWithoutProductCategoryInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutProductCategoryInput, SubCategoryUncheckedCreateWithoutProductCategoryInput>
  }

  export type SubCategoryCreateManyProductCategoryInputEnvelope = {
    data: SubCategoryCreateManyProductCategoryInput | SubCategoryCreateManyProductCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutProductCategoryInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductCategoryInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type AnchorTextUpsertWithoutProductCategoryInput = {
    update: XOR<AnchorTextUpdateWithoutProductCategoryInput, AnchorTextUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<AnchorTextCreateWithoutProductCategoryInput, AnchorTextUncheckedCreateWithoutProductCategoryInput>
    where?: AnchorTextWhereInput
  }

  export type AnchorTextUpdateToOneWithWhereWithoutProductCategoryInput = {
    where?: AnchorTextWhereInput
    data: XOR<AnchorTextUpdateWithoutProductCategoryInput, AnchorTextUncheckedUpdateWithoutProductCategoryInput>
  }

  export type AnchorTextUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnchorTextUncheckedUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotesUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: QuotesWhereUniqueInput
    update: XOR<QuotesUpdateWithoutProductCategoryInput, QuotesUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<QuotesCreateWithoutProductCategoryInput, QuotesUncheckedCreateWithoutProductCategoryInput>
  }

  export type QuotesUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: QuotesWhereUniqueInput
    data: XOR<QuotesUpdateWithoutProductCategoryInput, QuotesUncheckedUpdateWithoutProductCategoryInput>
  }

  export type QuotesUpdateManyWithWhereWithoutProductCategoryInput = {
    where: QuotesScalarWhereInput
    data: XOR<QuotesUpdateManyMutationInput, QuotesUncheckedUpdateManyWithoutProductCategoryInput>
  }

  export type QuotesScalarWhereInput = {
    AND?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
    OR?: QuotesScalarWhereInput[]
    NOT?: QuotesScalarWhereInput | QuotesScalarWhereInput[]
    id?: StringFilter<"Quotes"> | string
    text?: StringNullableFilter<"Quotes"> | string | null
    imageUrl?: StringNullableFilter<"Quotes"> | string | null
    hyperLink?: StringNullableFilter<"Quotes"> | string | null
    categoryId?: StringFilter<"Quotes"> | string
  }

  export type SubCategoryUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: SubCategoryWhereUniqueInput
    update: XOR<SubCategoryUpdateWithoutProductCategoryInput, SubCategoryUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<SubCategoryCreateWithoutProductCategoryInput, SubCategoryUncheckedCreateWithoutProductCategoryInput>
  }

  export type SubCategoryUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: SubCategoryWhereUniqueInput
    data: XOR<SubCategoryUpdateWithoutProductCategoryInput, SubCategoryUncheckedUpdateWithoutProductCategoryInput>
  }

  export type SubCategoryUpdateManyWithWhereWithoutProductCategoryInput = {
    where: SubCategoryScalarWhereInput
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyWithoutProductCategoryInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductCategoryInput>
  }

  export type CartItemCreateWithoutProductColorInput = {
    id: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    ProductImage?: ProductImageCreateNestedOneWithoutCartItemInput
    Product: ProductCreateNestedOneWithoutCartItemInput
    User: UserCreateNestedOneWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutProductColorInput = {
    id: string
    userId: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    imageId?: string | null
  }

  export type CartItemCreateOrConnectWithoutProductColorInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductColorInput, CartItemUncheckedCreateWithoutProductColorInput>
  }

  export type CartItemCreateManyProductColorInputEnvelope = {
    data: CartItemCreateManyProductColorInput | CartItemCreateManyProductColorInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductColorInput = {
    id: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    isReviewed?: boolean
    ProductImage?: ProductImageCreateNestedOneWithoutOrderItemInput
    OrderDetails: OrderDetailsCreateNestedOneWithoutOrderItemInput
    Product: ProductCreateNestedOneWithoutOrderItemInput
    ProductSize?: ProductSizeCreateNestedOneWithoutOrderItemInput
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutProductColorInput = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    imageId?: string | null
    isReviewed?: boolean
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutProductColorInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductColorInput, OrderItemUncheckedCreateWithoutProductColorInput>
  }

  export type OrderItemCreateManyProductColorInputEnvelope = {
    data: OrderItemCreateManyProductColorInput | OrderItemCreateManyProductColorInput[]
    skipDuplicates?: boolean
  }

  export type ProductImageCreateWithoutProductColorInput = {
    id: string
    imageUrl: string
    altText?: string | null
    caption?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductImageInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductImageInput
    Product: ProductCreateNestedOneWithoutProductImageInput
  }

  export type ProductImageUncheckedCreateWithoutProductColorInput = {
    id: string
    productId: string
    imageUrl: string
    altText?: string | null
    caption?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductImageInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductImageInput
  }

  export type ProductImageCreateOrConnectWithoutProductColorInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductColorInput, ProductImageUncheckedCreateWithoutProductColorInput>
  }

  export type ProductImageCreateManyProductColorInputEnvelope = {
    data: ProductImageCreateManyProductColorInput | ProductImageCreateManyProductColorInput[]
    skipDuplicates?: boolean
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductColorInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductColorInput, CartItemUncheckedUpdateWithoutProductColorInput>
    create: XOR<CartItemCreateWithoutProductColorInput, CartItemUncheckedCreateWithoutProductColorInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductColorInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductColorInput, CartItemUncheckedUpdateWithoutProductColorInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductColorInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductColorInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductColorInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductColorInput, OrderItemUncheckedUpdateWithoutProductColorInput>
    create: XOR<OrderItemCreateWithoutProductColorInput, OrderItemUncheckedCreateWithoutProductColorInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductColorInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductColorInput, OrderItemUncheckedUpdateWithoutProductColorInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductColorInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductColorInput>
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductColorInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductColorInput, ProductImageUncheckedUpdateWithoutProductColorInput>
    create: XOR<ProductImageCreateWithoutProductColorInput, ProductImageUncheckedCreateWithoutProductColorInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductColorInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductColorInput, ProductImageUncheckedUpdateWithoutProductColorInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductColorInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductColorInput>
  }

  export type ProductCreateWithoutProductFabricInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductFabricInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductFabricInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductFabricInput, ProductUncheckedCreateWithoutProductFabricInput>
  }

  export type ProductCreateManyProductFabricInputEnvelope = {
    data: ProductCreateManyProductFabricInput | ProductCreateManyProductFabricInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductFabricInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductFabricInput, ProductUncheckedUpdateWithoutProductFabricInput>
    create: XOR<ProductCreateWithoutProductFabricInput, ProductUncheckedCreateWithoutProductFabricInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductFabricInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductFabricInput, ProductUncheckedUpdateWithoutProductFabricInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductFabricInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductFabricInput>
  }

  export type CartItemCreateWithoutProductImageInput = {
    id: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    ProductColor?: ProductColorCreateNestedOneWithoutCartItemInput
    Product: ProductCreateNestedOneWithoutCartItemInput
    User: UserCreateNestedOneWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutProductImageInput = {
    id: string
    userId: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    sizeId?: string | null
  }

  export type CartItemCreateOrConnectWithoutProductImageInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductImageInput, CartItemUncheckedCreateWithoutProductImageInput>
  }

  export type CartItemCreateManyProductImageInputEnvelope = {
    data: CartItemCreateManyProductImageInput | CartItemCreateManyProductImageInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductImageInput = {
    id: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    isReviewed?: boolean
    ProductColor?: ProductColorCreateNestedOneWithoutOrderItemInput
    OrderDetails: OrderDetailsCreateNestedOneWithoutOrderItemInput
    Product: ProductCreateNestedOneWithoutOrderItemInput
    ProductSize?: ProductSizeCreateNestedOneWithoutOrderItemInput
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutProductImageInput = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    colorId?: string | null
    isReviewed?: boolean
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutProductImageInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductImageInput, OrderItemUncheckedCreateWithoutProductImageInput>
  }

  export type OrderItemCreateManyProductImageInputEnvelope = {
    data: OrderItemCreateManyProductImageInput | OrderItemCreateManyProductImageInput[]
    skipDuplicates?: boolean
  }

  export type ProductColorCreateWithoutProductImageInput = {
    id: string
    name: string
    code: string
    slug: string
    CartItem?: CartItemCreateNestedManyWithoutProductColorInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUncheckedCreateWithoutProductImageInput = {
    id: string
    name: string
    code: string
    slug: string
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductColorInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorCreateOrConnectWithoutProductImageInput = {
    where: ProductColorWhereUniqueInput
    create: XOR<ProductColorCreateWithoutProductImageInput, ProductColorUncheckedCreateWithoutProductImageInput>
  }

  export type ProductCreateWithoutProductImageInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductImageInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductImageInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductImageInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductImageInput, CartItemUncheckedUpdateWithoutProductImageInput>
    create: XOR<CartItemCreateWithoutProductImageInput, CartItemUncheckedCreateWithoutProductImageInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductImageInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductImageInput, CartItemUncheckedUpdateWithoutProductImageInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductImageInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductImageInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductImageInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductImageInput, OrderItemUncheckedUpdateWithoutProductImageInput>
    create: XOR<OrderItemCreateWithoutProductImageInput, OrderItemUncheckedCreateWithoutProductImageInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductImageInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductImageInput, OrderItemUncheckedUpdateWithoutProductImageInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductImageInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductImageInput>
  }

  export type ProductColorUpsertWithoutProductImageInput = {
    update: XOR<ProductColorUpdateWithoutProductImageInput, ProductColorUncheckedUpdateWithoutProductImageInput>
    create: XOR<ProductColorCreateWithoutProductImageInput, ProductColorUncheckedCreateWithoutProductImageInput>
    where?: ProductColorWhereInput
  }

  export type ProductColorUpdateToOneWithWhereWithoutProductImageInput = {
    where?: ProductColorWhereInput
    data: XOR<ProductColorUpdateWithoutProductImageInput, ProductColorUncheckedUpdateWithoutProductImageInput>
  }

  export type ProductColorUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    CartItem?: CartItemUpdateManyWithoutProductColorNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorUncheckedUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    CartItem?: CartItemUncheckedUpdateManyWithoutProductColorNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductColorNestedInput
  }

  export type ProductUpsertWithoutProductImageInput = {
    update: XOR<ProductUpdateWithoutProductImageInput, ProductUncheckedUpdateWithoutProductImageInput>
    create: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductImageInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductImageInput, ProductUncheckedUpdateWithoutProductImageInput>
  }

  export type ProductUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutProductInventoryInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductInventoryInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductInventoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductInventoryInput, ProductUncheckedCreateWithoutProductInventoryInput>
  }

  export type ProductSizeCreateWithoutProductInventoryInput = {
    id: string
    name: string
    slug: string
    OrderItem?: OrderItemCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeUncheckedCreateWithoutProductInventoryInput = {
    id: string
    name: string
    slug: string
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeCreateOrConnectWithoutProductInventoryInput = {
    where: ProductSizeWhereUniqueInput
    create: XOR<ProductSizeCreateWithoutProductInventoryInput, ProductSizeUncheckedCreateWithoutProductInventoryInput>
  }

  export type ProductUpsertWithoutProductInventoryInput = {
    update: XOR<ProductUpdateWithoutProductInventoryInput, ProductUncheckedUpdateWithoutProductInventoryInput>
    create: XOR<ProductCreateWithoutProductInventoryInput, ProductUncheckedCreateWithoutProductInventoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductInventoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductInventoryInput, ProductUncheckedUpdateWithoutProductInventoryInput>
  }

  export type ProductUpdateWithoutProductInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductSizeUpsertWithoutProductInventoryInput = {
    update: XOR<ProductSizeUpdateWithoutProductInventoryInput, ProductSizeUncheckedUpdateWithoutProductInventoryInput>
    create: XOR<ProductSizeCreateWithoutProductInventoryInput, ProductSizeUncheckedCreateWithoutProductInventoryInput>
    where?: ProductSizeWhereInput
  }

  export type ProductSizeUpdateToOneWithWhereWithoutProductInventoryInput = {
    where?: ProductSizeWhereInput
    data: XOR<ProductSizeUpdateWithoutProductInventoryInput, ProductSizeUncheckedUpdateWithoutProductInventoryInput>
  }

  export type ProductSizeUpdateWithoutProductInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    OrderItem?: OrderItemUpdateManyWithoutProductSizeNestedInput
  }

  export type ProductSizeUncheckedUpdateWithoutProductInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductSizeNestedInput
  }

  export type ProductCreateWithoutProductReviewInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductReviewInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductReviewInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductReviewInput, ProductUncheckedCreateWithoutProductReviewInput>
  }

  export type UserCreateWithoutProductReviewInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductReviewInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductReviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductReviewInput, UserUncheckedCreateWithoutProductReviewInput>
  }

  export type ProductUpsertWithoutProductReviewInput = {
    update: XOR<ProductUpdateWithoutProductReviewInput, ProductUncheckedUpdateWithoutProductReviewInput>
    create: XOR<ProductCreateWithoutProductReviewInput, ProductUncheckedCreateWithoutProductReviewInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductReviewInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductReviewInput, ProductUncheckedUpdateWithoutProductReviewInput>
  }

  export type ProductUpdateWithoutProductReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutProductReviewInput = {
    update: XOR<UserUpdateWithoutProductReviewInput, UserUncheckedUpdateWithoutProductReviewInput>
    create: XOR<UserCreateWithoutProductReviewInput, UserUncheckedCreateWithoutProductReviewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductReviewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductReviewInput, UserUncheckedUpdateWithoutProductReviewInput>
  }

  export type UserUpdateWithoutProductReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderItemCreateWithoutProductSizeInput = {
    id: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    isReviewed?: boolean
    ProductColor?: ProductColorCreateNestedOneWithoutOrderItemInput
    ProductImage?: ProductImageCreateNestedOneWithoutOrderItemInput
    OrderDetails: OrderDetailsCreateNestedOneWithoutOrderItemInput
    Product: ProductCreateNestedOneWithoutOrderItemInput
    ReturnRequest?: ReturnRequestCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutProductSizeInput = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    imageId?: string | null
    isReviewed?: boolean
    ReturnRequest?: ReturnRequestUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutProductSizeInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductSizeInput, OrderItemUncheckedCreateWithoutProductSizeInput>
  }

  export type OrderItemCreateManyProductSizeInputEnvelope = {
    data: OrderItemCreateManyProductSizeInput | OrderItemCreateManyProductSizeInput[]
    skipDuplicates?: boolean
  }

  export type ProductInventoryCreateWithoutProductSizeInput = {
    id: string
    mrp: number
    price: number
    stock: number
    minQuantity?: number
    discount?: number | null
    Product: ProductCreateNestedOneWithoutProductInventoryInput
  }

  export type ProductInventoryUncheckedCreateWithoutProductSizeInput = {
    id: string
    productId: string
    mrp: number
    price: number
    stock: number
    minQuantity?: number
    discount?: number | null
  }

  export type ProductInventoryCreateOrConnectWithoutProductSizeInput = {
    where: ProductInventoryWhereUniqueInput
    create: XOR<ProductInventoryCreateWithoutProductSizeInput, ProductInventoryUncheckedCreateWithoutProductSizeInput>
  }

  export type ProductInventoryCreateManyProductSizeInputEnvelope = {
    data: ProductInventoryCreateManyProductSizeInput | ProductInventoryCreateManyProductSizeInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductSizeInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductSizeInput, OrderItemUncheckedUpdateWithoutProductSizeInput>
    create: XOR<OrderItemCreateWithoutProductSizeInput, OrderItemUncheckedCreateWithoutProductSizeInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductSizeInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductSizeInput, OrderItemUncheckedUpdateWithoutProductSizeInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductSizeInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductSizeInput>
  }

  export type ProductInventoryUpsertWithWhereUniqueWithoutProductSizeInput = {
    where: ProductInventoryWhereUniqueInput
    update: XOR<ProductInventoryUpdateWithoutProductSizeInput, ProductInventoryUncheckedUpdateWithoutProductSizeInput>
    create: XOR<ProductInventoryCreateWithoutProductSizeInput, ProductInventoryUncheckedCreateWithoutProductSizeInput>
  }

  export type ProductInventoryUpdateWithWhereUniqueWithoutProductSizeInput = {
    where: ProductInventoryWhereUniqueInput
    data: XOR<ProductInventoryUpdateWithoutProductSizeInput, ProductInventoryUncheckedUpdateWithoutProductSizeInput>
  }

  export type ProductInventoryUpdateManyWithWhereWithoutProductSizeInput = {
    where: ProductInventoryScalarWhereInput
    data: XOR<ProductInventoryUpdateManyMutationInput, ProductInventoryUncheckedUpdateManyWithoutProductSizeInput>
  }

  export type ProductCategoryCreateWithoutQuotesInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    AnchorText?: AnchorTextCreateNestedOneWithoutProductCategoryInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductCategoryInput
    Product?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutQuotesInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    AnchorText?: AnchorTextUncheckedCreateNestedOneWithoutProductCategoryInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductCategoryInput
    Product?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutQuotesInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutQuotesInput, ProductCategoryUncheckedCreateWithoutQuotesInput>
  }

  export type ProductCategoryUpsertWithoutQuotesInput = {
    update: XOR<ProductCategoryUpdateWithoutQuotesInput, ProductCategoryUncheckedUpdateWithoutQuotesInput>
    create: XOR<ProductCategoryCreateWithoutQuotesInput, ProductCategoryUncheckedCreateWithoutQuotesInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutQuotesInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutQuotesInput, ProductCategoryUncheckedUpdateWithoutQuotesInput>
  }

  export type ProductCategoryUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    AnchorText?: AnchorTextUpdateOneWithoutProductCategoryNestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductCategoryNestedInput
    Product?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    AnchorText?: AnchorTextUncheckedUpdateOneWithoutProductCategoryNestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductCategoryNestedInput
    Product?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type OrderItemCreateWithoutReturnRequestInput = {
    id: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    isReviewed?: boolean
    ProductColor?: ProductColorCreateNestedOneWithoutOrderItemInput
    ProductImage?: ProductImageCreateNestedOneWithoutOrderItemInput
    OrderDetails: OrderDetailsCreateNestedOneWithoutOrderItemInput
    Product: ProductCreateNestedOneWithoutOrderItemInput
    ProductSize?: ProductSizeCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutReturnRequestInput = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    colorId?: string | null
    imageId?: string | null
    isReviewed?: boolean
  }

  export type OrderItemCreateOrConnectWithoutReturnRequestInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>
  }

  export type OrderItemUpsertWithoutReturnRequestInput = {
    update: XOR<OrderItemUpdateWithoutReturnRequestInput, OrderItemUncheckedUpdateWithoutReturnRequestInput>
    create: XOR<OrderItemCreateWithoutReturnRequestInput, OrderItemUncheckedCreateWithoutReturnRequestInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutReturnRequestInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutReturnRequestInput, OrderItemUncheckedUpdateWithoutReturnRequestInput>
  }

  export type OrderItemUpdateWithoutReturnRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ProductColor?: ProductColorUpdateOneWithoutOrderItemNestedInput
    ProductImage?: ProductImageUpdateOneWithoutOrderItemNestedInput
    OrderDetails?: OrderDetailsUpdateOneRequiredWithoutOrderItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
    ProductSize?: ProductSizeUpdateOneWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutReturnRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutRewardsInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRewardsInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRewardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
  }

  export type UserUpsertWithoutRewardsInput = {
    update: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
    create: XOR<UserCreateWithoutRewardsInput, UserUncheckedCreateWithoutRewardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRewardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRewardsInput, UserUncheckedUpdateWithoutRewardsInput>
  }

  export type UserUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSearchQueryInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSearchQueryInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSearchQueryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearchQueryInput, UserUncheckedCreateWithoutSearchQueryInput>
  }

  export type UserUpsertWithoutSearchQueryInput = {
    update: XOR<UserUpdateWithoutSearchQueryInput, UserUncheckedUpdateWithoutSearchQueryInput>
    create: XOR<UserCreateWithoutSearchQueryInput, UserUncheckedCreateWithoutSearchQueryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearchQueryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearchQueryInput, UserUncheckedUpdateWithoutSearchQueryInput>
  }

  export type UserUpdateWithoutSearchQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSearchQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
  }

  export type UserUpsertWithoutSessionInput = {
    update: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
  }

  export type UserUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ShopByOccasionProductCreateWithoutShopByOccasionInput = {
    id: string
    imageUrl: string
    hyperLink: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput = {
    id: string
    imageUrl: string
    hyperLink: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopByOccasionProductCreateOrConnectWithoutShopByOccasionInput = {
    where: ShopByOccasionProductWhereUniqueInput
    create: XOR<ShopByOccasionProductCreateWithoutShopByOccasionInput, ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput>
  }

  export type ShopByOccasionProductCreateManyShopByOccasionInputEnvelope = {
    data: ShopByOccasionProductCreateManyShopByOccasionInput | ShopByOccasionProductCreateManyShopByOccasionInput[]
    skipDuplicates?: boolean
  }

  export type ShopByOccasionProductUpsertWithWhereUniqueWithoutShopByOccasionInput = {
    where: ShopByOccasionProductWhereUniqueInput
    update: XOR<ShopByOccasionProductUpdateWithoutShopByOccasionInput, ShopByOccasionProductUncheckedUpdateWithoutShopByOccasionInput>
    create: XOR<ShopByOccasionProductCreateWithoutShopByOccasionInput, ShopByOccasionProductUncheckedCreateWithoutShopByOccasionInput>
  }

  export type ShopByOccasionProductUpdateWithWhereUniqueWithoutShopByOccasionInput = {
    where: ShopByOccasionProductWhereUniqueInput
    data: XOR<ShopByOccasionProductUpdateWithoutShopByOccasionInput, ShopByOccasionProductUncheckedUpdateWithoutShopByOccasionInput>
  }

  export type ShopByOccasionProductUpdateManyWithWhereWithoutShopByOccasionInput = {
    where: ShopByOccasionProductScalarWhereInput
    data: XOR<ShopByOccasionProductUpdateManyMutationInput, ShopByOccasionProductUncheckedUpdateManyWithoutShopByOccasionInput>
  }

  export type ShopByOccasionProductScalarWhereInput = {
    AND?: ShopByOccasionProductScalarWhereInput | ShopByOccasionProductScalarWhereInput[]
    OR?: ShopByOccasionProductScalarWhereInput[]
    NOT?: ShopByOccasionProductScalarWhereInput | ShopByOccasionProductScalarWhereInput[]
    id?: StringFilter<"ShopByOccasionProduct"> | string
    imageUrl?: StringFilter<"ShopByOccasionProduct"> | string
    hyperLink?: StringFilter<"ShopByOccasionProduct"> | string
    shopByOccasionId?: StringNullableFilter<"ShopByOccasionProduct"> | string | null
    createdAt?: DateTimeFilter<"ShopByOccasionProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ShopByOccasionProduct"> | Date | string
  }

  export type ShopByOccasionCreateWithoutShopByOccasionProductInput = {
    id: string
    occasionName?: string | null
    categoryHyperLinks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopByOccasionUncheckedCreateWithoutShopByOccasionProductInput = {
    id: string
    occasionName?: string | null
    categoryHyperLinks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopByOccasionCreateOrConnectWithoutShopByOccasionProductInput = {
    where: ShopByOccasionWhereUniqueInput
    create: XOR<ShopByOccasionCreateWithoutShopByOccasionProductInput, ShopByOccasionUncheckedCreateWithoutShopByOccasionProductInput>
  }

  export type ShopByOccasionUpsertWithoutShopByOccasionProductInput = {
    update: XOR<ShopByOccasionUpdateWithoutShopByOccasionProductInput, ShopByOccasionUncheckedUpdateWithoutShopByOccasionProductInput>
    create: XOR<ShopByOccasionCreateWithoutShopByOccasionProductInput, ShopByOccasionUncheckedCreateWithoutShopByOccasionProductInput>
    where?: ShopByOccasionWhereInput
  }

  export type ShopByOccasionUpdateToOneWithWhereWithoutShopByOccasionProductInput = {
    where?: ShopByOccasionWhereInput
    data: XOR<ShopByOccasionUpdateWithoutShopByOccasionProductInput, ShopByOccasionUncheckedUpdateWithoutShopByOccasionProductInput>
  }

  export type ShopByOccasionUpdateWithoutShopByOccasionProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    occasionName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLinks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopByOccasionUncheckedUpdateWithoutShopByOccasionProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    occasionName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryHyperLinks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopBySeasonProductCreateWithoutShopBySeasonInput = {
    id: string
    imageUrl: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    hyperLink: string
  }

  export type ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput = {
    id: string
    imageUrl: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    hyperLink: string
  }

  export type ShopBySeasonProductCreateOrConnectWithoutShopBySeasonInput = {
    where: ShopBySeasonProductWhereUniqueInput
    create: XOR<ShopBySeasonProductCreateWithoutShopBySeasonInput, ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput>
  }

  export type ShopBySeasonProductCreateManyShopBySeasonInputEnvelope = {
    data: ShopBySeasonProductCreateManyShopBySeasonInput | ShopBySeasonProductCreateManyShopBySeasonInput[]
    skipDuplicates?: boolean
  }

  export type ShopBySeasonProductUpsertWithWhereUniqueWithoutShopBySeasonInput = {
    where: ShopBySeasonProductWhereUniqueInput
    update: XOR<ShopBySeasonProductUpdateWithoutShopBySeasonInput, ShopBySeasonProductUncheckedUpdateWithoutShopBySeasonInput>
    create: XOR<ShopBySeasonProductCreateWithoutShopBySeasonInput, ShopBySeasonProductUncheckedCreateWithoutShopBySeasonInput>
  }

  export type ShopBySeasonProductUpdateWithWhereUniqueWithoutShopBySeasonInput = {
    where: ShopBySeasonProductWhereUniqueInput
    data: XOR<ShopBySeasonProductUpdateWithoutShopBySeasonInput, ShopBySeasonProductUncheckedUpdateWithoutShopBySeasonInput>
  }

  export type ShopBySeasonProductUpdateManyWithWhereWithoutShopBySeasonInput = {
    where: ShopBySeasonProductScalarWhereInput
    data: XOR<ShopBySeasonProductUpdateManyMutationInput, ShopBySeasonProductUncheckedUpdateManyWithoutShopBySeasonInput>
  }

  export type ShopBySeasonProductScalarWhereInput = {
    AND?: ShopBySeasonProductScalarWhereInput | ShopBySeasonProductScalarWhereInput[]
    OR?: ShopBySeasonProductScalarWhereInput[]
    NOT?: ShopBySeasonProductScalarWhereInput | ShopBySeasonProductScalarWhereInput[]
    id?: StringFilter<"ShopBySeasonProduct"> | string
    imageUrl?: StringFilter<"ShopBySeasonProduct"> | string
    description?: StringNullableFilter<"ShopBySeasonProduct"> | string | null
    createdAt?: DateTimeFilter<"ShopBySeasonProduct"> | Date | string
    updatedAt?: DateTimeFilter<"ShopBySeasonProduct"> | Date | string
    seasonId?: StringFilter<"ShopBySeasonProduct"> | string
    hyperLink?: StringFilter<"ShopBySeasonProduct"> | string
  }

  export type ShopBySeasonCreateWithoutShopBySeasonProductInput = {
    id: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopBySeasonUncheckedCreateWithoutShopBySeasonProductInput = {
    id: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopBySeasonCreateOrConnectWithoutShopBySeasonProductInput = {
    where: ShopBySeasonWhereUniqueInput
    create: XOR<ShopBySeasonCreateWithoutShopBySeasonProductInput, ShopBySeasonUncheckedCreateWithoutShopBySeasonProductInput>
  }

  export type ShopBySeasonUpsertWithoutShopBySeasonProductInput = {
    update: XOR<ShopBySeasonUpdateWithoutShopBySeasonProductInput, ShopBySeasonUncheckedUpdateWithoutShopBySeasonProductInput>
    create: XOR<ShopBySeasonCreateWithoutShopBySeasonProductInput, ShopBySeasonUncheckedCreateWithoutShopBySeasonProductInput>
    where?: ShopBySeasonWhereInput
  }

  export type ShopBySeasonUpdateToOneWithWhereWithoutShopBySeasonProductInput = {
    where?: ShopBySeasonWhereInput
    data: XOR<ShopBySeasonUpdateWithoutShopBySeasonProductInput, ShopBySeasonUncheckedUpdateWithoutShopBySeasonProductInput>
  }

  export type ShopBySeasonUpdateWithoutShopBySeasonProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopBySeasonUncheckedUpdateWithoutShopBySeasonProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutSizeChartInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSizeChartInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSizeChartInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSizeChartInput, ProductUncheckedCreateWithoutSizeChartInput>
  }

  export type ProductCreateManySizeChartInputEnvelope = {
    data: ProductCreateManySizeChartInput | ProductCreateManySizeChartInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutSizeChartInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSizeChartInput, ProductUncheckedUpdateWithoutSizeChartInput>
    create: XOR<ProductCreateWithoutSizeChartInput, ProductUncheckedCreateWithoutSizeChartInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSizeChartInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSizeChartInput, ProductUncheckedUpdateWithoutSizeChartInput>
  }

  export type ProductUpdateManyWithWhereWithoutSizeChartInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSizeChartInput>
  }

  export type UserCreateWithoutStaticMessagesInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStaticMessagesInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStaticMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaticMessagesInput, UserUncheckedCreateWithoutStaticMessagesInput>
  }

  export type UserUpsertWithoutStaticMessagesInput = {
    update: XOR<UserUpdateWithoutStaticMessagesInput, UserUncheckedUpdateWithoutStaticMessagesInput>
    create: XOR<UserCreateWithoutStaticMessagesInput, UserUncheckedCreateWithoutStaticMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaticMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaticMessagesInput, UserUncheckedUpdateWithoutStaticMessagesInput>
  }

  export type UserUpdateWithoutStaticMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaticMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCategoryCreateWithoutSubCategoryInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    AnchorText?: AnchorTextCreateNestedOneWithoutProductCategoryInput
    Quotes?: QuotesCreateNestedManyWithoutProductCategoryInput
    Product?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutSubCategoryInput = {
    id: string
    name: string
    slug: string
    isVisible?: boolean
    seoTitle?: string | null
    seoDescription?: string | null
    AnchorText?: AnchorTextUncheckedCreateNestedOneWithoutProductCategoryInput
    Quotes?: QuotesUncheckedCreateNestedManyWithoutProductCategoryInput
    Product?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutSubCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutSubCategoryInput, ProductCategoryUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductCreateWithoutSubCategoryInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
  }

  export type ProductUncheckedCreateWithoutSubCategoryInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
  }

  export type ProductCreateOrConnectWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductCategoryUpsertWithoutSubCategoryInput = {
    update: XOR<ProductCategoryUpdateWithoutSubCategoryInput, ProductCategoryUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<ProductCategoryCreateWithoutSubCategoryInput, ProductCategoryUncheckedCreateWithoutSubCategoryInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutSubCategoryInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutSubCategoryInput, ProductCategoryUncheckedUpdateWithoutSubCategoryInput>
  }

  export type ProductCategoryUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    AnchorText?: AnchorTextUpdateOneWithoutProductCategoryNestedInput
    Quotes?: QuotesUpdateManyWithoutProductCategoryNestedInput
    Product?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    AnchorText?: AnchorTextUncheckedUpdateOneWithoutProductCategoryNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutProductCategoryNestedInput
    Product?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSubCategoryInput, ProductUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<ProductCreateWithoutSubCategoryInput, ProductUncheckedCreateWithoutSubCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSubCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSubCategoryInput, ProductUncheckedUpdateWithoutSubCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutSubCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSubCategoryInput>
  }

  export type UserCreateWithoutSupportTicketInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupportTicketInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupportTicketInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportTicketInput, UserUncheckedCreateWithoutSupportTicketInput>
  }

  export type UserUpsertWithoutSupportTicketInput = {
    update: XOR<UserUpdateWithoutSupportTicketInput, UserUncheckedUpdateWithoutSupportTicketInput>
    create: XOR<UserCreateWithoutSupportTicketInput, UserUncheckedCreateWithoutSupportTicketInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportTicketInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportTicketInput, UserUncheckedUpdateWithoutSupportTicketInput>
  }

  export type UserUpdateWithoutSupportTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUpdateHistoryInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUpdateHistoryInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUpdateHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdateHistoryInput, UserUncheckedCreateWithoutUpdateHistoryInput>
  }

  export type UserUpsertWithoutUpdateHistoryInput = {
    update: XOR<UserUpdateWithoutUpdateHistoryInput, UserUncheckedUpdateWithoutUpdateHistoryInput>
    create: XOR<UserCreateWithoutUpdateHistoryInput, UserUncheckedCreateWithoutUpdateHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdateHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdateHistoryInput, UserUncheckedUpdateWithoutUpdateHistoryInput>
  }

  export type UserUpdateWithoutUpdateHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdateHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuditLogCreateWithoutUserInput = {
    id: string
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id: string
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutUserInput = {
    id: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    ProductColor?: ProductColorCreateNestedOneWithoutCartItemInput
    ProductImage?: ProductImageCreateNestedOneWithoutCartItemInput
    Product: ProductCreateNestedOneWithoutCartItemInput
  }

  export type CartItemUncheckedCreateWithoutUserInput = {
    id: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    sizeId?: string | null
    imageId?: string | null
  }

  export type CartItemCreateOrConnectWithoutUserInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput>
  }

  export type CartItemCreateManyUserInputEnvelope = {
    data: CartItemCreateManyUserInput | CartItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeleteRequestCreateWithoutUserInput = {
    id: string
    userName?: string | null
    userEmail?: string | null
    reason?: string | null
    status?: $Enums.DeleteRequest_status
    createdAt?: Date | string
  }

  export type DeleteRequestUncheckedCreateWithoutUserInput = {
    id: string
    userName?: string | null
    userEmail?: string | null
    reason?: string | null
    status?: $Enums.DeleteRequest_status
    createdAt?: Date | string
  }

  export type DeleteRequestCreateOrConnectWithoutUserInput = {
    where: DeleteRequestWhereUniqueInput
    create: XOR<DeleteRequestCreateWithoutUserInput, DeleteRequestUncheckedCreateWithoutUserInput>
  }

  export type DeleteRequestCreateManyUserInputEnvelope = {
    data: DeleteRequestCreateManyUserInput | DeleteRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DropMessageCreateWithoutUserInput = {
    id: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DropMessageUncheckedCreateWithoutUserInput = {
    id: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type DropMessageCreateOrConnectWithoutUserInput = {
    where: DropMessageWhereUniqueInput
    create: XOR<DropMessageCreateWithoutUserInput, DropMessageUncheckedCreateWithoutUserInput>
  }

  export type DropMessageCreateManyUserInputEnvelope = {
    data: DropMessageCreateManyUserInput | DropMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUser_Message_handledByIdToUserInput = {
    id: string
    message: string
    createdAt?: Date | string
    User_Message_receiverIdToUser: UserCreateNestedOneWithoutMessage_Message_receiverIdToUserInput
    User_Message_senderIdToUser: UserCreateNestedOneWithoutMessage_Message_senderIdToUserInput
  }

  export type MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput = {
    id: string
    senderId: string
    receiverId: string
    message: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutUser_Message_handledByIdToUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUser_Message_handledByIdToUserInput, MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput>
  }

  export type MessageCreateManyUser_Message_handledByIdToUserInputEnvelope = {
    data: MessageCreateManyUser_Message_handledByIdToUserInput | MessageCreateManyUser_Message_handledByIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUser_Message_receiverIdToUserInput = {
    id: string
    message: string
    createdAt?: Date | string
    User_Message_handledByIdToUser?: UserCreateNestedOneWithoutMessage_Message_handledByIdToUserInput
    User_Message_senderIdToUser: UserCreateNestedOneWithoutMessage_Message_senderIdToUserInput
  }

  export type MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput = {
    id: string
    senderId: string
    message: string
    createdAt?: Date | string
    handledById?: string | null
  }

  export type MessageCreateOrConnectWithoutUser_Message_receiverIdToUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput>
  }

  export type MessageCreateManyUser_Message_receiverIdToUserInputEnvelope = {
    data: MessageCreateManyUser_Message_receiverIdToUserInput | MessageCreateManyUser_Message_receiverIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUser_Message_senderIdToUserInput = {
    id: string
    message: string
    createdAt?: Date | string
    User_Message_handledByIdToUser?: UserCreateNestedOneWithoutMessage_Message_handledByIdToUserInput
    User_Message_receiverIdToUser: UserCreateNestedOneWithoutMessage_Message_receiverIdToUserInput
  }

  export type MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput = {
    id: string
    receiverId: string
    message: string
    createdAt?: Date | string
    handledById?: string | null
  }

  export type MessageCreateOrConnectWithoutUser_Message_senderIdToUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput>
  }

  export type MessageCreateManyUser_Message_senderIdToUserInputEnvelope = {
    data: MessageCreateManyUser_Message_senderIdToUserInput | MessageCreateManyUser_Message_senderIdToUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    hyperLink?: string | null
    title: string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    hyperLink?: string | null
    title: string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderDetailsCreateWithoutUserInput = {
    id: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    finalPrice?: number | null
    UserAddress?: UserAddressCreateNestedOneWithoutOrderDetailsInput
    Discount?: DiscountCreateNestedOneWithoutOrderDetailsInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderDetailsInput
    PaymentDetails?: PaymentDetailsCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsUncheckedCreateWithoutUserInput = {
    id: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    discountId?: string | null
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    addressId?: string | null
    finalPrice?: number | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderDetailsInput
    PaymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsCreateOrConnectWithoutUserInput = {
    where: OrderDetailsWhereUniqueInput
    create: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput>
  }

  export type OrderDetailsCreateManyUserInputEnvelope = {
    data: OrderDetailsCreateManyUserInput | OrderDetailsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OtpCreateWithoutUserInput = {
    id: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpUncheckedCreateWithoutUserInput = {
    id: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpCreateOrConnectWithoutUserInput = {
    where: OtpWhereUniqueInput
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type OtpCreateManyUserInputEnvelope = {
    data: OtpCreateManyUserInput | OtpCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUserInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUserInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUserInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductCreateManyUserInputEnvelope = {
    data: ProductCreateManyUserInput | ProductCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductReviewCreateWithoutUserInput = {
    id: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    images: JsonNullValueInput | InputJsonValue
    Product: ProductCreateNestedOneWithoutProductReviewInput
  }

  export type ProductReviewUncheckedCreateWithoutUserInput = {
    id: string
    productId: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    images: JsonNullValueInput | InputJsonValue
  }

  export type ProductReviewCreateOrConnectWithoutUserInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput>
  }

  export type ProductReviewCreateManyUserInputEnvelope = {
    data: ProductReviewCreateManyUserInput | ProductReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RewardsCreateWithoutUserInput = {
    id: string
    title?: string | null
    code?: string | null
    description?: string | null
  }

  export type RewardsUncheckedCreateWithoutUserInput = {
    id: string
    title?: string | null
    code?: string | null
    description?: string | null
  }

  export type RewardsCreateOrConnectWithoutUserInput = {
    where: RewardsWhereUniqueInput
    create: XOR<RewardsCreateWithoutUserInput, RewardsUncheckedCreateWithoutUserInput>
  }

  export type RewardsCreateManyUserInputEnvelope = {
    data: RewardsCreateManyUserInput | RewardsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SearchQueryCreateWithoutUserInput = {
    id: string
    query: string
    createdAt?: Date | string
  }

  export type SearchQueryUncheckedCreateWithoutUserInput = {
    id: string
    query: string
    createdAt?: Date | string
  }

  export type SearchQueryCreateOrConnectWithoutUserInput = {
    where: SearchQueryWhereUniqueInput
    create: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput>
  }

  export type SearchQueryCreateManyUserInputEnvelope = {
    data: SearchQueryCreateManyUserInput | SearchQueryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    token: string
    createdAt?: Date | string
    updatedAt: Date | string
    expiresAt?: Date | string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    token: string
    createdAt?: Date | string
    updatedAt: Date | string
    expiresAt?: Date | string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StaticMessagesCreateWithoutUserInput = {
    id: string
    status?: $Enums.StaticMessages_status
    message: string
    createdAt?: Date | string
  }

  export type StaticMessagesUncheckedCreateWithoutUserInput = {
    id: string
    status?: $Enums.StaticMessages_status
    message: string
    createdAt?: Date | string
  }

  export type StaticMessagesCreateOrConnectWithoutUserInput = {
    where: StaticMessagesWhereUniqueInput
    create: XOR<StaticMessagesCreateWithoutUserInput, StaticMessagesUncheckedCreateWithoutUserInput>
  }

  export type StaticMessagesCreateManyUserInputEnvelope = {
    data: StaticMessagesCreateManyUserInput | StaticMessagesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    id: string
    subject: string
    message: string
    status?: $Enums.SupportTicket_status
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id: string
    subject: string
    message: string
    status?: $Enums.SupportTicket_status
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UpdateHistoryCreateWithoutUserInput = {
    id: string
    title: string
    description: string
    createdAt?: Date | string
  }

  export type UpdateHistoryUncheckedCreateWithoutUserInput = {
    id: string
    title: string
    description: string
    createdAt?: Date | string
  }

  export type UpdateHistoryCreateOrConnectWithoutUserInput = {
    where: UpdateHistoryWhereUniqueInput
    create: XOR<UpdateHistoryCreateWithoutUserInput, UpdateHistoryUncheckedCreateWithoutUserInput>
  }

  export type UpdateHistoryCreateManyUserInputEnvelope = {
    data: UpdateHistoryCreateManyUserInput | UpdateHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOther_UserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOther_UserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOther_UserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOther_UserInput, UserUncheckedCreateWithoutOther_UserInput>
  }

  export type UserCreateWithoutUserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput>
  }

  export type UserCreateManyUserInputEnvelope = {
    data: UserCreateManyUserInput | UserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAddressCreateWithoutUserInput = {
    id: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country: string
    mobileNumber: string
    createdAt?: Date | string
    updatedAt: Date | string
    isDefault: boolean
    fullName?: string | null
    altMobileNumber?: string | null
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserAddressInput
  }

  export type UserAddressUncheckedCreateWithoutUserInput = {
    id: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country: string
    mobileNumber: string
    createdAt?: Date | string
    updatedAt: Date | string
    isDefault: boolean
    fullName?: string | null
    altMobileNumber?: string | null
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserAddressInput
  }

  export type UserAddressCreateOrConnectWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressCreateManyUserInputEnvelope = {
    data: UserAddressCreateManyUserInput | UserAddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPrivilegeCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    Privilege: PrivilegeCreateNestedOneWithoutUserPrivilegeInput
  }

  export type UserPrivilegeUncheckedCreateWithoutUserInput = {
    id: string
    privilegeId: string
    createdAt?: Date | string
  }

  export type UserPrivilegeCreateOrConnectWithoutUserInput = {
    where: UserPrivilegeWhereUniqueInput
    create: XOR<UserPrivilegeCreateWithoutUserInput, UserPrivilegeUncheckedCreateWithoutUserInput>
  }

  export type UserPrivilegeCreateManyUserInputEnvelope = {
    data: UserPrivilegeCreateManyUserInput | UserPrivilegeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WishlistItemCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    Product: ProductCreateNestedOneWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateWithoutUserInput = {
    id: string
    productId: string
    createdAt?: Date | string
  }

  export type WishlistItemCreateOrConnectWithoutUserInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput>
  }

  export type WishlistItemCreateManyUserInputEnvelope = {
    data: WishlistItemCreateManyUserInput | WishlistItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    description?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type CartItemUpsertWithWhereUniqueWithoutUserInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutUserInput, CartItemUncheckedUpdateWithoutUserInput>
    create: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutUserInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutUserInput, CartItemUncheckedUpdateWithoutUserInput>
  }

  export type CartItemUpdateManyWithWhereWithoutUserInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutUserInput>
  }

  export type DeleteRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: DeleteRequestWhereUniqueInput
    update: XOR<DeleteRequestUpdateWithoutUserInput, DeleteRequestUncheckedUpdateWithoutUserInput>
    create: XOR<DeleteRequestCreateWithoutUserInput, DeleteRequestUncheckedCreateWithoutUserInput>
  }

  export type DeleteRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: DeleteRequestWhereUniqueInput
    data: XOR<DeleteRequestUpdateWithoutUserInput, DeleteRequestUncheckedUpdateWithoutUserInput>
  }

  export type DeleteRequestUpdateManyWithWhereWithoutUserInput = {
    where: DeleteRequestScalarWhereInput
    data: XOR<DeleteRequestUpdateManyMutationInput, DeleteRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type DeleteRequestScalarWhereInput = {
    AND?: DeleteRequestScalarWhereInput | DeleteRequestScalarWhereInput[]
    OR?: DeleteRequestScalarWhereInput[]
    NOT?: DeleteRequestScalarWhereInput | DeleteRequestScalarWhereInput[]
    id?: StringFilter<"DeleteRequest"> | string
    userId?: StringNullableFilter<"DeleteRequest"> | string | null
    userName?: StringNullableFilter<"DeleteRequest"> | string | null
    userEmail?: StringNullableFilter<"DeleteRequest"> | string | null
    reason?: StringNullableFilter<"DeleteRequest"> | string | null
    status?: EnumDeleteRequest_statusFilter<"DeleteRequest"> | $Enums.DeleteRequest_status
    createdAt?: DateTimeFilter<"DeleteRequest"> | Date | string
  }

  export type DropMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: DropMessageWhereUniqueInput
    update: XOR<DropMessageUpdateWithoutUserInput, DropMessageUncheckedUpdateWithoutUserInput>
    create: XOR<DropMessageCreateWithoutUserInput, DropMessageUncheckedCreateWithoutUserInput>
  }

  export type DropMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: DropMessageWhereUniqueInput
    data: XOR<DropMessageUpdateWithoutUserInput, DropMessageUncheckedUpdateWithoutUserInput>
  }

  export type DropMessageUpdateManyWithWhereWithoutUserInput = {
    where: DropMessageScalarWhereInput
    data: XOR<DropMessageUpdateManyMutationInput, DropMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type DropMessageScalarWhereInput = {
    AND?: DropMessageScalarWhereInput | DropMessageScalarWhereInput[]
    OR?: DropMessageScalarWhereInput[]
    NOT?: DropMessageScalarWhereInput | DropMessageScalarWhereInput[]
    id?: StringFilter<"DropMessage"> | string
    userId?: StringFilter<"DropMessage"> | string
    startedAt?: DateTimeNullableFilter<"DropMessage"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"DropMessage"> | Date | string | null
    createdAt?: DateTimeFilter<"DropMessage"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutUser_Message_handledByIdToUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUser_Message_handledByIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_handledByIdToUserInput>
    create: XOR<MessageCreateWithoutUser_Message_handledByIdToUserInput, MessageUncheckedCreateWithoutUser_Message_handledByIdToUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUser_Message_handledByIdToUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUser_Message_handledByIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_handledByIdToUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUser_Message_handledByIdToUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    message?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    handledById?: StringNullableFilter<"Message"> | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutUser_Message_receiverIdToUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_receiverIdToUserInput>
    create: XOR<MessageCreateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedCreateWithoutUser_Message_receiverIdToUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUser_Message_receiverIdToUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUser_Message_receiverIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_receiverIdToUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUser_Message_receiverIdToUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutUser_Message_senderIdToUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUser_Message_senderIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_senderIdToUserInput>
    create: XOR<MessageCreateWithoutUser_Message_senderIdToUserInput, MessageUncheckedCreateWithoutUser_Message_senderIdToUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUser_Message_senderIdToUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUser_Message_senderIdToUserInput, MessageUncheckedUpdateWithoutUser_Message_senderIdToUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUser_Message_senderIdToUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    hyperLink?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
  }

  export type OrderDetailsUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderDetailsWhereUniqueInput
    update: XOR<OrderDetailsUpdateWithoutUserInput, OrderDetailsUncheckedUpdateWithoutUserInput>
    create: XOR<OrderDetailsCreateWithoutUserInput, OrderDetailsUncheckedCreateWithoutUserInput>
  }

  export type OrderDetailsUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderDetailsWhereUniqueInput
    data: XOR<OrderDetailsUpdateWithoutUserInput, OrderDetailsUncheckedUpdateWithoutUserInput>
  }

  export type OrderDetailsUpdateManyWithWhereWithoutUserInput = {
    where: OrderDetailsScalarWhereInput
    data: XOR<OrderDetailsUpdateManyMutationInput, OrderDetailsUncheckedUpdateManyWithoutUserInput>
  }

  export type OtpUpsertWithWhereUniqueWithoutUserInput = {
    where: OtpWhereUniqueInput
    update: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type OtpUpdateWithWhereUniqueWithoutUserInput = {
    where: OtpWhereUniqueInput
    data: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
  }

  export type OtpUpdateManyWithWhereWithoutUserInput = {
    where: OtpScalarWhereInput
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyWithoutUserInput>
  }

  export type OtpScalarWhereInput = {
    AND?: OtpScalarWhereInput | OtpScalarWhereInput[]
    OR?: OtpScalarWhereInput[]
    NOT?: OtpScalarWhereInput | OtpScalarWhereInput[]
    id?: StringFilter<"Otp"> | string
    userId?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    createdAt?: DateTimeFilter<"Otp"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
  }

  export type ProductUpdateManyWithWhereWithoutUserInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductReviewWhereUniqueInput
    update: XOR<ProductReviewUpdateWithoutUserInput, ProductReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput>
  }

  export type ProductReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductReviewWhereUniqueInput
    data: XOR<ProductReviewUpdateWithoutUserInput, ProductReviewUncheckedUpdateWithoutUserInput>
  }

  export type ProductReviewUpdateManyWithWhereWithoutUserInput = {
    where: ProductReviewScalarWhereInput
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type RewardsUpsertWithWhereUniqueWithoutUserInput = {
    where: RewardsWhereUniqueInput
    update: XOR<RewardsUpdateWithoutUserInput, RewardsUncheckedUpdateWithoutUserInput>
    create: XOR<RewardsCreateWithoutUserInput, RewardsUncheckedCreateWithoutUserInput>
  }

  export type RewardsUpdateWithWhereUniqueWithoutUserInput = {
    where: RewardsWhereUniqueInput
    data: XOR<RewardsUpdateWithoutUserInput, RewardsUncheckedUpdateWithoutUserInput>
  }

  export type RewardsUpdateManyWithWhereWithoutUserInput = {
    where: RewardsScalarWhereInput
    data: XOR<RewardsUpdateManyMutationInput, RewardsUncheckedUpdateManyWithoutUserInput>
  }

  export type RewardsScalarWhereInput = {
    AND?: RewardsScalarWhereInput | RewardsScalarWhereInput[]
    OR?: RewardsScalarWhereInput[]
    NOT?: RewardsScalarWhereInput | RewardsScalarWhereInput[]
    id?: StringFilter<"Rewards"> | string
    userId?: StringFilter<"Rewards"> | string
    title?: StringNullableFilter<"Rewards"> | string | null
    code?: StringNullableFilter<"Rewards"> | string | null
    description?: StringNullableFilter<"Rewards"> | string | null
  }

  export type SearchQueryUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchQueryWhereUniqueInput
    update: XOR<SearchQueryUpdateWithoutUserInput, SearchQueryUncheckedUpdateWithoutUserInput>
    create: XOR<SearchQueryCreateWithoutUserInput, SearchQueryUncheckedCreateWithoutUserInput>
  }

  export type SearchQueryUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchQueryWhereUniqueInput
    data: XOR<SearchQueryUpdateWithoutUserInput, SearchQueryUncheckedUpdateWithoutUserInput>
  }

  export type SearchQueryUpdateManyWithWhereWithoutUserInput = {
    where: SearchQueryScalarWhereInput
    data: XOR<SearchQueryUpdateManyMutationInput, SearchQueryUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchQueryScalarWhereInput = {
    AND?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
    OR?: SearchQueryScalarWhereInput[]
    NOT?: SearchQueryScalarWhereInput | SearchQueryScalarWhereInput[]
    id?: StringFilter<"SearchQuery"> | string
    query?: StringFilter<"SearchQuery"> | string
    createdAt?: DateTimeFilter<"SearchQuery"> | Date | string
    userId?: StringFilter<"SearchQuery"> | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Session"> | Date | string | null
  }

  export type StaticMessagesUpsertWithWhereUniqueWithoutUserInput = {
    where: StaticMessagesWhereUniqueInput
    update: XOR<StaticMessagesUpdateWithoutUserInput, StaticMessagesUncheckedUpdateWithoutUserInput>
    create: XOR<StaticMessagesCreateWithoutUserInput, StaticMessagesUncheckedCreateWithoutUserInput>
  }

  export type StaticMessagesUpdateWithWhereUniqueWithoutUserInput = {
    where: StaticMessagesWhereUniqueInput
    data: XOR<StaticMessagesUpdateWithoutUserInput, StaticMessagesUncheckedUpdateWithoutUserInput>
  }

  export type StaticMessagesUpdateManyWithWhereWithoutUserInput = {
    where: StaticMessagesScalarWhereInput
    data: XOR<StaticMessagesUpdateManyMutationInput, StaticMessagesUncheckedUpdateManyWithoutUserInput>
  }

  export type StaticMessagesScalarWhereInput = {
    AND?: StaticMessagesScalarWhereInput | StaticMessagesScalarWhereInput[]
    OR?: StaticMessagesScalarWhereInput[]
    NOT?: StaticMessagesScalarWhereInput | StaticMessagesScalarWhereInput[]
    id?: StringFilter<"StaticMessages"> | string
    userId?: StringFilter<"StaticMessages"> | string
    status?: EnumStaticMessages_statusFilter<"StaticMessages"> | $Enums.StaticMessages_status
    message?: StringFilter<"StaticMessages"> | string
    createdAt?: DateTimeFilter<"StaticMessages"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    message?: StringFilter<"SupportTicket"> | string
    status?: EnumSupportTicket_statusFilter<"SupportTicket"> | $Enums.SupportTicket_status
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
  }

  export type UpdateHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UpdateHistoryWhereUniqueInput
    update: XOR<UpdateHistoryUpdateWithoutUserInput, UpdateHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<UpdateHistoryCreateWithoutUserInput, UpdateHistoryUncheckedCreateWithoutUserInput>
  }

  export type UpdateHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UpdateHistoryWhereUniqueInput
    data: XOR<UpdateHistoryUpdateWithoutUserInput, UpdateHistoryUncheckedUpdateWithoutUserInput>
  }

  export type UpdateHistoryUpdateManyWithWhereWithoutUserInput = {
    where: UpdateHistoryScalarWhereInput
    data: XOR<UpdateHistoryUpdateManyMutationInput, UpdateHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UpdateHistoryScalarWhereInput = {
    AND?: UpdateHistoryScalarWhereInput | UpdateHistoryScalarWhereInput[]
    OR?: UpdateHistoryScalarWhereInput[]
    NOT?: UpdateHistoryScalarWhereInput | UpdateHistoryScalarWhereInput[]
    id?: StringFilter<"UpdateHistory"> | string
    userId?: StringFilter<"UpdateHistory"> | string
    title?: StringFilter<"UpdateHistory"> | string
    description?: StringFilter<"UpdateHistory"> | string
    createdAt?: DateTimeFilter<"UpdateHistory"> | Date | string
  }

  export type UserUpsertWithoutOther_UserInput = {
    update: XOR<UserUpdateWithoutOther_UserInput, UserUncheckedUpdateWithoutOther_UserInput>
    create: XOR<UserCreateWithoutOther_UserInput, UserUncheckedCreateWithoutOther_UserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOther_UserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOther_UserInput, UserUncheckedUpdateWithoutOther_UserInput>
  }

  export type UserUpdateWithoutOther_UserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOther_UserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutUserInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutUserInput, UserUncheckedUpdateWithoutUserInput>
    create: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput>
  }

  export type UserUpdateWithWhereUniqueWithoutUserInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutUserInput, UserUncheckedUpdateWithoutUserInput>
  }

  export type UserUpdateManyWithWhereWithoutUserInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    isVerified?: BoolFilter<"User"> | boolean
    role?: EnumUser_roleFilter<"User"> | $Enums.User_role
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    status?: EnumUser_statusFilter<"User"> | $Enums.User_status
    profileUrl?: StringNullableFilter<"User"> | string | null
    mobileNumber?: StringNullableFilter<"User"> | string | null
    whatsAppNumber?: StringNullableFilter<"User"> | string | null
    isLoggedIn?: BoolFilter<"User"> | boolean
    isViewed?: BoolFilter<"User"> | boolean
    is2FA?: BoolFilter<"User"> | boolean
    assignedStaffId?: StringNullableFilter<"User"> | string | null
  }

  export type UserAddressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    update: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    data: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserAddressUpdateManyWithWhereWithoutUserInput = {
    where: UserAddressScalarWhereInput
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAddressScalarWhereInput = {
    AND?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
    OR?: UserAddressScalarWhereInput[]
    NOT?: UserAddressScalarWhereInput | UserAddressScalarWhereInput[]
    id?: StringFilter<"UserAddress"> | string
    userId?: StringFilter<"UserAddress"> | string
    addressLine1?: StringFilter<"UserAddress"> | string
    addressLine2?: StringNullableFilter<"UserAddress"> | string | null
    city?: StringFilter<"UserAddress"> | string
    state?: StringFilter<"UserAddress"> | string
    zipCode?: StringFilter<"UserAddress"> | string
    country?: StringFilter<"UserAddress"> | string
    mobileNumber?: StringFilter<"UserAddress"> | string
    createdAt?: DateTimeFilter<"UserAddress"> | Date | string
    updatedAt?: DateTimeFilter<"UserAddress"> | Date | string
    isDefault?: BoolFilter<"UserAddress"> | boolean
    fullName?: StringNullableFilter<"UserAddress"> | string | null
    altMobileNumber?: StringNullableFilter<"UserAddress"> | string | null
  }

  export type UserPrivilegeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPrivilegeWhereUniqueInput
    update: XOR<UserPrivilegeUpdateWithoutUserInput, UserPrivilegeUncheckedUpdateWithoutUserInput>
    create: XOR<UserPrivilegeCreateWithoutUserInput, UserPrivilegeUncheckedCreateWithoutUserInput>
  }

  export type UserPrivilegeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPrivilegeWhereUniqueInput
    data: XOR<UserPrivilegeUpdateWithoutUserInput, UserPrivilegeUncheckedUpdateWithoutUserInput>
  }

  export type UserPrivilegeUpdateManyWithWhereWithoutUserInput = {
    where: UserPrivilegeScalarWhereInput
    data: XOR<UserPrivilegeUpdateManyMutationInput, UserPrivilegeUncheckedUpdateManyWithoutUserInput>
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutUserInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutUserInput, WishlistItemUncheckedUpdateWithoutUserInput>
    create: XOR<WishlistItemCreateWithoutUserInput, WishlistItemUncheckedCreateWithoutUserInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutUserInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutUserInput, WishlistItemUncheckedUpdateWithoutUserInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutUserInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderDetailsCreateWithoutUserAddressInput = {
    id: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    finalPrice?: number | null
    Discount?: DiscountCreateNestedOneWithoutOrderDetailsInput
    User: UserCreateNestedOneWithoutOrderDetailsInput
    OrderItem?: OrderItemCreateNestedManyWithoutOrderDetailsInput
    PaymentDetails?: PaymentDetailsCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsUncheckedCreateWithoutUserAddressInput = {
    id: string
    userId: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    discountId?: string | null
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    finalPrice?: number | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderDetailsInput
    PaymentDetails?: PaymentDetailsUncheckedCreateNestedManyWithoutOrderDetailsInput
  }

  export type OrderDetailsCreateOrConnectWithoutUserAddressInput = {
    where: OrderDetailsWhereUniqueInput
    create: XOR<OrderDetailsCreateWithoutUserAddressInput, OrderDetailsUncheckedCreateWithoutUserAddressInput>
  }

  export type OrderDetailsCreateManyUserAddressInputEnvelope = {
    data: OrderDetailsCreateManyUserAddressInput | OrderDetailsCreateManyUserAddressInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutUserAddressInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserAddressInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAddressInput, UserUncheckedCreateWithoutUserAddressInput>
  }

  export type OrderDetailsUpsertWithWhereUniqueWithoutUserAddressInput = {
    where: OrderDetailsWhereUniqueInput
    update: XOR<OrderDetailsUpdateWithoutUserAddressInput, OrderDetailsUncheckedUpdateWithoutUserAddressInput>
    create: XOR<OrderDetailsCreateWithoutUserAddressInput, OrderDetailsUncheckedCreateWithoutUserAddressInput>
  }

  export type OrderDetailsUpdateWithWhereUniqueWithoutUserAddressInput = {
    where: OrderDetailsWhereUniqueInput
    data: XOR<OrderDetailsUpdateWithoutUserAddressInput, OrderDetailsUncheckedUpdateWithoutUserAddressInput>
  }

  export type OrderDetailsUpdateManyWithWhereWithoutUserAddressInput = {
    where: OrderDetailsScalarWhereInput
    data: XOR<OrderDetailsUpdateManyMutationInput, OrderDetailsUncheckedUpdateManyWithoutUserAddressInput>
  }

  export type UserUpsertWithoutUserAddressInput = {
    update: XOR<UserUpdateWithoutUserAddressInput, UserUncheckedUpdateWithoutUserAddressInput>
    create: XOR<UserCreateWithoutUserAddressInput, UserUncheckedCreateWithoutUserAddressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserAddressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserAddressInput, UserUncheckedUpdateWithoutUserAddressInput>
  }

  export type UserUpdateWithoutUserAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PrivilegeCreateWithoutUserPrivilegeInput = {
    id: string
    name: string
    label?: string | null
  }

  export type PrivilegeUncheckedCreateWithoutUserPrivilegeInput = {
    id: string
    name: string
    label?: string | null
  }

  export type PrivilegeCreateOrConnectWithoutUserPrivilegeInput = {
    where: PrivilegeWhereUniqueInput
    create: XOR<PrivilegeCreateWithoutUserPrivilegeInput, PrivilegeUncheckedCreateWithoutUserPrivilegeInput>
  }

  export type UserCreateWithoutUserPrivilegeInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPrivilegeInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    WishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPrivilegeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPrivilegeInput, UserUncheckedCreateWithoutUserPrivilegeInput>
  }

  export type PrivilegeUpsertWithoutUserPrivilegeInput = {
    update: XOR<PrivilegeUpdateWithoutUserPrivilegeInput, PrivilegeUncheckedUpdateWithoutUserPrivilegeInput>
    create: XOR<PrivilegeCreateWithoutUserPrivilegeInput, PrivilegeUncheckedCreateWithoutUserPrivilegeInput>
    where?: PrivilegeWhereInput
  }

  export type PrivilegeUpdateToOneWithWhereWithoutUserPrivilegeInput = {
    where?: PrivilegeWhereInput
    data: XOR<PrivilegeUpdateWithoutUserPrivilegeInput, PrivilegeUncheckedUpdateWithoutUserPrivilegeInput>
  }

  export type PrivilegeUpdateWithoutUserPrivilegeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivilegeUncheckedUpdateWithoutUserPrivilegeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutUserPrivilegeInput = {
    update: XOR<UserUpdateWithoutUserPrivilegeInput, UserUncheckedUpdateWithoutUserPrivilegeInput>
    create: XOR<UserCreateWithoutUserPrivilegeInput, UserUncheckedCreateWithoutUserPrivilegeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPrivilegeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPrivilegeInput, UserUncheckedUpdateWithoutUserPrivilegeInput>
  }

  export type UserUpdateWithoutUserPrivilegeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPrivilegeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutWishlistItemInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemCreateNestedManyWithoutProductInput
    Discount?: DiscountCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemCreateNestedManyWithoutProductInput
    CustomerType?: CustomerTypeCreateNestedOneWithoutProductInput
    ProductFabric?: ProductFabricCreateNestedOneWithoutProductInput
    SizeChart?: SizeChartCreateNestedOneWithoutProductInput
    User: UserCreateNestedOneWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryCreateNestedManyWithoutProductInput
    Product_A?: ProductCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutWishlistItemInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
    CartItem?: CartItemUncheckedCreateNestedManyWithoutProductInput
    Discount?: DiscountUncheckedCreateNestedManyWithoutProductInput
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    ProductInventory?: ProductInventoryUncheckedCreateNestedManyWithoutProductInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    ProductCategory?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    Product_A?: ProductUncheckedCreateNestedManyWithoutProduct_BInput
    Product_B?: ProductUncheckedCreateNestedManyWithoutProduct_AInput
    SubCategory?: SubCategoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutWishlistItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
  }

  export type UserCreateWithoutWishlistItemInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    CartItem?: CartItemCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsCreateNestedManyWithoutUserInput
    Otp?: OtpCreateNestedManyWithoutUserInput
    Product?: ProductCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    Rewards?: RewardsCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryCreateNestedManyWithoutUserInput
    User?: UserCreateNestedOneWithoutOther_UserInput
    other_User?: UserCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWishlistItemInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
    assignedStaffId?: string | null
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    CartItem?: CartItemUncheckedCreateNestedManyWithoutUserInput
    DeleteRequest?: DeleteRequestUncheckedCreateNestedManyWithoutUserInput
    DropMessage?: DropMessageUncheckedCreateNestedManyWithoutUserInput
    Message_Message_handledByIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_handledByIdToUserInput
    Message_Message_receiverIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_receiverIdToUserInput
    Message_Message_senderIdToUser?: MessageUncheckedCreateNestedManyWithoutUser_Message_senderIdToUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    OrderDetails?: OrderDetailsUncheckedCreateNestedManyWithoutUserInput
    Otp?: OtpUncheckedCreateNestedManyWithoutUserInput
    Product?: ProductUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    Rewards?: RewardsUncheckedCreateNestedManyWithoutUserInput
    SearchQuery?: SearchQueryUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    StaticMessages?: StaticMessagesUncheckedCreateNestedManyWithoutUserInput
    SupportTicket?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    UpdateHistory?: UpdateHistoryUncheckedCreateNestedManyWithoutUserInput
    other_User?: UserUncheckedCreateNestedManyWithoutUserInput
    UserAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    UserPrivilege?: UserPrivilegeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWishlistItemInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWishlistItemInput, UserUncheckedCreateWithoutWishlistItemInput>
  }

  export type ProductUpsertWithoutWishlistItemInput = {
    update: XOR<ProductUpdateWithoutWishlistItemInput, ProductUncheckedUpdateWithoutWishlistItemInput>
    create: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutWishlistItemInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutWishlistItemInput, ProductUncheckedUpdateWithoutWishlistItemInput>
  }

  export type ProductUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutWishlistItemInput = {
    update: XOR<UserUpdateWithoutWishlistItemInput, UserUncheckedUpdateWithoutWishlistItemInput>
    create: XOR<UserCreateWithoutWishlistItemInput, UserUncheckedCreateWithoutWishlistItemInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWishlistItemInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWishlistItemInput, UserUncheckedUpdateWithoutWishlistItemInput>
  }

  export type UserUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    User?: UserUpdateOneWithoutOther_UserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWishlistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateManyCustomerTypeInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
  }

  export type ProductUpdateWithoutCustomerTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCustomerTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCustomerTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderDetailsCreateManyDiscountInput = {
    id: string
    userId: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    addressId?: string | null
    finalPrice?: number | null
  }

  export type OrderDetailsUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    UserAddress?: UserAddressUpdateOneWithoutOrderDetailsNestedInput
    User?: UserUpdateOneRequiredWithoutOrderDetailsNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderDetailsNestedInput
    PaymentDetails?: PaymentDetailsUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderDetailsNestedInput
    PaymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateManyWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OrderItemCreateManyOrderDetailsInput = {
    id: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    colorId?: string | null
    imageId?: string | null
    isReviewed?: boolean
  }

  export type PaymentDetailsCreateManyOrderDetailsInput = {
    id: string
    amount: number
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: string | null
    currency: string
    method: string
    order_id: string
    payment_id: string
    upi?: string | null
    wallet?: string | null
  }

  export type OrderItemUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ProductColor?: ProductColorUpdateOneWithoutOrderItemNestedInput
    ProductImage?: ProductImageUpdateOneWithoutOrderItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
    ProductSize?: ProductSizeUpdateOneWithoutOrderItemNestedInput
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentDetailsUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentDetailsUncheckedUpdateWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentDetailsUncheckedUpdateManyWithoutOrderDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
    upi?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReturnRequestCreateManyOrderItemInput = {
    id: string
    reason: string
    status?: $Enums.ReturnRequest_status
    requestedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReturnRequestUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnRequest_statusFieldUpdateOperationsInput | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnRequestUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnRequest_statusFieldUpdateOperationsInput | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnRequestUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReturnRequest_statusFieldUpdateOperationsInput | $Enums.ReturnRequest_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPrivilegeCreateManyPrivilegeInput = {
    id: string
    userId: string
    createdAt?: Date | string
  }

  export type UserPrivilegeUpdateWithoutPrivilegeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutUserPrivilegeNestedInput
  }

  export type UserPrivilegeUncheckedUpdateWithoutPrivilegeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPrivilegeUncheckedUpdateManyWithoutPrivilegeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyProductInput = {
    id: string
    userId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    sizeId?: string | null
    imageId?: string | null
  }

  export type DiscountCreateManyProductInput = {
    id: string
    code: string
    description?: string | null
    amount: number
    type: $Enums.Discount_type
    createdAt?: Date | string
    updatedAt: Date | string
    maxPrice?: number | null
    minPrice?: number | null
    isActive?: boolean
    isSpecial?: boolean
    orders?: number | null
    userEmails: JsonNullValueInput | InputJsonValue
    isWebAvailable?: boolean
    isCODAvailable?: boolean
  }

  export type OrderItemCreateManyProductInput = {
    id: string
    orderId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    colorId?: string | null
    imageId?: string | null
    isReviewed?: boolean
  }

  export type ProductImageCreateManyProductInput = {
    id: string
    imageUrl: string
    colorId?: string | null
    altText?: string | null
    caption?: string | null
  }

  export type ProductInventoryCreateManyProductInput = {
    id: string
    mrp: number
    price: number
    sizeId?: string | null
    stock: number
    minQuantity?: number
    discount?: number | null
  }

  export type ProductReviewCreateManyProductInput = {
    id: string
    userId: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    images: JsonNullValueInput | InputJsonValue
  }

  export type WishlistItemCreateManyProductInput = {
    id: string
    userId: string
    createdAt?: Date | string
  }

  export type CartItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductColor?: ProductColorUpdateOneWithoutCartItemNestedInput
    ProductImage?: ProductImageUpdateOneWithoutCartItemNestedInput
    User?: UserUpdateOneRequiredWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiscountUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumDiscount_typeFieldUpdateOperationsInput | $Enums.Discount_type
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    orders?: NullableIntFieldUpdateOperationsInput | number | null
    userEmails?: JsonNullValueInput | InputJsonValue
    isWebAvailable?: BoolFieldUpdateOperationsInput | boolean
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    OrderDetails?: OrderDetailsUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumDiscount_typeFieldUpdateOperationsInput | $Enums.Discount_type
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    orders?: NullableIntFieldUpdateOperationsInput | number | null
    userEmails?: JsonNullValueInput | InputJsonValue
    isWebAvailable?: BoolFieldUpdateOperationsInput | boolean
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumDiscount_typeFieldUpdateOperationsInput | $Enums.Discount_type
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    minPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSpecial?: BoolFieldUpdateOperationsInput | boolean
    orders?: NullableIntFieldUpdateOperationsInput | number | null
    userEmails?: JsonNullValueInput | InputJsonValue
    isWebAvailable?: BoolFieldUpdateOperationsInput | boolean
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ProductColor?: ProductColorUpdateOneWithoutOrderItemNestedInput
    ProductImage?: ProductImageUpdateOneWithoutOrderItemNestedInput
    OrderDetails?: OrderDetailsUpdateOneRequiredWithoutOrderItemNestedInput
    ProductSize?: ProductSizeUpdateOneWithoutOrderItemNestedInput
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductImageNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductImageNestedInput
    ProductColor?: ProductColorUpdateOneWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductImageNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductInventoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    ProductSize?: ProductSizeUpdateOneWithoutProductInventoryNestedInput
  }

  export type ProductInventoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductInventoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
    User?: UserUpdateOneRequiredWithoutProductReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
  }

  export type ProductReviewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
  }

  export type WishlistItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    AnchorText?: AnchorTextUpdateOneWithoutProductCategoryNestedInput
    Quotes?: QuotesUpdateManyWithoutProductCategoryNestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    AnchorText?: AnchorTextUncheckedUpdateOneWithoutProductCategoryNestedInput
    Quotes?: QuotesUncheckedUpdateManyWithoutProductCategoryNestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutProduct_BInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProduct_BInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProduct_BInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutProduct_AInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProduct_AInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProduct_AInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubCategoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubCategoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotesCreateManyProductCategoryInput = {
    id: string
    text?: string | null
    imageUrl?: string | null
    hyperLink?: string | null
  }

  export type SubCategoryCreateManyProductCategoryInput = {
    id: string
    name: string
    slug: string
    imageUrl?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
  }

  export type QuotesUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotesUncheckedUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotesUncheckedUpdateManyWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubCategoryUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateManyWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemCreateManyProductColorInput = {
    id: string
    userId: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    imageId?: string | null
  }

  export type OrderItemCreateManyProductColorInput = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    imageId?: string | null
    isReviewed?: boolean
  }

  export type ProductImageCreateManyProductColorInput = {
    id: string
    productId: string
    imageUrl: string
    altText?: string | null
    caption?: string | null
  }

  export type CartItemUpdateWithoutProductColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductImage?: ProductImageUpdateOneWithoutCartItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    User?: UserUpdateOneRequiredWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemUncheckedUpdateManyWithoutProductColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUpdateWithoutProductColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ProductImage?: ProductImageUpdateOneWithoutOrderItemNestedInput
    OrderDetails?: OrderDetailsUpdateOneRequiredWithoutOrderItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
    ProductSize?: ProductSizeUpdateOneWithoutOrderItemNestedInput
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutProductColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUpdateWithoutProductColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductImageNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductImageNestedInput
    Product?: ProductUpdateOneRequiredWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateWithoutProductColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductImageNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateManyWithoutProductColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyProductFabricInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
  }

  export type ProductUpdateWithoutProductFabricInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductFabricInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductFabricInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemCreateManyProductImageInput = {
    id: string
    userId: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    sizeId?: string | null
  }

  export type OrderItemCreateManyProductImageInput = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    sizeId?: string | null
    colorId?: string | null
    isReviewed?: boolean
  }

  export type CartItemUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductColor?: ProductColorUpdateOneWithoutCartItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
    User?: UserUpdateOneRequiredWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemUncheckedUpdateManyWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ProductColor?: ProductColorUpdateOneWithoutOrderItemNestedInput
    OrderDetails?: OrderDetailsUpdateOneRequiredWithoutOrderItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
    ProductSize?: ProductSizeUpdateOneWithoutOrderItemNestedInput
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutProductImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemCreateManyProductSizeInput = {
    id: string
    orderId: string
    productId: string
    quantity: number
    price: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    imageId?: string | null
    isReviewed?: boolean
  }

  export type ProductInventoryCreateManyProductSizeInput = {
    id: string
    productId: string
    mrp: number
    price: number
    stock: number
    minQuantity?: number
    discount?: number | null
  }

  export type OrderItemUpdateWithoutProductSizeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ProductColor?: ProductColorUpdateOneWithoutOrderItemNestedInput
    ProductImage?: ProductImageUpdateOneWithoutOrderItemNestedInput
    OrderDetails?: OrderDetailsUpdateOneRequiredWithoutOrderItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutOrderItemNestedInput
    ReturnRequest?: ReturnRequestUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductSizeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
    ReturnRequest?: ReturnRequestUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutProductSizeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    isReviewed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductInventoryUpdateWithoutProductSizeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    Product?: ProductUpdateOneRequiredWithoutProductInventoryNestedInput
  }

  export type ProductInventoryUncheckedUpdateWithoutProductSizeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProductInventoryUncheckedUpdateManyWithoutProductSizeInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    mrp?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ShopByOccasionProductCreateManyShopByOccasionInput = {
    id: string
    imageUrl: string
    hyperLink: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ShopByOccasionProductUpdateWithoutShopByOccasionInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopByOccasionProductUncheckedUpdateWithoutShopByOccasionInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopByOccasionProductUncheckedUpdateManyWithoutShopByOccasionInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    hyperLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopBySeasonProductCreateManyShopBySeasonInput = {
    id: string
    imageUrl: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    hyperLink: string
  }

  export type ShopBySeasonProductUpdateWithoutShopBySeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: StringFieldUpdateOperationsInput | string
  }

  export type ShopBySeasonProductUncheckedUpdateWithoutShopBySeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: StringFieldUpdateOperationsInput | string
  }

  export type ShopBySeasonProductUncheckedUpdateManyWithoutShopBySeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManySizeChartInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    userId: string
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
  }

  export type ProductUpdateWithoutSizeChartInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSizeChartInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSizeChartInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    User?: UserUpdateOneRequiredWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
  }

  export type ProductUncheckedUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id: string
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type CartItemCreateManyUserInput = {
    id: string
    productId: string
    quantity: number
    createdAt?: Date | string
    updatedAt: Date | string
    colorId?: string | null
    sizeId?: string | null
    imageId?: string | null
  }

  export type DeleteRequestCreateManyUserInput = {
    id: string
    userName?: string | null
    userEmail?: string | null
    reason?: string | null
    status?: $Enums.DeleteRequest_status
    createdAt?: Date | string
  }

  export type DropMessageCreateManyUserInput = {
    id: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyUser_Message_handledByIdToUserInput = {
    id: string
    senderId: string
    receiverId: string
    message: string
    createdAt?: Date | string
  }

  export type MessageCreateManyUser_Message_receiverIdToUserInput = {
    id: string
    senderId: string
    message: string
    createdAt?: Date | string
    handledById?: string | null
  }

  export type MessageCreateManyUser_Message_senderIdToUserInput = {
    id: string
    receiverId: string
    message: string
    createdAt?: Date | string
    handledById?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id: string
    message?: string | null
    isRead?: boolean
    createdAt?: Date | string
    hyperLink?: string | null
    title: string
  }

  export type OrderDetailsCreateManyUserInput = {
    id: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    discountId?: string | null
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    addressId?: string | null
    finalPrice?: number | null
  }

  export type OtpCreateManyUserInput = {
    id: string
    code: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ProductCreateManyUserInput = {
    id: string
    slug: string
    isReturnable?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    thumbnailUrl: string
    isActive?: boolean
    description?: string | null
    summary?: string | null
    customerTypeId?: string | null
    estimatedDeliveryDay?: number | null
    styleId: string
    title: string
    returnPolicy?: string | null
    views?: number
    displayPrice?: number
    tags: JsonNullValueInput | InputJsonValue
    longTailKeyword?: string | null
    affiliateId: string
    isCODAvailable?: boolean
    ogImage?: string | null
    sellerCode?: string | null
    sizeChartId?: string | null
    fabricId?: string | null
    seoTitle?: string | null
    seoDescription?: string | null
  }

  export type ProductReviewCreateManyUserInput = {
    id: string
    productId: string
    rating: number
    review?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    images: JsonNullValueInput | InputJsonValue
  }

  export type RewardsCreateManyUserInput = {
    id: string
    title?: string | null
    code?: string | null
    description?: string | null
  }

  export type SearchQueryCreateManyUserInput = {
    id: string
    query: string
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id: string
    token: string
    createdAt?: Date | string
    updatedAt: Date | string
    expiresAt?: Date | string | null
  }

  export type StaticMessagesCreateManyUserInput = {
    id: string
    status?: $Enums.StaticMessages_status
    message: string
    createdAt?: Date | string
  }

  export type SupportTicketCreateManyUserInput = {
    id: string
    subject: string
    message: string
    status?: $Enums.SupportTicket_status
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type UpdateHistoryCreateManyUserInput = {
    id: string
    title: string
    description: string
    createdAt?: Date | string
  }

  export type UserCreateManyUserInput = {
    id: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt: Date | string
    isVerified?: boolean
    role?: $Enums.User_role
    firstName?: string | null
    lastName?: string | null
    status?: $Enums.User_status
    profileUrl?: string | null
    mobileNumber?: string | null
    whatsAppNumber?: string | null
    isLoggedIn?: boolean
    isViewed?: boolean
    is2FA?: boolean
  }

  export type UserAddressCreateManyUserInput = {
    id: string
    addressLine1: string
    addressLine2?: string | null
    city: string
    state: string
    zipCode: string
    country: string
    mobileNumber: string
    createdAt?: Date | string
    updatedAt: Date | string
    isDefault: boolean
    fullName?: string | null
    altMobileNumber?: string | null
  }

  export type UserPrivilegeCreateManyUserInput = {
    id: string
    privilegeId: string
    createdAt?: Date | string
  }

  export type WishlistItemCreateManyUserInput = {
    id: string
    productId: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    ProductColor?: ProductColorUpdateOneWithoutCartItemNestedInput
    ProductImage?: ProductImageUpdateOneWithoutCartItemNestedInput
    Product?: ProductUpdateOneRequiredWithoutCartItemNestedInput
  }

  export type CartItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    sizeId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeleteRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeleteRequest_statusFieldUpdateOperationsInput | $Enums.DeleteRequest_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeleteRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeleteRequest_statusFieldUpdateOperationsInput | $Enums.DeleteRequest_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeleteRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDeleteRequest_statusFieldUpdateOperationsInput | $Enums.DeleteRequest_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutUser_Message_handledByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Message_receiverIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_receiverIdToUserNestedInput
    User_Message_senderIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_senderIdToUserNestedInput
  }

  export type MessageUncheckedUpdateWithoutUser_Message_handledByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutUser_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Message_handledByIdToUser?: UserUpdateOneWithoutMessage_Message_handledByIdToUserNestedInput
    User_Message_senderIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_senderIdToUserNestedInput
  }

  export type MessageUncheckedUpdateWithoutUser_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateWithoutUser_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Message_handledByIdToUser?: UserUpdateOneWithoutMessage_Message_handledByIdToUserNestedInput
    User_Message_receiverIdToUser?: UserUpdateOneRequiredWithoutMessage_Message_receiverIdToUserNestedInput
  }

  export type MessageUncheckedUpdateWithoutUser_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hyperLink?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
  }

  export type OrderDetailsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    UserAddress?: UserAddressUpdateOneWithoutOrderDetailsNestedInput
    Discount?: DiscountUpdateOneWithoutOrderDetailsNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderDetailsNestedInput
    PaymentDetails?: PaymentDetailsUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderDetailsNestedInput
    PaymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OtpUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUpdateManyWithoutProductNestedInput
    Discount?: DiscountUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUpdateManyWithoutProductNestedInput
    CustomerType?: CustomerTypeUpdateOneWithoutProductNestedInput
    ProductFabric?: ProductFabricUpdateOneWithoutProductNestedInput
    SizeChart?: SizeChartUpdateOneWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUpdateManyWithoutProductNestedInput
    Product_A?: ProductUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    CartItem?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    Discount?: DiscountUncheckedUpdateManyWithoutProductNestedInput
    OrderItem?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    ProductInventory?: ProductInventoryUncheckedUpdateManyWithoutProductNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    ProductCategory?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    Product_A?: ProductUncheckedUpdateManyWithoutProduct_BNestedInput
    Product_B?: ProductUncheckedUpdateManyWithoutProduct_ANestedInput
    SubCategory?: SubCategoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isReturnable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    customerTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDeliveryDay?: NullableIntFieldUpdateOperationsInput | number | null
    styleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    returnPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    displayPrice?: FloatFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    longTailKeyword?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateId?: StringFieldUpdateOperationsInput | string
    isCODAvailable?: BoolFieldUpdateOperationsInput | boolean
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    sellerCode?: NullableStringFieldUpdateOperationsInput | string | null
    sizeChartId?: NullableStringFieldUpdateOperationsInput | string | null
    fabricId?: NullableStringFieldUpdateOperationsInput | string | null
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
    Product?: ProductUpdateOneRequiredWithoutProductReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
  }

  export type ProductReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: JsonNullValueInput | InputJsonValue
  }

  export type RewardsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SearchQueryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchQueryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StaticMessagesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaticMessages_statusFieldUpdateOperationsInput | $Enums.StaticMessages_status
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticMessagesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaticMessages_statusFieldUpdateOperationsInput | $Enums.StaticMessages_status
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaticMessagesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStaticMessages_statusFieldUpdateOperationsInput | $Enums.StaticMessages_status
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicket_statusFieldUpdateOperationsInput | $Enums.SupportTicket_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicket_statusFieldUpdateOperationsInput | $Enums.SupportTicket_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicket_statusFieldUpdateOperationsInput | $Enums.SupportTicket_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UpdateHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpdateHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpdateHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUpdateManyWithoutUserNestedInput
    Otp?: OtpUpdateManyWithoutUserNestedInput
    Product?: ProductUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUpdateManyWithoutUserNestedInput
    other_User?: UserUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    CartItem?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    DeleteRequest?: DeleteRequestUncheckedUpdateManyWithoutUserNestedInput
    DropMessage?: DropMessageUncheckedUpdateManyWithoutUserNestedInput
    Message_Message_handledByIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_handledByIdToUserNestedInput
    Message_Message_receiverIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_receiverIdToUserNestedInput
    Message_Message_senderIdToUser?: MessageUncheckedUpdateManyWithoutUser_Message_senderIdToUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserNestedInput
    Otp?: OtpUncheckedUpdateManyWithoutUserNestedInput
    Product?: ProductUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    Rewards?: RewardsUncheckedUpdateManyWithoutUserNestedInput
    SearchQuery?: SearchQueryUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    StaticMessages?: StaticMessagesUncheckedUpdateManyWithoutUserNestedInput
    SupportTicket?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    UpdateHistory?: UpdateHistoryUncheckedUpdateManyWithoutUserNestedInput
    other_User?: UserUncheckedUpdateManyWithoutUserNestedInput
    UserAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    UserPrivilege?: UserPrivilegeUncheckedUpdateManyWithoutUserNestedInput
    WishlistItem?: WishlistItemUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUser_roleFieldUpdateOperationsInput | $Enums.User_role
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUser_statusFieldUpdateOperationsInput | $Enums.User_status
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    whatsAppNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isLoggedIn?: BoolFieldUpdateOperationsInput | boolean
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    is2FA?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    altMobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDetails?: OrderDetailsUpdateManyWithoutUserAddressNestedInput
  }

  export type UserAddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    altMobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OrderDetails?: OrderDetailsUncheckedUpdateManyWithoutUserAddressNestedInput
  }

  export type UserAddressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    altMobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPrivilegeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Privilege?: PrivilegeUpdateOneRequiredWithoutUserPrivilegeNestedInput
  }

  export type UserPrivilegeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    privilegeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPrivilegeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    privilegeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Product?: ProductUpdateOneRequiredWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WishlistItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderDetailsCreateManyUserAddressInput = {
    id: string
    userId: string
    totalPrice: number
    status: $Enums.OrderDetails_status
    createdAt?: Date | string
    updatedAt: Date | string
    discountId?: string | null
    orderId: string
    paymentMethod?: $Enums.OrderDetails_paymentMethod | null
    notes?: string | null
    trackingId?: string | null
    finalPrice?: number | null
  }

  export type OrderDetailsUpdateWithoutUserAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    Discount?: DiscountUpdateOneWithoutOrderDetailsNestedInput
    User?: UserUpdateOneRequiredWithoutOrderDetailsNestedInput
    OrderItem?: OrderItemUpdateManyWithoutOrderDetailsNestedInput
    PaymentDetails?: PaymentDetailsUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateWithoutUserAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderDetailsNestedInput
    PaymentDetails?: PaymentDetailsUncheckedUpdateManyWithoutOrderDetailsNestedInput
  }

  export type OrderDetailsUncheckedUpdateManyWithoutUserAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumOrderDetails_statusFieldUpdateOperationsInput | $Enums.OrderDetails_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumOrderDetails_paymentMethodFieldUpdateOperationsInput | $Enums.OrderDetails_paymentMethod | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    trackingId?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}